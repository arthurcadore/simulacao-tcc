{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Simulador ARGOS-3","text":"<p>O Simulador ARGOS-3 \u00e9 uma ferramenta computacional desenvolvida em Python com o objetivo de estudar, analisar e validar a comunica\u00e7\u00e3o via sat\u00e9lite no padr\u00e3o ARGOS-III.  </p> <p>O padr\u00e3o ARGOS-3 \u00e9 empregado pelo Sistema Brasileiro de Coleta de Dados Ambientais (SBCDA), sob responsabilidade do Instituto Nacional de Pesquisas Espaciais (INPE), para o recebimento de informa\u00e7\u00f5es provenientes de milhares de Plataformas de Coleta de Dados (PCDs) distribu\u00eddas em todo o territ\u00f3rio nacional. As transmiss\u00f5es realizadas pelas PCDs s\u00e3o retransmitidas por sat\u00e9lites como o SCD-1, SCD-2 e pela s\u00e9rie CBERS, que orbitam a aproximadamente 750 km de altitude.  </p> <p> </p> <p>O simulador foi projetado para reproduzir os principais aspectos e desafios da comunica\u00e7\u00e3o com sat\u00e9lites, incorporando conceitos fundamentais, tais como:</p> <ul> <li>T\u00e9cnicas de modula\u00e7\u00e3o, codifica\u00e7\u00e3o e sincroniza\u00e7\u00e3o de sinais  </li> <li>Modelagem de efeitos de canal, incluindo ru\u00eddo, interfer\u00eancias e atenua\u00e7\u00e3o</li> </ul> <p>Este reposit\u00f3rio consolida a documenta\u00e7\u00e3o, os testes e os resultados de simula\u00e7\u00e3o do ARGOS-3, constituindo uma base de refer\u00eancia para pesquisas acad\u00eamicas, iniciativas de desenvolvimento tecnol\u00f3gico e aplica\u00e7\u00f5es em monitoramento ambiental no Brasil.</p>"},{"location":"api/bersnr/","title":"BER vs SNR","text":"<p>Implementa\u00e7\u00e3o de simula\u00e7\u00e3o para curva BER vs SNR. </p> <p>Autor: Arthur Cadore Data: 28-07-2025</p>"},{"location":"api/bersnr/#bersnr.simulate_ber","title":"<code>simulate_ber(snr_db, numblocks=8, fs=128000, Rb=400)</code>","text":"<p>Simula a transmiss\u00e3o e recep\u00e7\u00e3o de um datagrama ARGOS-III, para um dado SNR.</p> <p>Parameters:</p> Name Type Description Default <code>snr_db</code> <code>float</code> <p>Rela\u00e7\u00e3o sinal-ru\u00eddo em decib\u00e9is.</p> required <code>numblocks</code> <code>int</code> <p>N\u00famero de blocos a serem transmitidos.</p> <code>8</code> <code>fs</code> <code>int</code> <p>Frequ\u00eancia de amostragem.</p> <code>128000</code> <code>Rb</code> <code>int</code> <p>Taxa de bits. </p> <code>400</code> <p>Returns:</p> Name Type Description <code>ber</code> <code>float</code> <p>A taxa de erro de bit (BER) simulada.</p>"},{"location":"api/bersnr/#bersnr.run_simulation","title":"<code>run_simulation(SNR_values=np.arange(-30, 31, 1), repetitions=10, numblocks=1, num_workers=16)</code>","text":"<p>Executa a simula\u00e7\u00e3o completa de BER vs SNR. Retorna a tupla BER vs SNR.</p> <p>Parameters:</p> Name Type Description Default <code>SNR_values</code> <code>ndarray</code> <p>Valores de SNR a serem simulados.</p> <code>arange(-30, 31, 1)</code> <code>repetitions</code> <code>int</code> <p>N\u00famero de repeti\u00e7\u00f5es para cada valor de SNR.</p> <code>10</code> <code>numblocks</code> <code>int</code> <p>N\u00famero de blocos a serem transmitidos.</p> <code>1</code> <code>num_workers</code> <code>int</code> <p>N\u00famero de trabalhadores para a execu\u00e7\u00e3o paralela.</p> <code>16</code> <p>Returns:</p> Name Type Description <code>list</code> <p>Lista de tuplas (SNR, BER_m\u00e9dio).</p>"},{"location":"api/bersnr/#bersnr.save_results","title":"<code>save_results(results, filename='../out/snr_vs_ber.txt')</code>","text":"<p>Salva os resultados de simula\u00e7\u00e3o em um arquivo .txt </p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>list</code> <p>Lista de tuplas (SNR, BER) a serem salvas.</p> required <code>filename</code> <code>str</code> <p>Caminho do arquivo de sa\u00edda.</p> <code>'../out/snr_vs_ber.txt'</code>"},{"location":"api/bersnr/#bersnr.plot_from_file","title":"<code>plot_from_file(filename='../out/snr_vs_ber.txt', out_pdf='../out/snr_vs_ber.pdf')</code>","text":"<p>L\u00ea os resultados do arquivo TXT (relativo ao diret\u00f3rio do script) e gera o gr\u00e1fico BER vs SNR em PDF.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Caminho do arquivo de entrada.</p> <code>'../out/snr_vs_ber.txt'</code> <code>out_pdf</code> <code>str</code> <p>Caminho do arquivo PDF de sa\u00edda. </p> <code>'../out/snr_vs_ber.pdf'</code> <p></p>"},{"location":"api/convolutional/","title":"Convolutional Encoder","text":""},{"location":"api/convolutional/#convolutional.EncoderConvolutional.__init__","title":"<code>__init__(G=np.array([[121, 91]]))</code>","text":"<p>Inicializa o codificador convolucional com matriz de geradores.</p> Refer\u00eancia <ul> <li>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.4)</li> <li>CCSDS 131.1-G-2</li> </ul> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>ndarray</code> <p>Matriz de polin\u00f4mios geradores em formato bin\u00e1rio.</p> <code>array([[121, 91]])</code> Nota <ul> <li>O polin\u00f4mio gerador \\(G_0\\) \u00e9 representado por <code>G[0][0]</code> e \\(G_1\\) por <code>G[0][1]</code>.</li> <li>\\(G_0\\) \u00e9 definido como \\(1111001_{2}\\) ou \\(121_{10}\\)</li> <li>\\(G_1\\) \u00e9 definido como \\(1011011_{2}\\) ou \\(91_{10}\\)</li> </ul>"},{"location":"api/convolutional/#convolutional.EncoderConvolutional.calc_taps","title":"<code>calc_taps(poly)</code>","text":"<p>Calcula os \u00edndices (\"taps\") dos bits ativos (ou seja, bits \\('1'\\)) no polin\u00f4mio gerador.</p> <p>Parameters:</p> Name Type Description Default <code>poly</code> <code>int</code> <p>Polin\u00f4mio em formato bin\u00e1rio. </p> required <p>Returns:</p> Name Type Description <code>taps</code> <code>int</code> <p>Lista com os \u00edndices dos taps ativos.</p>"},{"location":"api/convolutional/#convolutional.EncoderConvolutional.calc_free_distance","title":"<code>calc_free_distance()</code>","text":"<p>Calcula a dist\u00e2ncia livre do c\u00f3digo convolucional, definida como a menor dist\u00e2ncia de Hamming entre quaisquer duas sequ\u00eancias de sa\u00edda distintas.</p> <p>Returns:</p> Name Type Description <code>dist</code> <code>int</code> <p>Dist\u00e2ncia livre do c\u00f3digo.</p>"},{"location":"api/convolutional/#convolutional.EncoderConvolutional.encode","title":"<code>encode(input_bits)</code>","text":"<p>Codifica uma sequ\u00eancia bin\u00e1ria de entrada \\(u_t\\) utilizando os registradores deslizantes e os taps.</p> <p>Parameters:</p> Name Type Description Default <code>input_bits</code> <code>ndarray</code> <p>Vetor de bits \\(u_t\\) de entrada a serem codificados.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>(ndarray, ndarray)</code> <p>Tupla com os dois canais de sa\u00edda \\(v_t^{(0)}\\) e \\(v_t^{(1)}\\).</p>"},{"location":"api/convolutional/#convolutional-decoder-viterbi","title":"Convolutional Decoder (Viterbi)","text":"<p>Implementa o decodificador Viterbi, no padr\u00e3o CCSDS 131.1-G-2, utilizado no PTT-A3.</p> Refer\u00eancia <p>AS3-SP-516-274-CNES (3.1.4.4)</p>"},{"location":"api/convolutional/#convolutional.DecoderViterbi.__init__","title":"<code>__init__(G=np.array([[121, 91]]))</code>","text":"<p>Inicializa o decodificador Convolucional.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>ndarray</code> <p>Matriz de polin\u00f4mios geradores.</p> <code>array([[121, 91]])</code>"},{"location":"api/convolutional/#convolutional.DecoderViterbi.build_trellis","title":"<code>build_trellis()</code>","text":"<p>Constroi a trelica do decodificador Viterbi.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Trelica do decodificador Viterbi.</p>"},{"location":"api/convolutional/#convolutional.DecoderViterbi.decode","title":"<code>decode(vt0, vt1)</code>","text":"<p>Decodifica os bits de entrada.</p> <p>Parameters:</p> Name Type Description Default <code>vt0</code> <code>ndarray</code> <p>Bits de entrada do canal I.</p> required <code>vt1</code> <code>ndarray</code> <p>Bits de entrada do canal Q.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Bits decodificados.</p>"},{"location":"api/datagram/","title":"Datagram","text":""},{"location":"api/datagram/#datagram.Datagram.__init__","title":"<code>__init__(pcdnum=None, numblocks=None, streambits=None)</code>","text":"<p>Inicializa uma inst\u00e2ncia do datagrama.</p> Refer\u00eancia <p>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4).</p> <p>Parameters:</p> Name Type Description Default <code>pcdnum</code> <code>int</code> <p>N\u00famero identificador da PCD. Necess\u00e1rio para o modo TX.</p> <code>None</code> <code>numblocks</code> <code>int</code> <p>Quantidade de blocos de dados (1 a 8). Necess\u00e1rio para o modo TX.</p> <code>None</code> <code>streambits</code> <code>ndarray</code> <p>Sequ\u00eancia de bits do datagrama. Necess\u00e1rio para o modo RX.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se o n\u00famero de blocos n\u00e3o estiver entre 1 e 8.</p> <code>ValueError</code> <p>Se o n\u00famero PCD n\u00e3o estiver entre 0 e 1048575 \\((2^{20} - 1)\\).</p> <code>ValueError</code> <p>Se os par\u00e2metros <code>pcdnum</code> e <code>numblocks</code> ou <code>streambits</code> n\u00e3o forem fornecidos.</p>"},{"location":"api/datagram/#datagram.Datagram.generate_blocks","title":"<code>generate_blocks()</code>","text":"<p>Gera os blocos de dados simulados (valores aleat\u00f3rios), com base na quantidade especificada de blocos.</p> Refer\u00eancia <p>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.2)</p> <p>Returns:</p> Name Type Description <code>blocks</code> <code>ndarray</code> <p>Vetor de bits representando os blocos de dados.</p>"},{"location":"api/datagram/#datagram.Datagram.generate_pcdid","title":"<code>generate_pcdid()</code>","text":"<p>Gera o campo PCD ID a partir do n\u00famero PCD, incluindo um checksum de 8 bits.</p> Refer\u00eancia <p>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.2)</p> <p>Returns:</p> Name Type Description <code>pcd_id</code> <code>ndarray</code> <p>Vetor de bits contendo o PCD ID e o checksum.</p>"},{"location":"api/datagram/#datagram.Datagram.generate_msglength","title":"<code>generate_msglength()</code>","text":"<p>Gera o campo Message Length com base na quantidade de blocos e calcula o bit de paridade.</p> Refer\u00eancia <p>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.2)</p> <p>Returns:</p> Name Type Description <code>msg_length</code> <code>ndarray</code> <p>Vetor de 4 bits representando o campo Message Length.</p>"},{"location":"api/datagram/#datagram.Datagram.generate_tail","title":"<code>generate_tail()</code>","text":"<p>Gera o campo Tail (cauda), utilizado para esvaziar o registrador do codificador convolucional.</p> Refer\u00eancia <p>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.3)</p> <p>Returns:</p> Name Type Description <code>tail</code> <code>ndarray</code> <p>Vetor de bits zerados com comprimento vari\u00e1vel (7, 8 ou 9 bits).</p>"},{"location":"api/datagram/#datagram.Datagram.parse_datagram","title":"<code>parse_datagram()</code>","text":"<p>Faz o parsing da sequ\u00eancia de bits do datagrama, extraindo campos e validando integridade.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>json</code> <p>Objeto JSON contendo a representa\u00e7\u00e3o estruturada do datagrama.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Caso haja falha nas valida\u00e7\u00f5es de paridade de Message Length.</p> <code>ValueError</code> <p>Caso haja falha no checksum do campo PCD ID.</p> <code>ValueError</code> <p>Se a sequ\u00eancia de bits n\u00e3o for v\u00e1lida ou n\u00e3o puder ser convertida para json.</p> <p>Examples:</p> <pre><code>    &gt;&gt;&gt; datagram = Datagram(streambits=bits)\n    &gt;&gt;&gt; print(datagram.parse_datagram())\n        {\n          \"msglength\": 2,\n          \"pcdid\": 1234,\n          \"data\": {\n            \"bloco_1\": {\n              \"sensor_1\": 42,\n              \"sensor_2\": 147,\n              \"sensor_3\": 75\n            },\n            \"bloco_2\": {\n              \"sensor_1\": 138,\n              \"sensor_2\": 7,\n              \"sensor_3\": 134,\n              \"sensor_4\": 182\n            }\n          },\n          \"tail\": 8\n        }\n</code></pre>"},{"location":"api/encoder/","title":"Encoder","text":""},{"location":"api/encoder/#encoder.Encoder.__init__","title":"<code>__init__(method)</code>","text":"<p>Inicializa uma inst\u00e2ncia do codificador com o m\u00e9todo especificado.</p> Refer\u00eancia <p>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.2.4)</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>M\u00e9todo de codifica\u00e7\u00e3o ('NRZ' ou 'Manchester').</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Se o m\u00e9todo de codifica\u00e7\u00e3o n\u00e3o for suportado.</p>"},{"location":"api/encoder/#encoder.Encoder.encode","title":"<code>encode(bitstream)</code>","text":"<p>Codifica o vetor de bits usando o m\u00e9todo especificado na inicializa\u00e7\u00e3o.</p> <p>Parameters:</p> Name Type Description Default <code>bitstream</code> <code>ndarray</code> <p>Vetor de bits a ser codificado.</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>ndarray</code> <p>Vetor de bits codificado.</p>"},{"location":"api/encoder/#encoder.Encoder.decode","title":"<code>decode(encoded_stream)</code>","text":"<p>Decodifica o vetor codificado de volta para o vetor original.</p> <p>Parameters:</p> Name Type Description Default <code>encoded_stream</code> <code>ndarray</code> <p>Vetor codificado a ser decodificado.</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>ndarray</code> <p>Vetor de bits decodificado.</p>"},{"location":"api/formatter/","title":"Formatter","text":""},{"location":"api/formatter/#formatter.Formatter.__init__","title":"<code>__init__(alpha=0.8, fs=128000, Rb=400, span=6, type='RRC')</code>","text":"<p>Inicializa uma inst\u00e2ncia de formatador de pulso. O pulso formatador \u00e9 usado para preparar os s\u00edmbolos nos canais I e Q para transmiss\u00e3o.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>Fator de roll-off do pulso RRC.</p> <code>0.8</code> <code>fs</code> <code>int</code> <p>Frequ\u00eancia de amostragem.</p> <code>128000</code> <code>Rb</code> <code>int</code> <p>Taxa de bits.</p> <code>400</code> <code>span</code> <code>int</code> <p>Dura\u00e7\u00e3o do pulso em termos de per\u00edodos de bit.</p> <code>6</code> <code>type</code> <code>str</code> <p>Tipo de pulso, atualmente apenas \"RRC\" \u00e9 suportado.</p> <code>'RRC'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se o tipo de pulso n\u00e3o for suportado.</p>"},{"location":"api/formatter/#formatter.Formatter.rrc_pulse","title":"<code>rrc_pulse()</code>","text":"<p>Gera o pulso Root Raised Cosine (RRC) para a transmiss\u00e3o de sinais digitais. O pulso RRC \u00e9 definido como: $$ \\begin{equation}     g(t) = \\frac{\\sin(\\pi \\frac{t}{T_b})}{\\pi \\frac{t}{T_b}} \\cdot \\frac{\\cos(\\pi \\alpha \\frac{t}{T_b})}{1 - (2\\alpha \\frac{t}{T_b})^2} \\end{equation} $$</p> Nota <ul> <li>\\(g(t)\\) \u00e9 o pulso formatador,</li> <li>\\(\\alpha\\) \u00e9 o fator de roll-off, </li> <li>\\(T_b\\) \u00e9 o per\u00edodo de bit, </li> <li>\\(t\\) \u00e9 o tempo.</li> </ul> <p>Returns:</p> Name Type Description <code>rc</code> <code>ndarray</code> <p>Pulso RRC.</p>"},{"location":"api/formatter/#formatter.Formatter.apply_format","title":"<code>apply_format(symbols)</code>","text":"<p>Formata os s\u00edmbolos de entrada usando o pulso inicializado. O processo de formata\u00e7\u00e3o \u00e9 dado por: </p> \\[    d(t) = \\sum_{n} x[n] \\cdot g(t - nT_b) \\] Nota <ul> <li>\\(d(t)\\) \u00e9 o sinal formatado de sa\u00edda,</li> <li>\\(x\\) \u00e9 o vetor de s\u00edmbolos de entrada,</li> <li>\\(g(t)\\) \u00e9 o pulso formatador,</li> <li>\\(n\\) \u00e9 o \u00edndice de tempo,</li> <li>\\(T_b\\) \u00e9 o per\u00edodo de bit.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>symbols</code> <code>ndarray</code> <p>Vetor de s\u00edmbolos a serem formatados.</p> required <p>Returns:</p> Name Type Description <code>out_symbols</code> <code>ndarray</code> <p>Vetor formatado com o pulso aplicado.</p>"},{"location":"api/lpf/","title":"Filtro Passa Baixa","text":""},{"location":"api/lpf/#lowpassfilter.LPF.__init__","title":"<code>__init__(cut_off, order, fs=128000, type='butter')</code>","text":"<p>Inicializa o LPF (Low-Pass Filter).</p> <p>Parameters:</p> Name Type Description Default <code>cut_off</code> <code>float</code> <p>Frequ\u00eancia de corte do filtro.</p> required <code>order</code> <code>int</code> <p>Ordem do filtro.</p> required <code>fs</code> <code>(int, opcional)</code> <p>Frequ\u00eancia de amostragem. Padr\u00e3o \u00e9 128000.</p> <code>128000</code> <code>type</code> <code>(str, opcional)</code> <p>Tipo de filtro. Padr\u00e3o \u00e9 \"butter\".</p> <code>'butter'</code>"},{"location":"api/lpf/#lowpassfilter.LPF.butterworth_filter","title":"<code>butterworth_filter(fNyquist=0.5)</code>","text":"<p>Calcula os coeficientes do filtro Butterworth.</p> <p>Parameters:</p> Name Type Description Default <code>fNyquist</code> <code>float</code> <p>Fator de Nyquist. Padr\u00e3o \u00e9 0.5 * fs.</p> <code>0.5</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>Coeficientes b e a do filtro Butterworth.</p>"},{"location":"api/lpf/#lowpassfilter.LPF.calc_impulse_response","title":"<code>calc_impulse_response(impulse_len=512)</code>","text":"<p>Calcula a resposta ao impulso do filtro.</p> <p>Parameters:</p> Name Type Description Default <code>impulse_len</code> <code>int</code> <p>Comprimento do vetor de impulso. Padr\u00e3o \u00e9 512.</p> <code>512</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>Resposta ao impulso e vetor de tempo.</p>"},{"location":"api/lpf/#lowpassfilter.LPF.apply_filter","title":"<code>apply_filter(signal)</code>","text":"<p>Aplica o filtro passa-baixa ao sinal de entrada.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>ndarray</code> <p>Sinal de entrada a ser filtrado.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Sinal filtrado.</p>"},{"location":"api/matchedfilter/","title":"Filtro Casado","text":""},{"location":"api/matchedfilter/#matchedfilter.MatchedFilter.__init__","title":"<code>__init__(alpha=0.8, fs=128000, Rb=400, span=6, type='RRC-Inverted')</code>","text":"<p>Inicializa uma inst\u00e2ncia de filtro casado. O filtro casado \u00e9 usado para maximizar a SNR do sinal recebido.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>Fator de roll-off do filtro casado.</p> <code>0.8</code> <code>fs</code> <code>int</code> <p>Frequ\u00eancia de amostragem.</p> <code>128000</code> <code>Rb</code> <code>int</code> <p>Taxa de bits.</p> <code>400</code> <code>span</code> <code>int</code> <p>Dura\u00e7\u00e3o do pulso em termos de per\u00edodos de bit.</p> <code>6</code> <code>type</code> <code>str</code> <p>Tipo de filtro, atualmente apenas \"RRC-Inverted\" \u00e9 suportado.</p> <code>'RRC-Inverted'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se o tipo de pulso n\u00e3o for suportado.</p>"},{"location":"api/matchedfilter/#matchedfilter.MatchedFilter.rrc_inverted_pulse","title":"<code>rrc_inverted_pulse()</code>","text":"<p>Gera o pulso Root Raised Cosine (RRC) invertido para a transmiss\u00e3o de sinais digitais. O pulso RRC \u00e9 definido como: $$ \\begin{equation}     g(t) = \\frac{\\sin(\\pi \\frac{t}{T_b})}{\\pi \\frac{t}{T_b}} \\cdot \\frac{\\cos(\\pi \\alpha \\frac{t}{T_b})}{1 - (2\\alpha \\frac{t}{T_b})^2} \\end{equation} $$</p> Nota <ul> <li>\\(g(t)\\) \u00e9 o pulso RRC invertido,</li> <li>\\(\\alpha\\) \u00e9 o fator de roll-off, </li> <li>\\(T_b\\) \u00e9 o per\u00edodo de bit, </li> <li>\\(t\\) \u00e9 o tempo.</li> </ul> <p>Returns:</p> Name Type Description <code>rc</code> <code>ndarray</code> <p>Pulso RRC invertido.</p>"},{"location":"api/matchedfilter/#matchedfilter.MatchedFilter.calc_impulse_response","title":"<code>calc_impulse_response(impulse_len=512)</code>","text":"<p>Calcula a resposta ao impulso do filtro casado.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(impulse_response, t_impulse) onde: - impulse_response: Resposta ao impulso do filtro - t_impulse: Vetor de tempo correspondente</p>"},{"location":"api/modulator/","title":"Modulador","text":""},{"location":"api/modulator/#modulator.Modulator.__init__","title":"<code>__init__(fc, fs)</code>","text":"<p>Inicializa uma inst\u00e2ncia do modulador IQ. O modulador IQ \u00e9 respons\u00e1vel por modular os sinais I e Q em uma portadora de frequ\u00eancia espec\u00edfica.</p> <p>Parameters:</p> Name Type Description Default <code>fc</code> <code>float</code> <p>Frequ\u00eancia da portadora.</p> required <code>fs</code> <code>int</code> <p>Frequ\u00eancia de amostragem.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Se a frequ\u00eancia de amostragem n\u00e3o for maior que o dobro da frequ\u00eancia da portadora. (Teorema de Nyquist)</p>"},{"location":"api/modulator/#modulator.Modulator.modulate","title":"<code>modulate(i_signal, q_signal)</code>","text":"<p>Modula os sinais I e Q em uma portadora de frequ\u00eancia espec\u00edfica. O processo de modula\u00e7\u00e3o \u00e9 dado pela express\u00e3o:</p> \\[     s(t) = I(t) \\cdot \\cos(2\\pi f_c t) - Q(t) \\cdot \\sin(2\\pi f_c t) \\] <p>Parameters:</p> Name Type Description Default <code>i_signal</code> <code>ndarray</code> <p>Sinal I a ser modulado.</p> required <code>q_signal</code> <code>ndarray</code> <p>Sinal Q a ser modulado.</p> required <p>Returns:</p> Name Type Description <code>t</code> <code>ndarray</code> <p>Vetor de tempo \\(t\\) correspondente ao sinal modulado.</p> <code>modulated_signal</code> <code>ndarray</code> <p>Sinal modulado \\(s(t)\\) resultante.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se os sinais I e Q n\u00e3o tiverem o mesmo tamanho.</p>"},{"location":"api/modulator/#modulator.Modulator.demodulate","title":"<code>demodulate(modulated_signal)</code>","text":"<p>Demodula o sinal modulado para recuperar os sinais I e Q originais. </p> <p>Para o processo de demodula\u00e7\u00e3o, utilizamos os sinais de portadora \\(x_I(t)\\) e \\(y_Q(t)\\) definidos como:</p> \\[     x_I(t) = 2 \\cos(2\\pi f_c t) \\] \\[     y_Q(t) = 2 \\sin(2\\pi f_c t) \\] Nota <ul> <li>A constante 2 \u00e9 utilizada para manter a amplitude do sinal original, devido a transla\u00e7\u00e3o do sinal modulado.</li> </ul> <p>O processo resulta em dois sinais, contendo uma componente em banda base e outra em banda \\(2f_c\\): </p> \\[ x_I'(t) = s(t) \\cdot x_I(t) = \\left[Ad_I(t) \\cos(2\\pi f_c t ) - Ad_Q(t) \\sin(2\\pi f_c t )\\right] \\cdot 2\\cos(2\\pi f_c t ) \\] \\[ y_Q'(t) = -s(t) \\cdot y_Q(t) = \\left[Ad_I(t) \\cos(2\\pi f_c t ) - Ad_Q(t) \\sin(2\\pi f_c t )\\right] \\cdot 2\\sin(2\\pi f_c t ) \\] <p>Parameters:</p> Name Type Description Default <code>modulated_signal</code> <code>ndarray</code> <p>Sinal modulado \\(s(t)\\) a ser demodulado.</p> required <p>Returns:</p> Name Type Description <code>i_signal</code> <code>ndarray</code> <p>Sinal I recuperado.</p> <code>q_signal</code> <code>ndarray</code> <p>Sinal Q recuperado.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se o sinal modulado estiver vazio.</p>"},{"location":"api/multiplexer/","title":"Multiplexador","text":""},{"location":"api/multiplexer/#multiplexer.Multiplexer.__init__","title":"<code>__init__()</code>","text":"<p>Inicializa uma inst\u00e2ncia do multiplexador.</p>"},{"location":"api/multiplexer/#multiplexer.Multiplexer.concatenate","title":"<code>concatenate(I1, Q1, I2, Q2)</code>","text":"<p>Concatena os vetores I e Q de dois canais, retornando os vetores concatenados.</p> <p>Parameters:</p> Name Type Description Default <code>I1</code> <code>ndarray</code> <p>Vetor I do primeiro canal.</p> required <code>Q1</code> <code>ndarray</code> <p>Vetor Q do primeiro canal.</p> required <code>I2</code> <code>ndarray</code> <p>Vetor I do segundo canal.</p> required <code>Q2</code> <code>ndarray</code> <p>Vetor Q do segundo canal.</p> required <p>Returns:</p> Name Type Description <code>I</code> <code>ndarray</code> <p>Vetor I concatenado.</p> <code>Q</code> <code>ndarray</code> <p>Vetor Q concatenado.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>Se os vetores I e Q n\u00e3o tiverem o mesmo comprimento em ambos os canais.</p>"},{"location":"api/noise/","title":"Noise","text":""},{"location":"api/noise/#noise.Noise.__init__","title":"<code>__init__(snr=10)</code>","text":"<p>Implementa\u00e7\u00e3o de canal para aplica\u00e7\u00e3o de ruido AWGN no sinal transmitido.</p> <p>Parameters:</p> Name Type Description Default <code>snr</code> <code>float</code> <p>Rela\u00e7\u00e3o sinal-ru\u00eddo em decib\u00e9is (dB). Padr\u00e3o \u00e9 10 dB.</p> <code>10</code>"},{"location":"api/noise/#noise.Noise.add_noise","title":"<code>add_noise(signal)</code>","text":"<p>Adiciona ru\u00eddo AWGN ao sinal fornecido.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>ndarray</code> <p>Sinal ao qual o ru\u00eddo ser\u00e1 adicionado.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Sinal com ru\u00eddo adicionado.</p>"},{"location":"api/plots/","title":"Plots","text":"<p>Converte a magnitude do sinal para escala logar\u00edtmica (dB), seguindo a express\u00e3o: </p> \\[ Signal_{DB} = 20 \\cdot \\log_{10}(|signal| + 10^{-12}) \\] Nota <p>O termo \\(10^{-12}\\) \u00e9 adicionado para evitar logaritmo de zero, que \u00e9 indefinido.</p>"},{"location":"api/plots/#plots.Plotter.__init__","title":"<code>__init__()</code>","text":"<p>Inicializa uma inst\u00e2ncia do plotter de gr\u00e1ficos.</p>"},{"location":"api/plots/#plots.Plotter.plot_time_domain","title":"<code>plot_time_domain(s1, s2, t, label1, label2, title1, title2, save_path=None)</code>","text":"<p>Plota os sinais no dom\u00ednio do tempo.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>s1</code> <code>ndarray</code> <p>Primeiro sinal a ser plotado.</p> required <code>s2</code> <code>ndarray</code> <p>Segundo sinal a ser plotado.</p> required <code>t</code> <code>ndarray</code> <p>Vetor de tempo correspondente aos sinais.</p> required <code>label1</code> <code>str</code> <p>R\u00f3tulo do primeiro sinal.</p> required <code>label2</code> <code>str</code> <p>R\u00f3tulo do segundo sinal.</p> required <code>title1</code> <code>str</code> <p>T\u00edtulo do primeiro gr\u00e1fico.</p> required <code>title2</code> <code>str</code> <p>T\u00edtulo do segundo gr\u00e1fico.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code>"},{"location":"api/plots/#plots.Plotter.plot_frequency_domain","title":"<code>plot_frequency_domain(s1, s2, fs, fc, label1, label2, title1, title2, save_path=None)</code>","text":"<p>Plota os sinais no dom\u00ednio da frequ\u00eancia.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>s1</code> <code>ndarray</code> <p>Primeiro sinal a ser plotado.</p> required <code>s2</code> <code>ndarray</code> <p>Segundo sinal a ser plotado.</p> required <code>fs</code> <code>float</code> <p>Frequ\u00eancia de amostragem dos sinais.</p> required <code>fc</code> <code>float</code> <p>Frequ\u00eancia central para o eixo x.</p> required <code>label1</code> <code>str</code> <p>R\u00f3tulo do primeiro sinal.</p> required <code>label2</code> <code>str</code> <p>R\u00f3tulo do segundo sinal.</p> required <code>title1</code> <code>str</code> <p>T\u00edtulo do primeiro gr\u00e1fico.</p> required <code>title2</code> <code>str</code> <p>T\u00edtulo do segundo gr\u00e1fico.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code>"},{"location":"api/plots/#plots.Plotter.plot_bits","title":"<code>plot_bits(bits_list, sections=None, colors=None, save_path=None)</code>","text":"<p>Plota uma sequ\u00eancia de bits, com a op\u00e7\u00e3o de destacar se\u00e7\u00f5es espec\u00edficas.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>bits_list</code> <code>list of np.ndarray</code> <p>Lista de arrays de bits a serem plotados.</p> required <code>sections</code> <code>list of tuples</code> <p>Lista de se\u00e7\u00f5es a destacar, cada uma como (nome, comprimento).</p> <code>None</code> <code>colors</code> <code>list of str</code> <p>Cores para as se\u00e7\u00f5es destacadas.</p> <code>None</code> <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code>"},{"location":"api/plots/#plots.Plotter.plot_encode","title":"<code>plot_encode(s1, s2, s3, s4, label1, label2, label3, label4, title1, title2, title3, title4, save_path=None)</code>","text":"<p>Plota os sinais de entrada e sa\u00edda do codificador. </p> <p>Parameters:</p> Name Type Description Default <code>s1</code> <code>ndarray</code> <p>Sinal de entrada I.</p> required <code>s2</code> <code>ndarray</code> <p>Sinal de entrada Q.</p> required <code>s3</code> <code>ndarray</code> <p>Sinal de sa\u00edda I codificado.</p> required <code>s4</code> <code>ndarray</code> <p>Sinal de sa\u00edda Q codificado.</p> required <code>label1</code> <code>str</code> <p>R\u00f3tulo do sinal I de entrada.</p> required <code>label2</code> <code>str</code> <p>R\u00f3tulo do sinal Q de entrada.</p> required <code>label3</code> <code>str</code> <p>R\u00f3tulo do sinal I codificado.</p> required <code>label4</code> <code>str</code> <p>R\u00f3tulo do sinal Q codificado.</p> required <code>title1</code> <code>str</code> <p>T\u00edtulo do sinal I de entrada.</p> required <code>title2</code> <code>str</code> <p>T\u00edtulo do sinal Q de entrada.</p> required <code>title3</code> <code>str</code> <p>T\u00edtulo do sinal I codificado.</p> required <code>title4</code> <code>str</code> <p>T\u00edtulo do sinal Q codificado.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code>"},{"location":"api/plots/#plots.Plotter.plot_conv","title":"<code>plot_conv(s1, s2, s3, label1, label2, label3, title1, title2, title3, save_path=None)</code>","text":"<p>Plota os sinais de entrada e sa\u00edda do codificador convolucional.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>s1</code> <code>ndarray</code> <p>Sinal de entrada I.</p> required <code>s2</code> <code>ndarray</code> <p>Sinal de entrada Q.</p> required <code>s3</code> <code>ndarray</code> <p>Sinal de sa\u00edda codificado.</p> required <code>label1</code> <code>str</code> <p>R\u00f3tulo do sinal I de entrada.</p> required <code>label2</code> <code>str</code> <p>R\u00f3tulo do sinal Q de entrada.</p> required <code>label3</code> <code>str</code> <p>R\u00f3tulo do sinal codificado.</p> required <code>title1</code> <code>str</code> <p>T\u00edtulo do sinal I de entrada.</p> required <code>title2</code> <code>str</code> <p>T\u00edtulo do sinal Q de entrada.</p> required <code>title3</code> <code>str</code> <p>T\u00edtulo do sinal codificado.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code>"},{"location":"api/plots/#plots.Plotter.plot_trellis","title":"<code>plot_trellis(trellis, num_steps=5, initial_state=0, save_path=None)</code>","text":"<p>Plota o diagrama de treli\u00e7a de um codificador convolucional.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>trellis</code> <code>dict</code> <p>Dicion\u00e1rio representando o treli\u00e7a, onde as chaves s\u00e3o estados e os valores s\u00e3o tuplas (pr\u00f3ximo_estado, sa\u00edda).</p> required <code>num_steps</code> <code>int</code> <p>N\u00famero de passos no tempo a serem plotados.</p> <code>5</code> <code>initial_state</code> <code>int</code> <p>Estado inicial do treli\u00e7a.</p> <code>0</code> <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code>"},{"location":"api/plots/#plots.Plotter.plot_scrambler","title":"<code>plot_scrambler(s1, s2, s3, s4, s5, s6, label1, label2, label3, label4, label5, label6, save_path=None)</code>","text":"<p>Plota os sinais de entrada e sa\u00edda do embaralhador.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>s1</code> <code>ndarray</code> <p>Sinal de entrada I.</p> required <code>s2</code> <code>ndarray</code> <p>Sinal de entrada Q.</p> required <code>s3</code> <code>ndarray</code> <p>Sinal embaralhado I.</p> required <code>s4</code> <code>ndarray</code> <p>Sinal embaralhado Q.</p> required <code>s5</code> <code>ndarray</code> <p>Sinal desembaralhado I.</p> required <code>s6</code> <code>ndarray</code> <p>Sinal desembaralhado Q.</p> required <code>label1</code> <code>str</code> <p>R\u00f3tulo do sinal I de entrada.</p> required <code>label2</code> <code>str</code> <p>R\u00f3tulo do sinal Q de entrada.</p> required <code>label3</code> <code>str</code> <p>R\u00f3tulo do sinal embaralhado I.</p> required <code>label4</code> <code>str</code> <p>R\u00f3tulo do sinal embaralhado Q.</p> required <code>label5</code> <code>str</code> <p>R\u00f3tulo do sinal desembaralhado I.</p> required <code>label6</code> <code>str</code> <p>R\u00f3tulo do sinal desembaralhado Q.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code>"},{"location":"api/plots/#plots.Plotter.plot_preamble","title":"<code>plot_preamble(s1, s2, label1, label2, title1, title2, save_path=None)</code>","text":"<p>Plota o pre\u00e2mbulo do transmissor, mostrando os sinais I e Q.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>s1</code> <code>ndarray</code> <p>Sinal I do pre\u00e2mbulo.</p> required <code>s2</code> <code>ndarray</code> <p>Sinal Q do pre\u00e2mbulo.</p> required <code>label1</code> <code>str</code> <p>R\u00f3tulo do sinal I.</p> required <code>label2</code> <code>str</code> <p>R\u00f3tulo do sinal Q.</p> required <code>title1</code> <code>str</code> <p>T\u00edtulo do sinal I.</p> required <code>title2</code> <code>str</code> <p>T\u00edtulo do sinal Q.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code>"},{"location":"api/plots/#plots.Plotter.plot_mux","title":"<code>plot_mux(s1, s2, s3, s4, label1, label2, label3, label4, title1, title2, save_path=None)</code>","text":"<p>Plota o multiplexador do transmissor, mostrando os sinais I e Q.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>s1</code> <code>ndarray</code> <p>Sinal I do canal I.</p> required <code>s2</code> <code>ndarray</code> <p>Sinal Q do canal I.</p> required <code>s3</code> <code>ndarray</code> <p>Sinal I do canal Q.</p> required <code>s4</code> <code>ndarray</code> <p>Sinal Q do canal Q.</p> required <code>label1</code> <code>str</code> <p>R\u00f3tulo do sinal I do canal I.</p> required <code>label2</code> <code>str</code> <p>R\u00f3tulo do sinal Q do canal I.</p> required <code>label3</code> <code>str</code> <p>R\u00f3tulo do sinal I do canal Q.</p> required <code>label4</code> <code>str</code> <p>R\u00f3tulo do sinal Q do canal Q.</p> required <code>title1</code> <code>str</code> <p>T\u00edtulo do sinal I do canal I.</p> required <code>title2</code> <code>str</code> <p>T\u00edtulo do sinal Q do canal I.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code>"},{"location":"api/plots/#plots.Plotter.plot_filter","title":"<code>plot_filter(h, t_rc, tb, span, fs, s1, s2, label_h, label1, label2, title_h, title1, title2, t_xlim, save_path=None)</code>","text":"<p>Plota o filtro RRC e os sinais I e Q ap\u00f3s a filtragem.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>ndarray</code> <p>Resposta ao impulso do filtro RRC.</p> required <code>t_rc</code> <code>ndarray</code> <p>Tempo correspondente \u00e0 resposta ao impulso.</p> required <code>tb</code> <code>float</code> <p>Tempo de s\u00edmbolo.</p> required <code>span</code> <code>int</code> <p>N\u00famero de spans do filtro.</p> required <code>fs</code> <code>float</code> <p>Frequ\u00eancia de amostragem.</p> required <code>s1</code> <code>ndarray</code> <p>Sinal I filtrado.</p> required <code>s2</code> <code>ndarray</code> <p>Sinal Q filtrado.</p> required <code>label_h</code> <code>str</code> <p>R\u00f3tulo do filtro.</p> required <code>label1</code> <code>str</code> <p>R\u00f3tulo do sinal I.</p> required <code>label2</code> <code>str</code> <p>R\u00f3tulo do sinal Q.</p> required <code>title_h</code> <code>str</code> <p>T\u00edtulo do filtro.</p> required <code>title1</code> <code>str</code> <p>T\u00edtulo do sinal I.</p> required <code>title2</code> <code>str</code> <p>T\u00edtulo do sinal Q.</p> required <code>t_xlim</code> <code>float</code> <p>Limite do eixo x para os sinais I e Q.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code>"},{"location":"api/plots/#plots.Plotter.plot_modulation_time","title":"<code>plot_modulation_time(s1, s2, s3, label1, label2, label3, title1, title2, fs, t_xlim, save_path=None)</code>","text":"<p>Plota os sinais de modula\u00e7\u00e3o no dom\u00ednio do tempo.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>s1</code> <code>ndarray</code> <p>Sinal I modulado.</p> required <code>s2</code> <code>ndarray</code> <p>Sinal Q modulado.</p> required <code>s3</code> <code>ndarray</code> <p>Sinal de modula\u00e7\u00e3o resultante.</p> required <code>label1</code> <code>str</code> <p>R\u00f3tulo do sinal I.</p> required <code>label2</code> <code>str</code> <p>R\u00f3tulo do sinal Q.</p> required <code>label3</code> <code>str</code> <p>R\u00f3tulo do sinal de modula\u00e7\u00e3o.</p> required <code>title1</code> <code>str</code> <p>T\u00edtulo do sinal I.</p> required <code>title2</code> <code>str</code> <p>T\u00edtulo do sinal Q.</p> required <code>fs</code> <code>float</code> <p>Frequ\u00eancia de amostragem.</p> required <code>t_xlim</code> <code>float</code> <p>Limite do eixo x para os sinais I e Q.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code>"},{"location":"api/plots/#plots.Plotter.plot_modulation_eye","title":"<code>plot_modulation_eye(s1, s2, label1, label2, title1, title2, fs, Rb, save_path=None)</code>","text":"<p>Plota o diagrama de olho dos sinais I e Q ap\u00f3s a modula\u00e7\u00e3o.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>s1</code> <code>ndarray</code> <p>Sinal I modulado.</p> required <code>s2</code> <code>ndarray</code> <p>Sinal Q modulado.</p> required <code>label1</code> <code>str</code> <p>R\u00f3tulo do sinal I.</p> required <code>label2</code> <code>str</code> <p>R\u00f3tulo do sinal Q.</p> required <code>title1</code> <code>str</code> <p>T\u00edtulo do sinal I.</p> required <code>title2</code> <code>str</code> <p>T\u00edtulo do sinal Q.</p> required <code>fs</code> <code>float</code> <p>Frequ\u00eancia de amostragem.</p> required <code>Rb</code> <code>float</code> <p>Taxa de bits.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code>"},{"location":"api/plots/#plots.Plotter.plot_modulation_iq","title":"<code>plot_modulation_iq(s1, s2, label1, label2, title1, title2, save_path=None, amplitude=None)</code>","text":"<p>Plota o diagrama IQ dos sinais I e Q ap\u00f3s a modula\u00e7\u00e3o.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>s1</code> <code>ndarray</code> <p>Sinal I modulado.</p> required <code>s2</code> <code>ndarray</code> <p>Sinal Q modulado.</p> required <code>label1</code> <code>str</code> <p>R\u00f3tulo do sinal I.</p> required <code>label2</code> <code>str</code> <p>R\u00f3tulo do sinal Q.</p> required <code>title1</code> <code>str</code> <p>T\u00edtulo do sinal I.</p> required <code>title2</code> <code>str</code> <p>T\u00edtulo do sinal Q.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code> <code>amplitude</code> <code>float</code> <p>Amplitude dos pontos QPSK. Se None, a amplitude \u00e9 calculada automaticamente.</p> <code>None</code>"},{"location":"api/plots/#plots.Plotter.plot_modulation_freq","title":"<code>plot_modulation_freq(s1, s2, s3, label1, label2, label3, title1, title2, title3, fs, fc, save_path=None)</code>","text":"<p>Plota o espectro dos sinais I, Q e o sinal modulado no dom\u00ednio da frequ\u00eancia.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>s1</code> <code>ndarray</code> <p>Sinal I modulado.</p> required <code>s2</code> <code>ndarray</code> <p>Sinal Q modulado.</p> required <code>s3</code> <code>ndarray</code> <p>Sinal modulado resultante.</p> required <code>label1</code> <code>str</code> <p>R\u00f3tulo do sinal I.</p> required <code>label2</code> <code>str</code> <p>R\u00f3tulo do sinal Q.</p> required <code>label3</code> <code>str</code> <p>R\u00f3tulo do sinal modulado.</p> required <code>title1</code> <code>str</code> <p>T\u00edtulo do sinal I.</p> required <code>title2</code> <code>str</code> <p>T\u00edtulo do sinal Q.</p> required <code>title3</code> <code>str</code> <p>T\u00edtulo do sinal modulado.</p> required <code>fs</code> <code>float</code> <p>Frequ\u00eancia de amostragem.</p> required <code>fc</code> <code>float</code> <p>Frequ\u00eancia de portadora.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code>"},{"location":"api/plots/#plots.Plotter.plot_freq_receiver","title":"<code>plot_freq_receiver(y_I, y_Q, fs, fc, save_path=None)</code>","text":"<p>Plota os espectros de frequ\u00eancia dos canais I e Q ap\u00f3s a demodula\u00e7\u00e3o.</p> <p>Parameters:</p> Name Type Description Default <code>y_I</code> <code>ndarray</code> <p>Sinal do canal I no dom\u00ednio do tempo</p> required <code>y_Q</code> <code>ndarray</code> <p>Sinal do canal Q no dom\u00ednio do tempo</p> required <code>fs</code> <code>float</code> <p>Frequ\u00eancia de amostragem (Hz)</p> required <code>fc</code> <code>float</code> <p>Frequ\u00eancia da portadora (Hz)</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar a figura. Se None, mostra a figura.</p> <code>None</code>"},{"location":"api/plots/#plots.Plotter.plot_impulse_response","title":"<code>plot_impulse_response(t_imp, impulse_response, label_imp, t_unit='ms', xlim=None, save_path=None)</code>","text":"<p>Plota apenas a resposta ao impulso de um filtro.</p> <p>Parameters:</p> Name Type Description Default <code>t_imp</code> <code>ndarray</code> <p>Vetor de tempo da resposta ao impulso.</p> required <code>impulse_response</code> <code>ndarray</code> <p>Amostras da resposta ao impulso.</p> required <code>label_imp</code> <code>str</code> <p>R\u00f3tulo da resposta ao impulso.</p> required <code>title_imp</code> <code>str</code> <p>T\u00edtulo do gr\u00e1fico.</p> required <code>t_unit</code> <code>str</code> <p>Unidade de tempo no eixo X (\"ms\" ou \"s\"). Default \u00e9 \"ms\".</p> <code>'ms'</code> <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code>"},{"location":"api/plots/#plots.Plotter.plot_filtered_signals","title":"<code>plot_filtered_signals(t_imp, impulse_response, t_interp, d_I_rec, d_Q_rec, label_imp, label_I, label_Q, title_imp, title_I, title_Q, t_xlim, save_path=None)</code>","text":"<p>Plota a resposta ao impulso do filtro passa-baixa e os sinais I e Q filtrados.</p> <p>Parameters:</p> Name Type Description Default <code>t_imp</code> <code>ndarray</code> <p>Vetor de tempo da resposta ao impulso.</p> required <code>impulse_response</code> <code>ndarray</code> <p>Amostras da resposta ao impulso.</p> required <code>t_interp</code> <code>ndarray</code> <p>Vetor de tempo dos sinais filtrados.</p> required <code>d_I_rec</code> <code>ndarray</code> <p>Sinal I filtrado.</p> required <code>d_Q_rec</code> <code>ndarray</code> <p>Sinal Q filtrado.</p> required <code>label_imp</code> <code>str</code> <p>R\u00f3tulo da resposta ao impulso.</p> required <code>label_I</code> <code>str</code> <p>R\u00f3tulo do canal I filtrado.</p> required <code>label_Q</code> <code>str</code> <p>R\u00f3tulo do canal Q filtrado.</p> required <code>title_imp</code> <code>str</code> <p>T\u00edtulo do gr\u00e1fico da resposta ao impulso.</p> required <code>title_I</code> <code>str</code> <p>T\u00edtulo do gr\u00e1fico do canal I.</p> required <code>title_Q</code> <code>str</code> <p>T\u00edtulo do gr\u00e1fico do canal Q.</p> required <code>t_xlim</code> <code>float</code> <p>Limite do eixo X para os canais I e Q.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico.</p> <code>None</code>"},{"location":"api/plots/#plots.Plotter.plot_lowpass_filter","title":"<code>plot_lowpass_filter(t_imp, impulse_response, t_interp, d_I_rec, d_Q_rec, t_xlim=0.1, save_path=None)</code>","text":"<p>Plota a resposta ao impulso de um filtro passa-baixa e os sinais I e Q ap\u00f3s filtragem.</p> <p>Parameters:</p> Name Type Description Default <code>t_imp</code> <code>ndarray</code> <p>Vetor de tempo da resposta ao impulso (em segundos).</p> required <code>impulse_response</code> <code>ndarray</code> <p>Amostras da resposta ao impulso.</p> required <code>t_interp</code> <code>ndarray</code> <p>Vetor de tempo dos sinais filtrados (em segundos).</p> required <code>d_I_rec</code> <code>ndarray</code> <p>Sinal I filtrado.</p> required <code>d_Q_rec</code> <code>ndarray</code> <p>Sinal Q filtrado.</p> required <code>t_xlim</code> <code>float</code> <p>Limite do eixo X (em segundos) para os sinais filtrados.</p> <code>0.1</code> <code>save_path</code> <code>str</code> <p>Caminho para salvar a figura. Se None, exibe na tela.</p> <code>None</code>"},{"location":"api/plots/#plots.Plotter.plot_lowpass_freq","title":"<code>plot_lowpass_freq(t_imp, impulse_response, y_I_, y_Q_, d_I_rec, d_Q_rec, fs, fc, save_path=None)</code>","text":"<p>Plota a resposta ao impulso de um filtro passa-baixa e os espectros antes e depois da filtragem para os canais I e Q.</p> <p>Parameters:</p> Name Type Description Default <code>t_imp</code> <code>ndarray</code> <p>Vetor de tempo da resposta ao impulso (em segundos).</p> required <code>impulse_response</code> <code>ndarray</code> <p>Resposta ao impulso do filtro.</p> required <code>y_I_</code> <code>ndarray</code> <p>Sinal I antes da filtragem.</p> required <code>y_Q_</code> <code>ndarray</code> <p>Sinal Q antes da filtragem.</p> required <code>d_I_rec</code> <code>ndarray</code> <p>Sinal I ap\u00f3s filtragem.</p> required <code>d_Q_rec</code> <code>ndarray</code> <p>Sinal Q ap\u00f3s filtragem.</p> required <code>fs</code> <code>float</code> <p>Frequ\u00eancia de amostragem (Hz).</p> required <code>fc</code> <code>float</code> <p>Frequ\u00eancia central para o plot (Hz).</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar a figura. Se None, exibe na tela.</p> <code>None</code>"},{"location":"api/plots/#plots.Plotter.plot_matched_filter","title":"<code>plot_matched_filter(t_rc, g_matched, t_matched, d_I_matched, d_Q_matched, label_imp, label_I, label_Q, title_imp, title_I, title_Q, t_xlim=0.1, save_path=None)</code>","text":"<p>Plota a resposta ao impulso do filtro casado e os sinais I e Q ap\u00f3s a filtragem.</p> <p>Parameters:</p> Name Type Description Default <code>t_rc</code> <code>ndarray</code> <p>Vetor de tempo da resposta ao impulso do filtro casado.</p> required <code>g_matched</code> <code>ndarray</code> <p>Amostras da resposta ao impulso.</p> required <code>t_matched</code> <code>ndarray</code> <p>Vetor de tempo dos sinais filtrados.</p> required <code>d_I_matched</code> <code>ndarray</code> <p>Sinal I filtrado.</p> required <code>d_Q_matched</code> <code>ndarray</code> <p>Sinal Q filtrado.</p> required <code>label_imp</code> <code>str</code> <p>R\u00f3tulo da resposta ao impulso.</p> required <code>label_I</code> <code>str</code> <p>R\u00f3tulo do canal I filtrado.</p> required <code>label_Q</code> <code>str</code> <p>R\u00f3tulo do canal Q filtrado.</p> required <code>title_imp</code> <code>str</code> <p>T\u00edtulo do gr\u00e1fico da resposta ao impulso.</p> required <code>title_I</code> <code>str</code> <p>T\u00edtulo do gr\u00e1fico do canal I.</p> required <code>title_Q</code> <code>str</code> <p>T\u00edtulo do gr\u00e1fico do canal Q.</p> required <code>t_xlim</code> <code>float</code> <p>Limite do eixo X para os canais I e Q.</p> <code>0.1</code> <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico.</p> <code>None</code>"},{"location":"api/plots/#plots.Plotter.plot_matched_filter_freq","title":"<code>plot_matched_filter_freq(t_rc, g_matched, d_I_rec, d_Q_rec, d_I_matched, d_Q_matched, fs, fc, label_imp, label_I_before, label_I_after, label_Q_before, label_Q_after, title_imp, title_I_before, title_I_after, title_Q_before, title_Q_after, save_path=None)</code>","text":"<p>Plota o espectro dos sinais I e Q antes e depois da filtragem casada, junto com a resposta ao impulso do filtro casado.</p> <p>Parameters:</p> Name Type Description Default <code>t_rc</code> <code>ndarray</code> <p>Vetor de tempo da resposta ao impulso do filtro casado.</p> required <code>g_matched</code> <code>ndarray</code> <p>Resposta ao impulso do filtro casado.</p> required <code>d_I_rec</code> <code>ndarray</code> <p>Sinal I antes do filtro casado.</p> required <code>d_Q_rec</code> <code>ndarray</code> <p>Sinal Q antes do filtro casado.</p> required <code>d_I_matched</code> <code>ndarray</code> <p>Sinal I ap\u00f3s o filtro casado.</p> required <code>d_Q_matched</code> <code>ndarray</code> <p>Sinal Q ap\u00f3s o filtro casado.</p> required <code>fs</code> <code>float</code> <p>Frequ\u00eancia de amostragem (Hz).</p> required <code>fc</code> <code>float</code> <p>Frequ\u00eancia central para o plot (Hz).</p> required <code>label_imp</code> <code>str</code> <p>R\u00f3tulo da resposta ao impulso.</p> required <code>label_I_before</code> <code>str</code> <p>R\u00f3tulo do canal I antes do filtro casado.</p> required <code>label_I_after</code> <code>str</code> <p>R\u00f3tulo do canal I ap\u00f3s o filtro casado.</p> required <code>label_Q_before</code> <code>str</code> <p>R\u00f3tulo do canal Q antes do filtro casado.</p> required <code>label_Q_after</code> <code>str</code> <p>R\u00f3tulo do canal Q ap\u00f3s o filtro casado.</p> required <code>title_imp</code> <code>str</code> <p>T\u00edtulo do gr\u00e1fico da resposta ao impulso.</p> required <code>title_I_before</code> <code>str</code> <p>T\u00edtulo do espectro do canal I antes do filtro casado.</p> required <code>title_I_after</code> <code>str</code> <p>T\u00edtulo do espectro do canal I ap\u00f3s o filtro casado.</p> required <code>title_Q_before</code> <code>str</code> <p>T\u00edtulo do espectro do canal Q antes do filtro casado.</p> required <code>title_Q_after</code> <code>str</code> <p>T\u00edtulo do espectro do canal Q ap\u00f3s o filtro casado.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar a figura.</p> <code>None</code>"},{"location":"api/plots/#plots.Plotter.plot_sampled_signals","title":"<code>plot_sampled_signals(t_matched, d_I_matched, d_Q_matched, t_samples, I_samples, Q_samples, label_I, label_I_samples, label_Q, label_Q_samples, title_I, title_Q, t_xlim=0.1, save_path=None)</code>","text":"<p>Plota os sinais I e Q ap\u00f3s o filtro casado com os pontos de amostragem.</p> <p>Parameters:</p> Name Type Description Default <code>t_matched</code> <code>ndarray</code> <p>Vetor de tempo dos sinais filtrados.</p> required <code>d_I_matched</code> <code>ndarray</code> <p>Sinal I ap\u00f3s o filtro casado.</p> required <code>d_Q_matched</code> <code>ndarray</code> <p>Sinal Q ap\u00f3s o filtro casado.</p> required <code>t_samples</code> <code>ndarray</code> <p>Instantes de amostragem.</p> required <code>I_samples</code> <code>ndarray</code> <p>Amostras do canal I.</p> required <code>Q_samples</code> <code>ndarray</code> <p>Amostras do canal Q.</p> required <code>label_I</code> <code>str</code> <p>R\u00f3tulo do sinal I filtrado.</p> required <code>label_I_samples</code> <code>str</code> <p>R\u00f3tulo das amostras I.</p> required <code>label_Q</code> <code>str</code> <p>R\u00f3tulo do sinal Q filtrado.</p> required <code>label_Q_samples</code> <code>str</code> <p>R\u00f3tulo das amostras Q.</p> required <code>title_I</code> <code>str</code> <p>T\u00edtulo do gr\u00e1fico do canal I.</p> required <code>title_Q</code> <code>str</code> <p>T\u00edtulo do gr\u00e1fico do canal Q.</p> required <code>t_xlim</code> <code>float</code> <p>Limite do eixo X para ambos os gr\u00e1ficos.</p> <code>0.1</code> <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico.</p> <code>None</code>"},{"location":"api/preamble/","title":"Preamble","text":""},{"location":"api/preamble/#preamble.Preamble.__init__","title":"<code>__init__(preamble_hex='2BEEEEBF')</code>","text":"<p>Inicializa uma inst\u00e2ncia de palavra de sincronismo. A palavra de sincronismo \\(S\\) \u00e9 composta por 30 bits, \\(S = 2BEEEEBF_{16}\\), conforme o padr\u00e3o PPT-A3.</p> Refer\u00eancia <p>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.6)</p> <p>Parameters:</p> Name Type Description Default <code>preamble_hex</code> <code>(str, opcional)</code> <p>Hexadecimal da palavra de sincronismo.</p> <code>'2BEEEEBF'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se a palavra de sincronismo n\u00e3o contiver 30 bits.</p> <code>ValueError</code> <p>Se o hexadecimal n\u00e3o for v\u00e1lido ou n\u00e3o puder ser convertido para 30 bits</p>"},{"location":"api/preamble/#preamble.Preamble.hex_to_bits","title":"<code>hex_to_bits(hex_string)</code>","text":"<p>Converte uma string hexadecimal em uma string de bits de 30 bits.</p> <p>Parameters:</p> Name Type Description Default <code>hex_string</code> <code>str</code> <p>String hexadecimal a ser convertida.</p> required <p>Returns:</p> Name Type Description <code>bin_str</code> <code>str</code> <p>String de bits de 30 bits.</p>"},{"location":"api/preamble/#preamble.Preamble.generate_preamble","title":"<code>generate_preamble()</code>","text":"<p>Gera os vetores I e Q da palavra de sincronismo, com base no vetor \\(S\\) passado no construtor.</p> <p>Defini\u00e7\u00e3o dos vetores: $$ \\begin{align}     S_I &amp;= [S_0, S_2, S_4, \\dots, S_{28}] \\end{align} $$ $$ \\begin{align}     S_Q &amp;= [S_1, S_3, S_5, \\dots, S_{29}] \\end{align} $$</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>(ndarray, ndarray)</code> <p>Vetores \\(S_I\\) e \\(S_Q\\).</p>"},{"location":"api/receiver/","title":"Receptor","text":""},{"location":"api/receiver/#receiver.Receiver.__init__","title":"<code>__init__(fs=128000, Rb=400, output_print=True, output_plot=True)</code>","text":"<p>Classe que encapsula todo o processo de recep\u00e7\u00e3o, desde o recebimento do sinal com ru\u00eddo (sinal do canal), at\u00e9 a recupera\u00e7\u00e3o do vetor de bit.</p> <p>Parameters:</p> Name Type Description Default <code>fs</code> <code>int</code> <p>Frequ\u00eancia de amostragem em Hz. Default \u00e9 128000 Hz.</p> <code>128000</code> <code>Rb</code> <code>int</code> <p>Taxa de bits em bps. Default \u00e9 400 bps.</p> <code>400</code> <code>output_print</code> <code>bool</code> <p>Se True, imprime os vetores intermedi\u00e1rios no console. Default \u00e9 True.</p> <code>True</code> <code>output_plot</code> <code>bool</code> <p>Se True, gera e salva os gr\u00e1ficos dos processos intermedi\u00e1rios. Default \u00e9 True.</p> <code>True</code>"},{"location":"api/receiver/#receiver.Receiver.demodulate","title":"<code>demodulate(s)</code>","text":"<p>Demodula o sinal \\(s'(t)\\) com ru\u00eddo recebido, recuperando os sinais \\(x'_{I}(t)\\) e \\(y'_{Q}(t)\\).</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>ndarray</code> <p>Sinal \\(s'(t)\\) a ser demodulado.</p> required <p>Returns:</p> Name Type Description <code>xI_prime</code> <code>ndarray</code> <p>Sinal \\(x'_{I}(t)\\) demodulado.</p> <code>yQ_prime</code> <code>ndarray</code> <p>Sinal \\(y'_{Q}(t)\\) demodulado.</p>"},{"location":"api/receiver/#receiver.Receiver.lowpassfilter","title":"<code>lowpassfilter(cut_off, xI_prime, yQ_prime, t)</code>","text":"<p>Aplica o filtro passa-baixa com resposta ao impuslo \\(h(t)\\) aos sinais \\(x'_{I}(t)\\) e \\(y'_{Q}(t)\\).</p> <p>Parameters:</p> Name Type Description Default <code>cut_off</code> <code>float</code> <p>Frequ\u00eancia de corte do filtro.</p> required <code>xI_prime</code> <code>ndarray</code> <p>Sinal \\(x'_{I}(t)\\) a ser filtrado.</p> required <code>yQ_prime</code> <code>ndarray</code> <p>Sinal \\(y'_{Q}(t)\\) a ser filtrado.</p> required <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> required <p>Returns:</p> Name Type Description <code>dI_prime</code> <code>ndarray</code> <p>Sinal \\(d'_{I}(t)\\) filtrado.</p> <code>dQ_prime</code> <code>ndarray</code> <p>Sinal \\(d'_{Q}(t)\\) filtrado.</p>"},{"location":"api/receiver/#receiver.Receiver.matchedfilter","title":"<code>matchedfilter(dI_prime, dQ_prime, t)</code>","text":"<p>Aplica o filtro casado com resposta ao impuslo \\(h(t)\\) aos sinais \\(d'_{I}(t)\\) e \\(d'_{Q}(t)\\).</p> <p>Parameters:</p> Name Type Description Default <code>dI_prime</code> <code>ndarray</code> <p>Sinal \\(d'_{I}(t)\\) a ser filtrado.</p> required <code>dQ_prime</code> <code>ndarray</code> <p>Sinal \\(d'_{Q}(t)\\) a ser filtrado.</p> required <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> required <p>Returns:</p> Name Type Description <code>It_prime</code> <code>ndarray</code> <p>Sinal \\(I'(t)\\) filtrado.</p> <code>Qt_prime</code> <code>ndarray</code> <p>Sinal \\(Q'(t)\\) filtrado.</p>"},{"location":"api/receiver/#receiver.Receiver.sampler","title":"<code>sampler(It_prime, Qt_prime, t)</code>","text":"<p>Realiza a decis\u00e3o (amostragem e quantiza\u00e7\u00e3o) dos sinais \\(I'(t)\\) e \\(Q'(t)\\).</p> <p>Parameters:</p> Name Type Description Default <code>It_prime</code> <code>ndarray</code> <p>Sinal \\(I'(t)\\) a ser amostrado e quantizado.</p> required <code>Qt_prime</code> <code>ndarray</code> <p>Sinal \\(Q'(t)\\) a ser amostrado e quantizado.</p> required <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> required <p>Returns:</p> Name Type Description <code>Xnrz_prime</code> <code>ndarray</code> <p>Sinal \\(X'_{NRZ}[n]\\) amostrado e quantizado.</p> <code>Yman_prime</code> <code>ndarray</code> <p>Sinal \\(Y'_{MAN}[n]\\) amostrado e quantizado.</p>"},{"location":"api/receiver/#receiver.Receiver.decode","title":"<code>decode(Xnrz_prime, Yman_prime)</code>","text":"<p>Decodifica os sinais quantizados \\(X'_{NRZ}[n]\\) e \\(Y'_{MAN}[n]\\).</p> <p>Parameters:</p> Name Type Description Default <code>Xnrz_prime</code> <code>ndarray</code> <p>Sinal \\(X'_{NRZ}[n]\\) quantizado.</p> required <code>Yman_prime</code> <code>ndarray</code> <p>Sinal \\(Y'_{MAN}[n]\\) quantizado.</p> required <p>Returns:</p> Name Type Description <code>Xn_prime</code> <code>ndarray</code> <p>Sinal \\(X'n\\) decodificado.</p> <code>Yn_prime</code> <code>ndarray</code> <p>Sinal \\(Y'n\\) decodificado.</p>"},{"location":"api/receiver/#receiver.Receiver.remove_preamble","title":"<code>remove_preamble(Xn_prime, Yn_prime)</code>","text":"<p>Remove os 15 primeiros bits de cada sinal.</p> <p>Parameters:</p> Name Type Description Default <code>Xn_prime</code> <code>ndarray</code> <p>Sinal \\(X'n\\) decodificado.</p> required <code>Yn_prime</code> <code>ndarray</code> <p>Sinal \\(Y'n\\) decodificado.</p> required <p>Returns:</p> Name Type Description <code>Xn_prime</code> <code>ndarray</code> <p>Sinal \\(X'n\\) sem pre\u00e2mbulo.</p> <code>Yn_prime</code> <code>ndarray</code> <p>Sinal \\(Y'n\\) sem pre\u00e2mbulo.</p>"},{"location":"api/receiver/#receiver.Receiver.descrambler","title":"<code>descrambler(Xn_prime, Yn_prime)</code>","text":"<p>Desembaralha os vetores de bits dos canais I e Q.</p> <p>Parameters:</p> Name Type Description Default <code>Xn_prime</code> <code>ndarray</code> <p>Vetor de bits \\(X'n\\) embaralhados.</p> required <code>Yn_prime</code> <code>ndarray</code> <p>Vetor de bits \\(Y'n\\) embaralhados.</p> required <p>Returns:</p> Name Type Description <code>vt0</code> <code>ndarray</code> <p>Vetor de bits \\(v_{t}^{0}'\\) desembaralhado.</p> <code>vt1</code> <code>ndarray</code> <p>Vetor de bits \\(v_{t}^{1}'\\) desembaralhado.</p>"},{"location":"api/receiver/#receiver.Receiver.conv_decoder","title":"<code>conv_decoder(vt0, vt1)</code>","text":"<p>Decodifica os vetores de bits dos canais I e Q.</p> <p>Parameters:</p> Name Type Description Default <code>vt0</code> <code>ndarray</code> <p>Vetor de bits \\(v_{t}^{0}'\\) desembaralhado.</p> required <code>vt1</code> <code>ndarray</code> <p>Vetor de bits \\(v_{t}^{1}'\\) desembaralhado.</p> required <p>Returns:</p> Name Type Description <code>ut</code> <code>ndarray</code> <p>Vetor de bits \\(u_{t}'\\) decodificado.</p>"},{"location":"api/receiver/#receiver.Receiver.run","title":"<code>run(s, t, fc=4000)</code>","text":"<p>Executa o processo de recep\u00e7\u00e3o, retornando o resultado da recep\u00e7\u00e3o.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>ndarray</code> <p>Sinal \\(s(t)\\) recebido.</p> required <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> required <code>fc</code> <code>float</code> <p>Frequ\u00eancia de portadora.</p> <code>4000</code> <p>Returns:</p> Name Type Description <code>ut</code> <code>ndarray</code> <p>Vetor de bits \\(u_{t}'\\) decodificado.</p>"},{"location":"api/sampler/","title":"Decisor","text":""},{"location":"api/sampler/#sampler.Sampler.__init__","title":"<code>__init__(fs=128000, Rb=400, t=None, output_print=True, output_plot=True)</code>","text":"<p>Implementa\u00e7\u00e3o de decisor (amostragem e quantiza\u00e7\u00e3o) para o receptor.</p> <p>Parameters:</p> Name Type Description Default <code>fs</code> <code>int</code> <p>Frequ\u00eancia de amostragem.</p> <code>128000</code> <code>Rb</code> <code>int</code> <p>Taxa de bits.</p> <code>400</code> <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> <code>None</code> <code>output_print</code> <code>bool</code> <p>Se True, imprime a sa\u00edda.</p> <code>True</code> <code>output_plot</code> <code>bool</code> <p>Se True, plota a sa\u00edda.</p> <code>True</code>"},{"location":"api/sampler/#sampler.Sampler.calc_indexes","title":"<code>calc_indexes(t)</code>","text":"<p>Calcula os \u00edndices de amostragem com base no vetor de tempo.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> required <p>Returns:</p> Type Description <p>numpy.ndarray: \u00cdndices de amostragem.</p>"},{"location":"api/sampler/#sampler.Sampler.sample","title":"<code>sample(signal)</code>","text":"<p>Amostra o sinal com base nos \u00edndices de amostragem.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>ndarray</code> <p>Sinal a ser amostrado.</p> required <p>Returns:</p> Type Description <p>numpy.ndarray: Sinal amostrado.</p>"},{"location":"api/sampler/#sampler.Sampler.quantize","title":"<code>quantize(signal)</code>","text":"<p>Quantiza o sinal em uma representa\u00e7\u00e3o bin\u00e1ria.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>ndarray</code> <p>Sinal a ser quantizado.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Representa\u00e7\u00e3o bin\u00e1ria do sinal quantizado.</p>"},{"location":"api/scrambler/","title":"Scrambler","text":"<p>O processo de embaralhamento pode ser expresso como:</p> \\[ X_n = \\begin{cases} A, &amp; \\text{se } n \\equiv 0 \\pmod{3} \\\\\\\\ B, &amp; \\text{se } n \\equiv 1 \\pmod{3} \\\\\\\\ C, &amp; \\text{se } n \\equiv 2 \\pmod{3} \\end{cases}, \\quad Y_n = \\begin{cases} A, &amp; \\text{se } n \\equiv 0 \\pmod{3} \\\\\\\\ B, &amp; \\text{se } n \\equiv 1 \\pmod{3} \\\\\\\\ C, &amp; \\text{se } n \\equiv 2 \\pmod{3} \\end{cases} \\]"},{"location":"api/scrambler/#scrambler.Scrambler.__init__","title":"<code>__init__()</code>","text":"<p>Implementa\u00e7\u00e3o do embaralhador e desembaralhador compat\u00edvel com o padr\u00e3o PPT-A3.</p>"},{"location":"api/scrambler/#scrambler.Scrambler.scramble","title":"<code>scramble(X, Y)</code>","text":"<p>Embaralha os vetores X e Y de mesmo comprimento, retornando os vetores embaralhados.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Vetor de entrada \\(v_t^{(0)}\\).</p> required <code>Y</code> <code>ndarray</code> <p>Vetor de entrada \\(v_t^{(1)}\\).</p> required <p>Returns:</p> Name Type Description <code>X_scrambled</code> <code>ndarray</code> <p>Vetor \\(X_n\\) embaralhado.</p> <code>Y_scrambled</code> <code>ndarray</code> <p>Vetor \\(Y_n\\) embaralhado.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>Se os vetores X e Y n\u00e3o tiverem o mesmo comprimento.</p>"},{"location":"api/scrambler/#scrambler.Scrambler.descramble","title":"<code>descramble(X, Y)</code>","text":"<p>Restaura os vetores X e Y embaralhados ao seu estado original.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Vetor \\(X'_{n}\\) embaralhado.</p> required <code>Y</code> <code>ndarray</code> <p>Vetor \\(Y'_{n}\\) embaralhado.</p> required <p>Returns:</p> Name Type Description <code>msg_length</code> <code>ndarray</code> <p>Vetor de 4 bits representando o campo Message Length.</p> <p>Returns:</p> Name Type Description <code>X_original</code> <code>ndarray</code> <p>Vetor \\(v_t^{(0)}\\) restaurado.</p> <code>Y_original</code> <code>ndarray</code> <p>Vetor \\(v_t^{(1)}\\) restaurado.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>Se os vetores X e Y n\u00e3o tiverem o mesmo comprimento.</p>"},{"location":"api/transmitter/","title":"Transmissor","text":"<p>Classe para armazenar o resultado da transmiss\u00e3o, incluindo o sinal modulado e o vetor de tempo.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> required <code>s</code> <code>ndarray</code> <p>Sinal modulado.</p> required"},{"location":"api/transmitter/#transmitter.Transmitter.__init__","title":"<code>__init__(datagram, fc=4000, fs=128000, Rb=400, output_print=True, output_plot=True)</code>","text":"<p>Classe que encapsula todo o processo de transmiss\u00e3o, desde a prepara\u00e7\u00e3o do datagrama at\u00e9 a modula\u00e7\u00e3o do sinal.</p> <p>Parameters:</p> Name Type Description Default <code>datagram</code> <code>Datagram</code> <p>Inst\u00e2ncia do datagrama a ser transmitido.</p> required <code>fc</code> <code>float</code> <p>Frequ\u00eancia da portadora em Hz. Default \u00e9 4000 Hz</p> <code>4000</code> <code>fs</code> <code>float</code> <p>Frequ\u00eancia de amostragem em Hz. Default \u00e9 128000 Hz.</p> <code>128000</code> <code>Rb</code> <code>float</code> <p>Taxa de bits em bps. Default \u00e9 400 b</p> <code>400</code> <code>output_print</code> <code>bool</code> <p>Se True, imprime os vetores intermedi\u00e1rios no console. Default \u00e9 True.</p> <code>True</code> <code>output_plot</code> <code>bool</code> <p>Se True, gera e salva os gr\u00e1ficos dos processos intermedi\u00e1rios.</p> <code>True</code>"},{"location":"api/transmitter/#transmitter.Transmitter.prepare_datagram","title":"<code>prepare_datagram()</code>","text":"<p>Prepara o datagrama para transmiss\u00e3o, retornando o vetor de bits \\(u_t\\).</p> <p>Returns:</p> Name Type Description <code>ut</code> <code>ndarray</code> <p>Vetor de bits do datagrama.</p>"},{"location":"api/transmitter/#transmitter.Transmitter.encode_convolutional","title":"<code>encode_convolutional(ut)</code>","text":"<p>Codifica o vetor de bits \\(u_t\\) usando codifica\u00e7\u00e3o convolucional.</p> <p>Parameters:</p> Name Type Description Default <code>ut</code> <code>ndarray</code> <p>Vetor de bits a ser codificado.</p> required <p>Returns:</p> Name Type Description <code>vt0</code> <code>ndarray</code> <p>Sa\u00edda do canal I.</p> <code>vt1</code> <code>ndarray</code> <p>Sa\u00edda do canal Q.</p>"},{"location":"api/transmitter/#transmitter.Transmitter.scramble","title":"<code>scramble(vt0, vt1)</code>","text":"<p>Embaralha os vetores de bits dos canais I e Q.</p> <p>Parameters:</p> Name Type Description Default <code>vt0</code> <code>ndarray</code> <p>Vetor de bits do canal I.</p> required <code>vt1</code> <code>ndarray</code> <p>Vetor de bits do canal Q.</p> required <p>Returns:</p> Name Type Description <code>Xn</code> <code>ndarray</code> <p>Vetor embaralhado do canal I.</p> <code>Yn</code> <code>ndarray</code> <p>Vetor embaralhado do canal Q.</p>"},{"location":"api/transmitter/#transmitter.Transmitter.generate_preamble","title":"<code>generate_preamble()</code>","text":"<p>Gera os vetores de pre\u00e2mbulo \\(S_I\\) e \\(S_Q\\).</p> <p>Returns:</p> Name Type Description <code>sI</code> <code>ndarray</code> <p>Vetor do pre\u00e2mbulo do canal I.</p> <code>sQ</code> <code>ndarray</code> <p>Vetor do pre\u00e2mbulo do canal Q.</p>"},{"location":"api/transmitter/#transmitter.Transmitter.multiplex","title":"<code>multiplex(sI, sQ, X, Y)</code>","text":"<p>Multiplexa os vetores de pre\u00e2mbulo e dados dos canais I e Q.</p> <p>Parameters:</p> Name Type Description Default <code>sI</code> <code>ndarray</code> <p>Vetor do pre\u00e2mbulo do canal I.</p> required <code>sQ</code> <code>ndarray</code> <p>Vetor do pre\u00e2mbulo do canal Q.</p> required <code>X</code> <code>ndarray</code> <p>Vetor de dados do canal I.</p> required <code>Y</code> <code>ndarray</code> <p>Vetor de dados do canal Q.</p> required <p>Returns:</p> Name Type Description <code>Xn</code> <code>ndarray</code> <p>Vetor multiplexado do canal I.</p> <code>Yn</code> <code>ndarray</code> <p>Vetor multiplexado do canal Q.</p>"},{"location":"api/transmitter/#transmitter.Transmitter.encode_channels","title":"<code>encode_channels(Xn, Yn)</code>","text":"<p>Codifica os vetores dos canais I e Q usando NRZ e Manchester, respectivamente.</p> <p>Parameters:</p> Name Type Description Default <code>Xn</code> <code>ndarray</code> <p>Vetor do canal I a ser codificado.</p> required <code>Yn</code> <code>ndarray</code> <p>Vetor do canal Q a ser codificado.</p> required <p>Returns:</p> Name Type Description <code>Xnrz</code> <code>ndarray</code> <p>Vetor codificado do canal I (NRZ).</p> <code>Yman</code> <code>ndarray</code> <p>Vetor codificado do canal Q (Manchester).</p>"},{"location":"api/transmitter/#transmitter.Transmitter.format_signals","title":"<code>format_signals(Xnrz, Yman)</code>","text":"<p>Formata os vetores dos canais I e Q usando filtro RRC.</p> <p>Parameters:</p> Name Type Description Default <code>Xnrz</code> <code>ndarray</code> <p>Vetor do canal I a ser formatado.</p> required <code>Yman</code> <code>ndarray</code> <p>Vetor do canal Q a ser formatado.</p> required <p>Returns:</p> Name Type Description <code>dI</code> <code>ndarray</code> <p>Vetor formatado do canal I.</p> <code>dQ</code> <code>ndarray</code> <p>Vetor formatado do canal Q.</p>"},{"location":"api/transmitter/#transmitter.Transmitter.modulate","title":"<code>modulate(dI, dQ)</code>","text":"<p>Modula os vetores formatados dos canais I e Q usando modula\u00e7\u00e3o QPSK.</p> <p>Parameters:</p> Name Type Description Default <code>dI</code> <code>ndarray</code> <p>Vetor formatado do canal I.</p> required <code>dQ</code> <code>ndarray</code> <p>Vetor formatado do canal Q.</p> required <p>Returns:</p> <pre><code>t (np.ndarray): Vetor de tempo.\ns (np.ndarray): Sinal modulado.\n</code></pre>"},{"location":"api/transmitter/#transmitter.Transmitter.run","title":"<code>run()</code>","text":"<p>Executa o processo de transmiss\u00e3o, retornando o resultado da transmiss\u00e3o.</p> <p>Returns:</p> Name Type Description <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> <code>s</code> <code>ndarray</code> <p>Sinal modulado \\(s(t)\\).</p>"},{"location":"api/transmitter/#transmitter.TransmissionResult.save","title":"<code>save(path_prefix='../out/transmission')</code>","text":"<p>Salva os resultados em arquivos TXT.</p>"}]}