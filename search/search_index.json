{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Simulador ARGOS-3","text":"<p>O Simulador ARGOS-3 \u00e9 uma ferramenta computacional desenvolvida em Python com o objetivo de estudar, analisar e validar a comunica\u00e7\u00e3o via sat\u00e9lite no padr\u00e3o ARGOS-3.  </p> <p>O padr\u00e3o ARGOS-3 \u00e9 empregado pelo Sistema Brasileiro de Coleta de Dados Ambientais (SBCDA), sob responsabilidade do Instituto Nacional de Pesquisas Espaciais (INPE), para o recebimento de informa\u00e7\u00f5es provenientes de milhares de Plataformas de Coleta de Dados (PCDs) distribu\u00eddas em todo o territ\u00f3rio nacional. As transmiss\u00f5es realizadas pelas PCDs s\u00e3o retransmitidas por sat\u00e9lites como o SCD-1, SCD-2 e pela s\u00e9rie CBERS, que orbitam a aproximadamente 750 km de altitude.  </p> <p> </p> <p>O simulador foi projetado para reproduzir os principais aspectos e desafios da comunica\u00e7\u00e3o com sat\u00e9lites, incorporando conceitos fundamentais, tais como:</p> <ul> <li>T\u00e9cnicas de modula\u00e7\u00e3o, codifica\u00e7\u00e3o e sincroniza\u00e7\u00e3o de sinais  </li> <li>Modelagem de efeitos de canal, incluindo ru\u00eddo, interfer\u00eancias e atenua\u00e7\u00e3o</li> </ul> <p>Este reposit\u00f3rio consolida a documenta\u00e7\u00e3o, os testes e os resultados de simula\u00e7\u00e3o do ARGOS-3, constituindo uma base de refer\u00eancia para pesquisas acad\u00eamicas, iniciativas de desenvolvimento tecnol\u00f3gico e aplica\u00e7\u00f5es em monitoramento ambiental no Brasil.</p>"},{"location":"api/bersnr/","title":"BER vs SNR","text":"<p>Define o n\u00famero de repeti\u00e7\u00f5es em fun\u00e7\u00e3o do \\(Eb/N0\\), usa interpola\u00e7\u00e3o linear entre pontos de refer\u00eancia.</p> <p>Simula a transmiss\u00e3o e recep\u00e7\u00e3o de um datagrama ARGOS-3, para um dado \\(Eb/N0\\).</p> <p>Parameters:</p> Name Type Description Default <code>ebn0_db</code> <code>float</code> <p>Rela\u00e7\u00e3o \\(Eb/N0\\) em decib\u00e9is.</p> required <code>numblocks</code> <code>int</code> <p>N\u00famero de blocos a serem transmitidos.</p> <code>8</code> <code>fs</code> <code>int</code> <p>Frequ\u00eancia de amostragem.</p> <code>128000</code> <code>Rb</code> <code>int</code> <p>Taxa de bits. </p> <code>400</code> <p>Returns:</p> Name Type Description <code>ber</code> <code>float</code> <p>A taxa de erro de bit (BER) simulada.</p> <p>Simula a transmiss\u00e3o e recep\u00e7\u00e3o QPSK em canal AWGN para um dado Eb/N0.</p> <p>Parameters:</p> Name Type Description Default <code>ebn0_db</code> <code>float</code> <p>Rela\u00e7\u00e3o Eb/N0 em dB.</p> required <code>num_bits</code> <code>int</code> <p>N\u00famero de bits simulados.</p> <code>1000</code> <code>bits_por_simbolo</code> <code>int</code> <p>N\u00famero de bits por s\u00edmbolo (QPSK = 2).</p> <code>2</code> <code>rng</code> <code>(Generator, opcional)</code> <p>gerador de n\u00fameros aleat\u00f3rios.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <p>BER simulada.</p> <p>Executa a simula\u00e7\u00e3o completa de BER vs Eb/N0 para ARGOS e QPSK.</p> <p>Parameters:</p> Name Type Description Default <code>EbN0_values</code> <code>ndarray</code> <p>Valores de Eb/N0 a serem simulados.</p> <code>arange(0, 12, 0.5)</code> <code>num_workers</code> <code>int</code> <p>N\u00famero de processos para execu\u00e7\u00e3o paralela.</p> <code>28</code> <p>Returns:</p> Name Type Description <code>list</code> <p>Lista de [Eb/N0, BER_ARGOS_m\u00e9dio, BER_QPSK_m\u00e9dio].</p> Exemplos <ul> <li>Argos e QPSK: </li> </ul>"},{"location":"api/convolutional/","title":"Codificador Convolutional","text":""},{"location":"api/convolutional/#convolutional.EncoderConvolutional.__init__","title":"<code>__init__(G=np.array([[121, 91]]))</code>","text":"<p>Inicializa o codificador convolucional, com base em uma tupla de polin\u00f4mios geradores \\(G\\) que determinam a estrutura do codificador.</p> \\[ \\begin{equation}     \\begin{split}         G_0 &amp;= 121_{10} \\quad \\mapsto \\quad G_0 = [1, 1, 1, 0, 0, 1, 1] \\\\         G_1 &amp;= 91_{10} \\quad \\mapsto \\quad G_1 = [1, 1, 0, 1, 1, 0, 1]     \\end{split} \\end{equation} \\] <p>O codificador convolucional, considerando \\(G_0\\) e \\(G_1\\) pode ser representado pelo diagrama de blocos abaixo.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>ndarray</code> <p>Tupla de polin\u00f4mios geradores \\(G\\).</p> <code>array([[121, 91]])</code> Exemplo <p></p> Refer\u00eancia: <p>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.4)</p> <p>CCSDS 131.1-G-2</p>"},{"location":"api/convolutional/#convolutional.EncoderConvolutional.calc_taps","title":"<code>calc_taps(poly)</code>","text":"<p>Calcula os \u00edndices dos bits ativos (\\('1'\\)), ou taps, do polin\u00f4mio gerador \\(G_n\\).</p> <p>Parameters:</p> Name Type Description Default <code>poly</code> <code>int</code> <p>Polin\u00f4mio gerador \\(G_n\\) em formato bin\u00e1rio. </p> required <p>Returns:</p> Name Type Description <code>taps</code> <code>int</code> <p>Lista com os \u00edndices dos taps ativos.</p>"},{"location":"api/convolutional/#convolutional.EncoderConvolutional.calc_free_distance","title":"<code>calc_free_distance()</code>","text":"<p>Calcula a dist\u00e2ncia livre \\(d_{free}\\) do c\u00f3digo convolucional, definida como a menor dist\u00e2ncia de Hamming entre quaisquer duas sequ\u00eancias de sa\u00edda distintas.</p> <p>Returns:</p> Name Type Description <code>dist</code> <code>int</code> <p>Dist\u00e2ncia livre \\(d_{free}\\) do codificador convolucional organizado com \\(G\\).</p>"},{"location":"api/convolutional/#convolutional.EncoderConvolutional.encode","title":"<code>encode(ut)</code>","text":"<p>Codifica uma sequ\u00eancia bin\u00e1ria de entrada \\(u_t\\), retornando as sequ\u00eancias de saida \\(v_t^{(0)}\\) e \\(v_t^{(1)}\\). O processo de codifica\u00e7\u00e3o pode ser representado pela express\u00e3o abaixo.</p> \\[ \\begin{equation} \\begin{bmatrix} v_t^{(0)} &amp; v_t^{(1)} \\end{bmatrix} = \\begin{bmatrix} u_{(t)} &amp; u_{(t-1)} &amp; u_{(t-2)} &amp; u_{(t-3)} &amp; u_{(t-4)} &amp; u_{(t-5)} &amp; u_{(t-6)} \\end{bmatrix} \\cdot \\begin{bmatrix} G_{0} &amp; G_{1} \\end{bmatrix}^{T} \\end{equation} \\] Sendo <ul> <li>\\(v_t^{(0)}\\) e \\(v_t^{(1)}\\): Canais de sa\u00edda do codificador.</li> <li>\\(u_t\\): Vetor de bits de entrada.</li> <li>\\(G_{0}\\) e \\(G_{1}\\): Polin\u00f4mios geradores do codificador.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>ut</code> <code>ndarray</code> <p>Vetor de bits \\(u_t\\) de entrada a serem codificados.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>(ndarray, ndarray)</code> <p>Tupla com os dois canais de sa\u00edda \\(v_t^{(0)}\\) e \\(v_t^{(1)}\\).</p>"},{"location":"api/data/","title":"Data","text":""},{"location":"api/data/#data.ExportData","title":"<code>ExportData</code>","text":"<p>Classe para armazenar o resultado da transmiss\u00e3o, incluindo o sinal modulado e o vetor de tempo. Pode salvar um \u00fanico vetor ou m\u00faltiplos vetores em um \u00fanico arquivo.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>Union[ndarray, List[ndarray]]</code> <p>Um \u00fanico vetor ou lista de vetores para salvar.</p> required <code>filename</code> <code>str</code> <p>Nome do arquivo de sa\u00edda.</p> required <code>path</code> <code>str</code> <p>Caminho do diret\u00f3rio de sa\u00edda.</p> <code>'../out'</code>"},{"location":"api/data/#data.ExportData.save","title":"<code>save(binary=True)</code>","text":"<p>Salva os resultados em arquivo bin\u00e1rio (.npy) ou em TXT.</p> <p>Parameters:</p> Name Type Description Default <code>binary</code> <code>bool</code> <p>Se True, salva em formato bin\u00e1rio (.npy).           Se False, salva em formato de texto (.txt).</p> <code>True</code>"},{"location":"api/data/#data.ImportData","title":"<code>ImportData</code>","text":"<p>Classe para carregar um vetor salvo em arquivo.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Nome do arquivo (sem extens\u00e3o).</p> required <code>path</code> <code>str</code> <p>Caminho do diret\u00f3rio de entrada.</p> <code>'../out'</code>"},{"location":"api/data/#data.ImportData.load","title":"<code>load(mode='npy', dtype=np.float64)</code>","text":"<p>Carrega o vetor salvo.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>Formato do arquivo: - \"npy\" : arquivo bin\u00e1rio com metadados do NumPy (.npy) - \"bin\" : dados crus em bin\u00e1rio (.bin) - \"txt\" : arquivo de texto (.txt)</p> <code>'npy'</code> <code>dtype</code> <code>dtype</code> <p>Tipo de dado (usado apenas para \"bin\").</p> <code>float64</code> <p>Returns:</p> Type Description <p>np.ndarray: Vetor carregado.</p>"},{"location":"api/datagram/","title":"Datagrama","text":""},{"location":"api/datagram/#datagram.Datagram.__init__","title":"<code>__init__(pcdnum=None, numblocks=None, streambits=None)</code>","text":"<p>Inicializa uma inst\u00e2ncia de datagrama no padr\u00e3o ARGOS-3. O formato do datagrama \u00e9 ilustrado na figura abaixo.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>pcdnum</code> <code>int</code> <p>N\u00famero identificador da PCD. Necess\u00e1rio para o modo TX.</p> <code>None</code> <code>numblocks</code> <code>int</code> <p>Quantidade de blocos de dados. Necess\u00e1rio para o modo TX.</p> <code>None</code> <code>streambits</code> <code>ndarray</code> <p>Sequ\u00eancia de bits do datagrama. Necess\u00e1rio para o modo RX.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se o n\u00famero de blocos n\u00e3o estiver entre 1 e 8.</p> <code>ValueError</code> <p>Se o n\u00famero PCD n\u00e3o estiver entre 0 e 1048575 \\((2^{20} - 1)\\).</p> <code>ValueError</code> <p>Se os par\u00e2metros <code>pcdnum</code> e <code>numblocks</code> ou <code>streambits</code> n\u00e3o forem fornecidos.</p> Exemplo <p></p> Refer\u00eancia: AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.2)"},{"location":"api/datagram/#datagram.Datagram.generate_blocks","title":"<code>generate_blocks()</code>","text":"<p>Gera os blocos de dados simulados (valores aleat\u00f3rios), com base na quantidade especificada de blocos. </p> <p>A quantidade de blocos pode variar de 1 \u00e1 8. O primeiro bloco tem comprimento de 24bits, enquanto que todos os demais blocos tem 32bits. Dessa forma, os dados o comprimento dos dados de aplica\u00e7\u00e3o s\u00e3o dados pela express\u00e3o abaixo.</p> \\[ L_{app} = 24 + 32 \\cdot (n-1) \\] Sendo <ul> <li>\\(L_{app}\\): Comprimento do datagrama em bits </li> <li>\\(n\\): N\u00famero de blocos do datagrama, podendo variar de 1 \u00e1 8. </li> </ul> <p>Returns:</p> Name Type Description <code>blocks</code> <code>ndarray</code> <p>Vetor de bits representando os blocos de dados.</p> Refer\u00eancia: AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.2)"},{"location":"api/datagram/#datagram.Datagram.generate_pcdid","title":"<code>generate_pcdid()</code>","text":"<p>Gera o campo \\(PCD_{ID}\\) a partir do n\u00famero PCD (\\(PCD_{num}\\)), Primeiro gera-se a sequ\u00eancia de 20 bits correspondente ao n\u00famero PCD.</p> \\[   PCDnum_{10} \\mapsto PCDnum_{2}   \\] Sendo <ul> <li>\\(PCDnum_{10}\\): Valor decimal do campo \\(PCD_{num}\\), podendo variar de 0 \u00e1 1048575 \\((2^{20} - 1)\\).</li> <li>\\(PCDnum_{2}\\): Sequ\u00eancia de 20 bits correspondente ao valor de \\(PCD_{num}\\).</li> </ul> <p>Em seguida, \u00e9 calculado o checksum, \\(R_{PCD}\\), do campo \\(PCD_{num}\\), obtido atrav\u00e9s da soma dos bits e aplica\u00e7\u00e3o da opera\u00e7\u00e3o m\u00f3dulo 256 (\\(2^8\\)).</p> \\[ \\begin{equation} R_{PCD} = \\left( \\sum_{i=0}^{19} b_i \\cdot 2^i \\right) \\bmod 256 \\end{equation} \\] Sendo <ul> <li>\\(R_{PCD}\\): Sequ\u00eancia de 8 bits correspondente ao checksum do campo \\(PCD_{num}\\).</li> <li>\\(i\\): Indice do bit do campo \\(PCD_{num}\\).</li> <li>\\(b\\): Valor do bit do campo \\(PCD_{num}\\).</li> </ul> <p>O campo \\(PCD_{ID}\\) \u00e9 gerado concatenando os par\u00e2metros gerados, sendo \\(PCD_{ID} = PCD_{num} \\oplus R_{PCD}\\).</p> <p>Returns:</p> Name Type Description <code>pcd_id</code> <code>ndarray</code> <p>Vetor de bits contendo o PCD ID e o checksum.       </p> Refer\u00eancia: AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.2)"},{"location":"api/datagram/#datagram.Datagram.generate_msglength","title":"<code>generate_msglength()</code>","text":"<p>Gera o valor do comprimento de mensagem \\(T_{m}\\) com base na quantidade de blocos \\(n\\). Primeiro, deve-se calcular a sequ\u00eancia de bits \\(B_m\\). </p> <p>$$    Bm_{10} = (n - 1) \\mapsto Bm_{2}   $$</p> Sendo <ul> <li>\\(B_m\\): Sequ\u00eancia de tr\u00eas bits correspondendo ao tamanho de mensagem. </li> <li>\\(n\\): N\u00famero de blocos do datagrama, podendo variar de 1 \u00e1 8. </li> </ul> <p>Em seguida, \u00e9 calculado o quarto bit \\(P_m\\) (bit de paridade).</p> \\[ \\begin{equation}     P_m =      \\begin{cases}     1, &amp; \\text{se } \\left[ \\sum_{i=0}^{B_m} b_i = 0 \\right]\\mod 2  \\\\     0, &amp; \\text{se } \\left[ \\sum_{i=0}^{B_m} b_i = 1 \\right]\\mod 2      \\end{cases} \\text{.} \\end{equation} \\] Sendo <ul> <li>\\(P_m\\): Bit de paridade.</li> <li>\\(i\\): Indice de bit do campo \\(B_m\\).</li> </ul> <p>O campo \\(T_{m}\\) \u00e9 gerado concatenando os par\u00e2metros gerados, sendo \\(T_{m} = B_{m} \\oplus P_{m}\\).</p> <p>Returns:</p> Name Type Description <code>msg_length</code> <code>ndarray</code> <p>Vetor de 4 bits representando o campo Message Length.</p> Refer\u00eancia: AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.2)"},{"location":"api/datagram/#datagram.Datagram.generate_tail","title":"<code>generate_tail()</code>","text":"<p>Gera a cauda do datagrama \\(E_m\\), utilizado para limpar o registrador do codificador convolucional.</p> \\[ E_m = 7 + [(n - 1) \\bmod 3] \\] Sendo <ul> <li>\\(E_m\\): Comprimento de cauda do datagrama (zeros) adicionada ao final do datagrama. </li> <li>\\(n\\): N\u00famero de blocos do datagrama.</li> </ul> <p>Returns:</p> Name Type Description <code>tail</code> <code>ndarray</code> <p>Vetor de bits zerados com comprimento vari\u00e1vel (7, 8 ou 9 bits).</p> Refer\u00eancia: AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.3)"},{"location":"api/datagram/#datagram.Datagram.parse_datagram","title":"<code>parse_datagram()</code>","text":"<p>Interpreta a sequ\u00eancia de bits do datagrama, extraindo campos e validando integridade.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>json</code> <p>Objeto JSON contendo a representa\u00e7\u00e3o estruturada do datagrama.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Caso haja falha na valida\u00e7\u00e3o de paridade do comprimento de mensagem \\(T_m\\).</p> <code>ValueError</code> <p>Caso haja falha no checksum do campo \\(PCD_{ID}\\). </p> <code>ValueError</code> <p>Se a sequ\u00eancia de bits de aplica\u00e7\u00e3o n\u00e3o corresponder ao comprimento de \\(T_m\\).</p> Exemplo <pre><code>&gt;&gt;&gt; datagram = Datagram(streambits=bits)\n&gt;&gt;&gt; print(datagram.parse_datagram())\n{\n  \"msglength\": 2,\n  \"pcdid\": 1234,\n  \"data\": {\n    \"bloco_1\": {\n      \"sensor_1\": 42,\n      \"sensor_2\": 147,\n      \"sensor_3\": 75\n    },\n    \"bloco_2\": {\n      \"sensor_1\": 138,\n      \"sensor_2\": 7,\n      \"sensor_3\": 134,\n      \"sensor_4\": 182\n    }\n  },\n  \"tail\": 8\n}\n</code></pre>"},{"location":"api/encoder/","title":"Codificador NRZ e MAN","text":""},{"location":"api/encoder/#encoder.Encoder.__init__","title":"<code>__init__(method)</code>","text":"<p>Inicializa o codificador de linha com o m\u00e9todo de codifica\u00e7\u00e3o especificado. </p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>M\u00e9todo de codifica\u00e7\u00e3o desejado, \\(NRZ\\) ou \\(Manchester\\).</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Se o m\u00e9todo de codifica\u00e7\u00e3o n\u00e3o for suportado.</p> Exemplo <p></p> Refer\u00eancia: AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.2.4)"},{"location":"api/encoder/#encoder.Encoder.encode","title":"<code>encode(bitstream)</code>","text":"<p>Codifica o vetor de bits usando o m\u00e9todo especificado na inicializa\u00e7\u00e3o. O processo de codifica\u00e7\u00e3o de linha \u00e9 dado pelas express\u00f5es abaixo correspondente a cada m\u00e9todo. </p> \\[ \\begin{equation} \\begin{aligned} X_{\\text{NRZ}}[n] &amp;=  \\begin{cases} 11, &amp; \\text{se } X_n = 1 \\\\ 00, &amp; \\text{se } X_n = 0 , \\end{cases} &amp;\\quad\\quad Y_{\\text{MAN}}[n] &amp;= \\begin{cases} 10, &amp; \\text{se } Y_n = 1 \\\\ 01, &amp; \\text{se } Y_n = 0 . \\end{cases} \\end{aligned} \\end{equation} \\] Sendo <ul> <li>\\(X_n\\) e \\(Y_n\\): Vetor de bits de entrada.</li> <li>\\(X_{\\text{NRZ}}[n]\\) e \\(Y_{\\text{MAN}}[n]\\): Vetor de simbolos de sa\u00edda.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>bitstream</code> <code>ndarray</code> <p>Vetor de bits a ser codificado.</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>ndarray</code> <p>Vetor de simbolos codificados.</p>"},{"location":"api/encoder/#encoder.Encoder.decode","title":"<code>decode(encoded_stream)</code>","text":"<p>Decodifica o vetor de simbolos usando o m\u00e9todo especificado na inicializa\u00e7\u00e3o. O processo de decodifica\u00e7\u00e3o de linha \u00e9 dado pelas express\u00f5es abaixo correspondente a cada m\u00e9todo.</p> \\[ \\begin{equation} \\begin{aligned} X_n &amp;=  \\begin{cases} 1, &amp; \\text{se } X_{\\text{NRZ}}[n] = 11 \\\\ 0, &amp; \\text{se } X_{\\text{NRZ}}[n] = 00 \\end{cases} &amp;\\quad\\quad Y_n &amp;= \\begin{cases} 1, &amp; \\text{se } Y_{\\text{MAN}}[n] = 10 \\\\ 0, &amp; \\text{se } Y_{\\text{MAN}}[n] = 01 \\end{cases} \\end{aligned} \\end{equation} \\] Sendo <ul> <li>\\(X_{\\text{NRZ}}[n]\\) e \\(Y_{\\text{MAN}}[n]\\): Vetor de simbolos de entrada</li> <li>\\(X_n\\) e \\(Y_n\\): Vetor de bits de sa\u00edda.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>encoded_stream</code> <code>ndarray</code> <p>Vetor codificado.</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>ndarray</code> <p>Vetor de bits decodificado.</p>"},{"location":"api/formatter/","title":"Formatador","text":""},{"location":"api/formatter/#formatter.Formatter.__init__","title":"<code>__init__(alpha=0.8, fs=128000, Rb=400, span=6, type='RRC')</code>","text":"<p>Inicializa uma inst\u00e2ncia de formatador, utilizado preparar os s\u00edmbolos para modula\u00e7\u00e3o.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>Fator de roll-off do pulso RRC.</p> <code>0.8</code> <code>fs</code> <code>int</code> <p>Frequ\u00eancia de amostragem.</p> <code>128000</code> <code>Rb</code> <code>int</code> <p>Taxa de bits.</p> <code>400</code> <code>span</code> <code>int</code> <p>Dura\u00e7\u00e3o do pulso em termos de per\u00edodos de bit.</p> <code>6</code> <code>type</code> <code>str</code> <p>Tipo de pulso, atualmente apenas \\(RRC\\) \u00e9 suportado.</p> <code>'RRC'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se o tipo de pulso n\u00e3o for suportado.</p> Exemplo <p></p> Refer\u00eancia: EEL7062 \u2013 Princ\u00edpios de Sistemas de Comunica\u00e7\u00e3o, Richard Demo Souza (Pg. 55)"},{"location":"api/formatter/#formatter.Formatter.rrc_pulse","title":"<code>rrc_pulse()</code>","text":"<p>Gera o pulso Root Raised Cosine (\\(RRC\\)). O pulso \\(RRC\\) no dominio do tempo \u00e9 definido pela express\u00e3o abaixo.</p> \\[     g(t) = \\frac{(1 - \\alpha) sinc((1- \\alpha) t / T_b) + \\alpha (4/\\pi) \\cos(\\pi (1 + \\alpha) t / T_b)}{1 - (4 \\alpha t / T_b)^2} \\] Sendo <ul> <li>\\(g(t)\\): Pulso formatador \\(RRC\\) no dominio do tempo.</li> <li>\\(\\alpha\\): Fator de roll-off do pulso.</li> <li>\\(T_b\\): Per\u00edodo de bit.</li> <li>\\(t\\): Vetor de tempo.</li> </ul> <p>Returns:</p> Name Type Description <code>rc</code> <code>ndarray</code> <p>Pulso RRC.</p> Exemplo <ul> <li></li> </ul>"},{"location":"api/formatter/#formatter.Formatter.apply_format","title":"<code>apply_format(symbols)</code>","text":"<p>Formata os s\u00edmbolos de entrada usando o pulso inicializado. O processo de formata\u00e7\u00e3o \u00e9 dado por: </p> \\[    d(t) = \\sum_{n} x[n] \\cdot g(t - nT_b) \\] Sendo <ul> <li>\\(d(t)\\): Sinal formatado de sa\u00edda.</li> <li>\\(x\\): Vetor de s\u00edmbolos de entrada.</li> <li>\\(g(t)\\): Pulso formatador.</li> <li>\\(n\\): Indice de bit.</li> <li>\\(T_b\\): Per\u00edodo de bit.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>symbols</code> <code>ndarray</code> <p>Vetor de s\u00edmbolos a serem formatados.</p> required <p>Returns:</p> Name Type Description <code>out_symbols</code> <code>ndarray</code> <p>Vetor formatado com o pulso aplicado.</p>"},{"location":"api/lpf/","title":"Filtro Passa Baixa","text":""},{"location":"api/lpf/#lowpassfilter.LPF.__init__","title":"<code>__init__(cut_off, order, fs=128000, type='butter')</code>","text":"<p>Inicializa uma inst\u00e2ncia de filtro passa-baixa com base em uma frequ\u00eancia de corte \\(f_{cut}\\) e uma ordem \\(N\\).</p> <p>Parameters:</p> Name Type Description Default <code>cut_off</code> <code>float</code> <p>Frequ\u00eancia de corte \\(f_{cut}\\) do filtro.</p> required <code>order</code> <code>int</code> <p>Ordem \\(N\\) do filtro.</p> required <code>fs</code> <code>(int, opcional)</code> <p>Frequ\u00eancia de amostragem \\(f_s\\). </p> <code>128000</code> <code>type</code> <code>(str, opcional)</code> <p>Tipo de filtro. Padr\u00e3o \u00e9 \"butter\".</p> <code>'butter'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se o tipo de filtro for inv\u00e1lido.</p> Exemplo <p></p>"},{"location":"api/lpf/#lowpassfilter.LPF.butterworth_filter","title":"<code>butterworth_filter(fNyquist=0.5)</code>","text":"<p>Calcula os coeficientes do filtro Butterworth utilizando a biblioteca <code>scipy.signal</code>. A fun\u00e7\u00e3o de transfer\u00eancia cont\u00ednua \\(H(s)\\) de um filtro Butterworth \u00e9 dada pela express\u00e3o abaixo.</p> \\[ H(s) = \\frac{1}{1 + \\left(\\frac{s}{2 \\pi f_{cut}}\\right)^{2n}} \\] Sendo <ul> <li>\\(s\\): Vari\u00e1vel complexa no dom\u00ednio de Laplace.</li> <li>\\(2 \\pi f_{cut}\\): Frequ\u00eancia angular de corte do filtro.</li> <li>\\(n\\): Ordem do filtro.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>fNyquist</code> <code>float</code> <p>Fator de Nyquist. Padr\u00e3o \u00e9 0.5 * fs.</p> <code>0.5</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>Coeficientes \\(b\\) e \\(a\\) correspondentes \u00e0 fun\u00e7\u00e3o de transfer\u00eancia do filtro Butterworth.</p>"},{"location":"api/lpf/#lowpassfilter.LPF.calc_impulse_response","title":"<code>calc_impulse_response(impulse_len=1024)</code>","text":"<p>Para obter a resposta ao impulso no dominio do tempo, um impulso unit\u00e1rio \u00e9 aplicado como entrada. Para um filtro Butterworth, o calculo \u00e9 dado pela express\u00e3o abaixo. </p> \\[ h(t) = \\mathcal{L}^{-1}\\left\\{H(f)\\right\\} \\] Sendo <ul> <li>\\(h(t)\\): Resposta ao impulso do filtro.</li> <li>\\(H(f)\\): Fun\u00e7\u00e3o de transfer\u00eancia do filtro.</li> <li>\\(\\mathcal{L}^{-1}\\): Transformada de Laplace inversa.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>impulse_len</code> <code>int</code> <p>Comprimento do vetor de impulso.</p> <code>1024</code> <p>Returns:</p> Name Type Description <code>impulse_response</code> <code>tuple[ndarray, ndarray]</code> <p>Resposta ao impulso e vetor de tempo.</p> Exemplo <p></p>"},{"location":"api/lpf/#lowpassfilter.LPF.apply_filter","title":"<code>apply_filter(signal)</code>","text":"<p>Aplica o filtro passa-baixa com resposta ao impulso \\(h(t)\\) ao sinal de entrada \\(s(t)\\), utilizando a fun\u00e7\u00e3o <code>scipy.signal.filtfilt</code>. O processo de filtragem \u00e9 dado pela express\u00e3o abaixo. </p> \\[     x(t) = s(t) \\ast h(t) \\] Sendo <ul> <li>\\(x(t)\\): Sinal filtrado.</li> <li>\\(s(t)\\): Sinal de entrada.</li> <li>\\(h(t)\\): Resposta ao impulso do filtro.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>ndarray</code> <p>Sinal de entrada \\(s(t)\\).</p> required <p>Returns:</p> Name Type Description <code>signal_filtered</code> <code>ndarray</code> <p>Sinal filtrado \\(x(t)\\).</p>"},{"location":"api/matchedfilter/","title":"Filtro Casado","text":""},{"location":"api/matchedfilter/#matchedfilter.MatchedFilter.__init__","title":"<code>__init__(alpha=0.8, fs=128000, Rb=400, span=6, type='RRC-Inverted')</code>","text":"<p>Inicializa uma inst\u00e2ncia de filtro casado. O filtro casado \u00e9 usado para maximizar a SNR do sinal recebido.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>Fator de roll-off do filtro casado.</p> <code>0.8</code> <code>fs</code> <code>int</code> <p>Frequ\u00eancia de amostragem.</p> <code>128000</code> <code>Rb</code> <code>int</code> <p>Taxa de bits.</p> <code>400</code> <code>span</code> <code>int</code> <p>Dura\u00e7\u00e3o do pulso em termos de per\u00edodos de bit.</p> <code>6</code> <code>type</code> <code>str</code> <p>Tipo de filtro, atualmente apenas \"RRC-Inverted\" \u00e9 suportado.</p> <code>'RRC-Inverted'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se o tipo de pulso n\u00e3o for suportado.</p> Exemplo <p></p>"},{"location":"api/matchedfilter/#matchedfilter.MatchedFilter.rrc_inverted_pulse","title":"<code>rrc_inverted_pulse()</code>","text":"<p>Gera o pulso Root Raised Cosine (\\(RRC\\)) invertido \\(-g(t)\\) para filtragem casada do sinal de entrada.</p> \\[ \\begin{equation}     -g(t) = - \\frac{(1 - \\alpha) sinc((1- \\alpha) t / T_b) + \\alpha (4/\\pi) \\cos(\\pi (1 + \\alpha) t / T_b)}{1 - (4 \\alpha t / T_b)^2} \\end{equation} \\] Sendo <ul> <li>\\(-g(t)\\): Pulso formatador \\(RRC\\) invertido no dominio do tempo.</li> <li>\\(\\alpha\\): Fator de roll-off do pulso.</li> <li>\\(T_b\\): Per\u00edodo de bit.</li> <li>\\(t\\): Vetor de tempo.</li> </ul> <p>Returns:</p> Name Type Description <code>rc</code> <code>ndarray</code> <p>Pulso RRC invertido \\(-g(t)\\).</p> Exemplo <p></p>"},{"location":"api/matchedfilter/#matchedfilter.MatchedFilter.calc_impulse_response","title":"<code>calc_impulse_response(impulse_len=512)</code>","text":"<p>Calcula a resposta ao impulso do filtro casado.</p> <p>Parameters:</p> Name Type Description Default <code>impulse_len</code> <code>int</code> <p>Comprimento do vetor de impulso.</p> <code>512</code> <p>Returns:</p> Name Type Description <code>impulse_response</code> <code>tuple[ndarray, ndarray]</code> <p>Resposta ao impulso e vetor de tempo.</p>"},{"location":"api/matchedfilter/#matchedfilter.MatchedFilter.apply_filter","title":"<code>apply_filter(signal)</code>","text":"<p>Aplica o filtro casado com resposta ao impulso \\(-g(t)\\) ao sinal de entrada \\(s(t)\\). O processo de filtragem \u00e9 dado pela express\u00e3o abaixo. </p> \\[     x(t) = s(t) \\ast h(t) \\] Sendo <ul> <li>\\(x(t)\\): Sinal filtrado.</li> <li>\\(s(t)\\): Sinal de entrada.</li> <li>\\(-g(t)\\): Pulso formatador \\(RRC\\) invertido.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>ndarray</code> <p>Sinal de entrada \\(s(t)\\).</p> required <p>Returns:</p> Name Type Description <code>signal_filtered</code> <code>ndarray</code> <p>Sinal filtrado \\(x(t)\\).</p>"},{"location":"api/modulator/","title":"Modulador","text":""},{"location":"api/modulator/#modulator.Modulator.__init__","title":"<code>__init__(fc, fs=128000)</code>","text":"<p>Inicializa uma inst\u00e2ncia do modulador QPSK no padr\u00e3o ARGOS-3. O modulador pode ser representado pelo diagrama de blocos apresentado abaixo.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>fc</code> <code>float</code> <p>Frequ\u00eancia da portadora.</p> required <code>fs</code> <code>int</code> <p>Frequ\u00eancia de amostragem.</p> <code>128000</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se a frequ\u00eancia de amostragem n\u00e3o for maior que o dobro da frequ\u00eancia da portadora. (Teorema de Nyquist)</p> Exemplo <p></p> Refer\u00eancia: AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.2.5.3)"},{"location":"api/modulator/#modulator.Modulator.modulate","title":"<code>modulate(i_signal, q_signal)</code>","text":"<p>Modula em QPSK os sinais \\(d_I\\) e \\(d_Q\\) com uma portadora \\(f_c\\), resultando no sinal modulado \\(s(t)\\). O processo de modula\u00e7\u00e3o \u00e9 dado pela express\u00e3o abaixo.</p> \\[     s(t) = d_I(t) \\cdot \\cos(2\\pi f_c t) - d_Q(t) \\cdot \\sin(2\\pi f_c t) \\] Sendo <ul> <li>\\(s(t)\\): Sinal modulado.</li> <li>\\(d_I(t)\\) e \\(d_Q(t)\\): Sinais formatados correspondentes aos canais \\(I\\) e \\(Q\\).</li> <li>\\(f_c\\): Frequ\u00eancia da portadora.</li> <li>\\(t\\): Vetor de tempo.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>i_signal</code> <code>ndarray</code> <p>Sinal \\(d_I\\) correspondente ao canal \\(I\\) a ser modulado.</p> required <code>q_signal</code> <code>ndarray</code> <p>Sinal \\(d_Q\\) correspondente ao canal \\(Q\\) a ser modulado.</p> required <p>Returns:</p> Name Type Description <code>modulated_signal</code> <code>ndarray</code> <p>Sinal modulado \\(s(t)\\) resultante.</p> <code>t</code> <code>ndarray</code> <p>Vetor de tempo \\(t\\) correspondente ao sinal modulado.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se os sinais I e Q n\u00e3o tiverem o mesmo tamanho.</p>"},{"location":"api/modulator/#modulator.Modulator.demodulate","title":"<code>demodulate(modulated_signal)</code>","text":"<p>Demodula o sinal modulado em QPSK. Para o processo de demodula\u00e7\u00e3o, utiliza-se duas componentes auxiliares \\(x_I(t)\\) e \\(y_Q(t)\\) definidas pelas express\u00f5es abaixo.</p> \\[ \\begin{aligned} x_I(t) &amp;= 2 \\cos(2\\pi f_c t), &amp;\\quad y_Q(t) &amp;= 2 \\sin(2\\pi f_c t) \\end{aligned} \\] Sendo <ul> <li>\\(x_I(t)\\) e \\(y_Q(t)\\): Componentes auxiliares utilizadas para a demodula\u00e7\u00e3o.</li> <li>\\(f_c\\): Frequ\u00eancia da portadora.</li> <li>\\(t\\): Vetor de tempo.</li> </ul> <p>A partir das componentes criadas \u00e9 realizado o processo de demodula\u00e7\u00e3o (transla\u00e7\u00e3o em frequ\u00eancia), que resulta em duas componentes, uma em banda base e outra em \\(2f_c\\), conforme as express\u00f5es abaixo.</p> \\[ x_I'(t) = s(t) \\cdot x_I(t) = \\left[d_I(t) \\cos(2\\pi f_c t ) - d_Q(t) \\sin(2\\pi f_c t )\\right] \\cdot 2\\cos(2\\pi f_c t ) \\] \\[ y_Q'(t) = -s(t) \\cdot y_Q(t) = \\left[d_I(t) \\cos(2\\pi f_c t ) - d_Q(t) \\sin(2\\pi f_c t )\\right] \\cdot 2\\sin(2\\pi f_c t ) \\] Sendo <ul> <li>\\(x_I'(t)\\) e \\(y_Q'(t)\\): Componentes resultantes da demodula\u00e7\u00e3o.</li> <li>\\(x_I(t)\\) e \\(y_Q(t)\\): Componentes auxiliares utilizadas para a demodula\u00e7\u00e3o.</li> <li>\\(s(t)\\): Sinal modulado.</li> <li>\\(d_I(t)\\) e \\(d_Q(t)\\): Sinais formatados correspondentes aos canais \\(I\\) e \\(Q\\).</li> <li>\\(f_c\\): Frequ\u00eancia da portadora.</li> <li>\\(t\\): Vetor de tempo.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>modulated_signal</code> <code>ndarray</code> <p>Sinal modulado \\(s(t)\\) a ser demodulado.</p> required <p>Returns:</p> Name Type Description <code>i_signal</code> <code>ndarray</code> <p>Sinal \\(x_I'(t)\\) recuperado.</p> <code>q_signal</code> <code>ndarray</code> <p>Sinal \\(y_Q'(t)\\) recuperado.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se o sinal modulado estiver vazio.</p>"},{"location":"api/multiplexer/","title":"Multiplexador","text":""},{"location":"api/multiplexer/#multiplexer.Multiplexer.__init__","title":"<code>__init__()</code>","text":"<p>Inicializa o multiplexador no padr\u00e3o ARGOS-3.</p> Exemplo <p></p>"},{"location":"api/multiplexer/#multiplexer.Multiplexer.concatenate","title":"<code>concatenate(SI, SQ, Xn, Yn)</code>","text":"<p>Concatena os vetores \\(X_n\\) e \\(Y_n\\) de entrada, com \\(S_I\\) e \\(S_Q\\), retornando os vetores concatenados \\(X_n\\) e \\(Y_n\\). O processo de multiplexa\u00e7\u00e3o \u00e9 dado pela express\u00e3o abaixo.</p> \\[ \\begin{align} X_n = S_I \\oplus X_n \\text{ , } \\quad Y_n = S_Q \\oplus Y_n \\end{align} \\] <p>Parameters:</p> Name Type Description Default <code>SI</code> <code>ndarray</code> <p>Vetor de entrada \\(S_I\\).</p> required <code>SQ</code> <code>ndarray</code> <p>Vetor de entrada \\(S_Q\\).</p> required <code>Xn</code> <code>ndarray</code> <p>Vetor de entrada \\(X_n\\).</p> required <code>Yn</code> <code>ndarray</code> <p>Vetor de entrada \\(Y_n\\).</p> required <p>Returns:</p> Name Type Description <code>Xn</code> <code>ndarray</code> <p>Vetor \\(X_n\\) concatenado.</p> <code>Yn</code> <code>ndarray</code> <p>Vetor \\(Y_n\\) concatenado.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>Se os vetores I e Q n\u00e3o tiverem o mesmo comprimento em ambos os canais.</p>"},{"location":"api/noise/","title":"Noise","text":""},{"location":"api/noise/#noise.Noise.__init__","title":"<code>__init__(snr=15)</code>","text":"<p>Implementa\u00e7\u00e3o de canal para aplica\u00e7\u00e3o de ruido \\(AWGN\\), com base em \\(SNR\\).</p> <p>Parameters:</p> Name Type Description Default <code>snr</code> <code>float</code> <p>Rela\u00e7\u00e3o sinal-ru\u00eddo em decib\u00e9is (dB).</p> <code>15</code> Exemplo <p></p>"},{"location":"api/noise/#noise.Noise.add_noise","title":"<code>add_noise(signal)</code>","text":"<p>Adiciona ru\u00eddo AWGN \\(n(t)\\) ao sinal de entrada \\(s(t)\\), com base na \\(\\mathrm{SNR}_{dB}\\) definida na inicializa\u00e7\u00e3o. </p> \\[ r(t) = s(t) + n(t), \\qquad n(t) \\sim \\mathcal{N}(0, \\sigma^2) \\] Sendo <ul> <li>\\(r(t)\\): Sinal retornado com ru\u00eddo AWGN adicionado.</li> <li>\\(s(t)\\): Sinal de entrada sem ru\u00eddo. </li> <li>\\(n(t)\\): Ru\u00eddo adicionado, com distribui\u00e7\u00e3o normal \\(\\mathcal{N}(0, \\sigma^2)\\).</li> </ul> <p>A vari\u00e2ncia do ru\u00eddo \\(\\sigma^2\\) \u00e9 dada por:</p> \\[ \\sigma^2 = \\frac{\\mathbb{E}\\!\\left[ |s(t)|^2 \\right]}{10^{\\frac{\\mathrm{SNR}_{dB}}{10}}} \\] Sendo <ul> <li>\\(\\sigma^2\\): A vari\u00e2ncia do ru\u00eddo.</li> <li>\\(\\mathbb{E}\\!\\left[ |s(t)|^2 \\right]\\): Pot\u00eancia m\u00e9dia do sinal de entrada.</li> <li>\\(\\mathrm{SNR}_{dB}\\): Rela\u00e7\u00e3o sinal-ru\u00eddo em decib\u00e9is (dB).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>ndarray</code> <p>Sinal transmitido \\(s(t)\\).</p> required <p>Returns:</p> Name Type Description <code>signal</code> <code>ndarray</code> <p>Sinal \\(r(t)\\), com ru\u00eddo AWGN adicionado.</p> Exemplo <p></p>"},{"location":"api/noise/#noise.NoiseEBN0.__init__","title":"<code>__init__(ebn0_db=10, fs=128000, Rb=400)</code>","text":"<p>Implementa\u00e7\u00e3o de canal para aplica\u00e7\u00e3o de ruido \\(AWGN\\), com base em \\(Eb/N_{0}\\).</p> <p>Parameters:</p> Name Type Description Default <code>ebn0_db</code> <code>float</code> <p>Valor alvo de \\(Eb/N_{0}\\) em \\(dB\\)</p> <code>10</code> <code>fs</code> <code>int</code> <p>Taxa de amostragem do sinal em \\(Hz\\).</p> <code>128000</code> <code>Rb</code> <code>int</code> <p>Taxa de bits em bits/s.</p> <code>400</code>"},{"location":"api/noise/#noise.NoiseEBN0.add_noise","title":"<code>add_noise(signal)</code>","text":"<p>Adiciona ru\u00eddo AWGN $n(t) ao sinal de entrada $s(t), com base na \\(Eb/N0_{dB}\\) definida na inicializa\u00e7\u00e3o. </p> \\[ r(t) = s(t) + n(t), \\qquad n(t) \\sim \\mathcal{N}(0, \\sigma^2) \\] Sendo <ul> <li>\\(r(t)\\): Sinal retornado com ru\u00eddo AWGN adicionado.</li> <li>\\(s(t)\\): Sinal de entrada sem ru\u00eddo. </li> <li>\\(n(t)\\): Ru\u00eddo adicionado, com distribui\u00e7\u00e3o normal \\(\\mathcal{N}(0, \\sigma^2)\\).</li> </ul> <p>A vari\u00e2ncia do ru\u00eddo \\(\\sigma^2\\) \u00e9 dada por:</p> \\[ \\sigma^2 = \\frac{N_0 \\cdot f_s}{2} \\] Sendo <ul> <li>\\(\\sigma^2\\): A vari\u00e2ncia do ru\u00eddo.</li> <li>\\(N_0\\): Densidade espectral de ru\u00eddo.</li> <li>\\(f_s\\): Taxa de amostragem do sinal em \\(Hz\\).</li> </ul> <p>A densidade espectral de ru\u00eddo \\(N_0\\) \u00e9 dada por:</p> \\[ N_0 = \\frac{\\mathbb{E}\\!\\left[ |s(t)|^2 \\right]}{R_b \\cdot 10^{\\frac{Eb/N_0}{10}}} \\] Sendo <ul> <li>\\(N_0\\): Densidade espectral de ru\u00eddo.</li> <li>\\(\\mathbb{E}\\!\\left[ |s(t)|^2 \\right]\\): Pot\u00eancia m\u00e9dia do sinal amostrado.</li> <li>\\(R_b\\): Taxa de bits em bits/s.</li> <li>\\(Eb/N_0\\): Rela\u00e7\u00e3o \\(dB\\) da energia por bit \\(E_b\\) por densidade espectral de ru\u00eddo \\(N_0\\) dada na inicializa\u00e7\u00e3o.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>ndarray</code> <p>Sinal transmitido \\(s(t)\\).</p> required <p>Returns:</p> Name Type Description <code>signal</code> <code>ndarray</code> <p>Sinal recebido \\(r(t)\\), com ru\u00eddo AWGN adicionado.</p> Exemplo <p></p> Refer\u00eancia: <p>Digital communications / John G. Proakis, Masoud Salehi.\u20145th ed. (pg. 283)</p> <p>https://rwnobrega.page/posts/snr/</p>"},{"location":"api/plots/","title":"Plotter","text":""},{"location":"api/plots/#plotter.BasePlot","title":"<code>BasePlot</code>","text":"<p>Inicializa o plot.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Eixo do plot</p> required <code>title</code> <code>str</code> <p>T\u00edtulo do plot</p> <code>''</code> <code>labels</code> <code>Optional[List[str]]</code> <p>Lista de r\u00f3tulos</p> <code>None</code> <code>xlim</code> <code>Optional[Tuple[float, float]]</code> <p>Limites do eixo x</p> <code>None</code> <code>ylim</code> <code>Optional[Tuple[float, float]]</code> <p>Limites do eixo y</p> <code>None</code> <code>colors</code> <code>Optional[Union[str, List[str]]]</code> <p>Cores do plot</p> <code>None</code> <code>style</code> <code>Optional[Dict[str, Any]]</code> <p>Estilo do plot</p> <code>None</code>"},{"location":"api/plots/#plotter.TimePlot","title":"<code>TimePlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Classe para plotar sinais no dom\u00ednio do tempo.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figura do plot</p> required <code>grid</code> <code>GridSpec</code> <p>GridSpec do plot</p> required <code>pos</code> <code>int</code> <p>Posi\u00e7\u00e3o do plot</p> required <code>t</code> <code>ndarray</code> <p>Vetor de tempo</p> required <code>signals</code> <code>Union[ndarray, List[ndarray]]</code> <p>Sinal ou lista de sinais</p> required Exemplos <ul> <li>Modulador: </li> <li>Demodulador: </li> <li>Adi\u00e7\u00e3o de AWGN </li> </ul>"},{"location":"api/plots/#plotter.FrequencyPlot","title":"<code>FrequencyPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Classe para plotar sinais no dom\u00ednio da frequ\u00eancia.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figura do plot</p> required <code>grid</code> <code>GridSpec</code> <p>GridSpec do plot</p> required <code>pos</code> <code>int</code> <p>Posi\u00e7\u00e3o do plot</p> required <code>fs</code> <code>float</code> <p>Frequ\u00eancia de amostragem</p> required <code>signal</code> <code>ndarray</code> <p>Sinal a ser plotado</p> required <code>fc</code> <code>float</code> <p>Frequ\u00eancia central</p> <code>0.0</code> Exemplos <ul> <li>Modulador: </li> <li>Demodulador: </li> <li>Adi\u00e7\u00e3o de AWGN </li> </ul>"},{"location":"api/plots/#plotter.ConstellationPlot","title":"<code>ConstellationPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Classe para plotar sinais no dom\u00ednio da constela\u00e7\u00e3o.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figura do plot</p> required <code>grid</code> <code>GridSpec</code> <p>GridSpec do plot</p> required <code>pos</code> <code>int</code> <p>Posi\u00e7\u00e3o do plot</p> required <code>dI</code> <code>ndarray</code> <p>Sinal I</p> required <code>dQ</code> <code>ndarray</code> <p>Sinal Q</p> required <code>amplitude</code> <code>Optional[float]</code> <p>Amplitude alvo para pontos ideais</p> <code>None</code> Exemplos <ul> <li>Modulador: </li> </ul>"},{"location":"api/plots/#plotter.BitsPlot","title":"<code>BitsPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Classe para plotar bits.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figura do plot</p> required <code>grid</code> <code>GridSpec</code> <p>GridSpec do plot</p> required <code>pos</code> <code>int</code> <p>Posi\u00e7\u00e3o do plot</p> required <code>bits_list</code> <code>List[ndarray]</code> <p>Lista de bits</p> required <code>sections</code> <code>Optional[List[Tuple[str, int]]]</code> <p>Se\u00e7\u00f5es do plot</p> <code>None</code> <code>colors</code> <code>Optional[List[str]]</code> <p>Cores do plot</p> <code>None</code> Exemplos <ul> <li>Datagrama: </li> <li>Codificador Convolucional: </li> <li>Embaralhador: </li> <li>Pre\u00e2mbulo: </li> <li>Multiplexador: </li> </ul>"},{"location":"api/plots/#plotter.EncodedBitsPlot","title":"<code>EncodedBitsPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Classe para plotar bits com codifica\u00e7\u00e3o de linha.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figura do plot</p> required <code>grid</code> <code>GridSpec</code> <p>GridSpec do plot</p> required <code>pos</code> <code>int</code> <p>Posi\u00e7\u00e3o do plot</p> required <code>bits</code> <code>ndarray</code> <p>Vetor de bits</p> required <code>color</code> <code>str</code> <p>Cor do plot</p> <code>'black'</code> Exemplos <ul> <li>Codifica\u00e7\u00e3o de Linha: </li> </ul>"},{"location":"api/plots/#plotter.ImpulseResponsePlot","title":"<code>ImpulseResponsePlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Classe para plotar a resposta ao impulso de um filtro.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figura do plot</p> required <code>grid</code> <code>GridSpec</code> <p>GridSpec do plot</p> required <code>pos</code> <code>int</code> <p>Posi\u00e7\u00e3o do plot no GridSpec</p> required <code>t_imp</code> <code>ndarray</code> <p>Vetor de tempo da resposta ao impulso</p> required <code>impulse_response</code> <code>ndarray</code> <p>Amostras da resposta ao impulso</p> required <code>t_unit</code> <code>str</code> <p>Unidade de tempo no eixo X (\"ms\" ou \"s\"). Default \u00e9 \"ms\"</p> <code>'ms'</code> Exemplos <ul> <li>Resposta ao Impulso RRC: </li> <li>Resposta ao Impulso Filtro Passa baixa: </li> <li>Resposta ao Impulso RRC Invertido: </li> </ul>"},{"location":"api/plots/#plotter.TrellisPlot","title":"<code>TrellisPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Classe para plotar o diagrama de treli\u00e7a de um decodificador viterbi.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figura do plot</p> required <code>grid</code> <code>GridSpec</code> <p>GridSpec do plot</p> required <code>pos</code> <code>int</code> <p>Posi\u00e7\u00e3o do plot no GridSpec</p> required <code>trellis</code> <code>dict</code> <p>Dicion\u00e1rio do treli\u00e7a.              Formato: {estado: {0: (prox_estado, sa\u00edda), 1: (prox_estado, sa\u00edda)}}</p> required <code>num_steps</code> <code>int</code> <p>N\u00famero de passos no tempo</p> <code>5</code> <code>initial_state</code> <code>int</code> <p>Estado inicial</p> <code>0</code> Exemplos <ul> <li>Treli\u00e7a Decodificador Viterbi: </li> </ul>"},{"location":"api/plots/#plotter.SampledSignalPlot","title":"<code>SampledSignalPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Classe para plotar um sinal no dom\u00ednio do tempo com seus pontos de amostragem.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figura do plot</p> required <code>grid</code> <code>GridSpec</code> <p>GridSpec do plot</p> required <code>pos</code> <code>int ou tuple</code> <p>Posi\u00e7\u00e3o no GridSpec</p> required <code>t_signal</code> <code>ndarray</code> <p>Vetor de tempo do sinal filtrado</p> required <code>signal</code> <code>ndarray</code> <p>Sinal filtrado</p> required <code>t_samples</code> <code>ndarray</code> <p>Instantes de amostragem</p> required <code>samples</code> <code>ndarray</code> <p>Amostras correspondentes</p> required Exemplos <ul> <li>Sinal Amostrado: </li> </ul>"},{"location":"api/plots/#plotter.PhasePlot","title":"<code>PhasePlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Classe para plotar a fase dos sinais IQ no dom\u00ednio do tempo.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figura do plot</p> required <code>grid</code> <code>GridSpec</code> <p>GridSpec do plot</p> required <code>pos</code> <code>int</code> <p>Posi\u00e7\u00e3o do plot</p> required <code>t</code> <code>ndarray</code> <p>Vetor de tempo</p> required <code>signals</code> <code>Union[ndarray, List[ndarray]]</code> <p>Sinais IQ (I e Q)</p> required <code>labels</code> <code>(List[str], opcional)</code> <p>R\u00f3tulos para os sinais. Se n\u00e3o fornecido, ser\u00e1 gerado automaticamente.</p> required"},{"location":"api/plots/#plotter.BersnrPlot","title":"<code>BersnrPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Classe para plotar a curva \\( E_b/N_0 \\) versus \\( BER \\) (Taxa de Erro de Bit).</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figura do plot</p> required <code>grid</code> <code>GridSpec</code> <p>GridSpec do plot</p> required <code>pos</code> <code>int</code> <p>Posi\u00e7\u00e3o do plot no GridSpec</p> required <code>ebn0</code> <code>ndarray</code> <p>Vetor de valores de \\( E_b/N_0 \\) (em dB)</p> required <code>ber_values</code> <code>List[ndarray]</code> <p>Lista de vetores de valores de \\( BER \\) para diferentes condi\u00e7\u00f5es</p> required <code>labels</code> <code>Optional[List[str]]</code> <p>R\u00f3tulos para as curvas (por exemplo, diferentes condi\u00e7\u00f5es ou algoritmos)</p> required Exemplos <ul> <li>Argos e QPSK: </li> </ul>"},{"location":"api/plots/#plotter.GaussianNoisePlot","title":"<code>GaussianNoisePlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Classe para plotar a distribui\u00e7\u00e3o Gaussiana do ru\u00eddo AWGN com base na vari\u00e2ncia.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figura do plot</p> required <code>grid</code> <code>GridSpec</code> <p>GridSpec do plot</p> required <code>pos</code> <code>int</code> <p>Posi\u00e7\u00e3o do plot no GridSpec</p> required <code>variance</code> <code>float</code> <p>Vari\u00e2ncia do ru\u00eddo</p> required <code>num_points</code> <code>int</code> <p>N\u00famero de pontos para a curva da gaussiana</p> <code>1000</code>"},{"location":"api/plots/#plotter.mag2db","title":"<code>mag2db(signal)</code>","text":"<p>Converte a magnitude do sinal para escala logar\u00edtmica (dB), normalizada.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>ndarray</code> <p>Array com os dados do sinal</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array com o sinal convertido para dB</p>"},{"location":"api/plots/#plotter.create_figure","title":"<code>create_figure(rows, cols, figsize=(16, 9))</code>","text":"<p>Cria uma figura com GridSpec e retorna (fig, grid).</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>N\u00famero de linhas do GridSpec</p> required <code>cols</code> <code>int</code> <p>N\u00famero de colunas do GridSpec</p> required <code>figsize</code> <code>Tuple[int, int]</code> <p>Tamanho da figura</p> <code>(16, 9)</code> <p>Returns:</p> Type Description <code>Tuple[Figure, GridSpec]</code> <p>Tuple[plt.Figure, gridspec.GridSpec]: Tupla com a figura e o GridSpec</p>"},{"location":"api/plots/#plotter.save_figure","title":"<code>save_figure(fig, filename, out_dir='../out')</code>","text":"<p>Salva a figura em / a partir do diret\u00f3rio onde est\u00e1 este script. <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figura a ser salva</p> required <code>filename</code> <code>str</code> <p>Nome do arquivo de sa\u00edda</p> required <code>out_dir</code> <code>str</code> <p>Diret\u00f3rio de sa\u00edda</p> <code>'../out'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se o diret\u00f3rio de sa\u00edda for inv\u00e1lido</p>"},{"location":"api/preamble/","title":"Pre\u00e2mbulo","text":""},{"location":"api/preamble/#preamble.Preamble.__init__","title":"<code>__init__(preamble_hex='2BEEEEBF')</code>","text":"<p>Inicializa uma inst\u00e2ncia de palavra de sincronismo, \\(S = 2BEEEEBF_{16}\\) no padr\u00e3o ARGOS-3. A palavra de sincronismo composta por 30 bits, \\(S = [S_0, S_1, S_2, \\dots, S_{29}]\\) que s\u00e3o intercalados para formar os vetores \\(S_I\\) e \\(S_Q\\) de cada canal, conforme apresentado abaixo.</p> \\[ \\begin{align} S_I &amp;= [S_0,\\, S_2,\\, S_4,\\, \\dots,\\, S_{28}] &amp;&amp; \\mapsto \\quad S_I = [1111,\\, 1111,\\, 1111,\\, 111] \\\\ S_Q &amp;= [S_1,\\, S_3,\\, S_5,\\, \\dots,\\, S_{29}] &amp;&amp; \\mapsto \\quad S_Q = [0011,\\, 0101,\\, 0100,\\, 111] \\end{align} \\] Sendo <ul> <li>\\(S\\): Palavra de sincronismo original.</li> <li>\\(S_I\\) e \\(S_Q\\): Vetores de saida correspondentes aos canais I e Q, respectivamente.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>preamble_hex</code> <code>(str, opcional)</code> <p>Hexadecimal da palavra de sincronismo.</p> <code>'2BEEEEBF'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se a palavra de sincronismo \\(S\\) tiver comprimento diferente de 8 caracteres. </p> <code>ValueError</code> <p>Se o hexadecimal n\u00e3o for v\u00e1lido ou n\u00e3o puder ser convertido.</p> Exemplo <p></p> Refer\u00eancia: AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.6)"},{"location":"api/preamble/#preamble.Preamble.generate_preamble","title":"<code>generate_preamble()</code>","text":"<p>Gera os vetores \\(S_I\\) e \\(S_Q\\) da palavra de sincronismo, com base no vetor \\(S\\) passado no construtor.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>(ndarray, ndarray)</code> <p>Vetores \\(S_I\\) e \\(S_Q\\).</p>"},{"location":"api/receiver/","title":"Receptor","text":""},{"location":"api/receiver/#receiver.Receiver.__init__","title":"<code>__init__(fs=128000, Rb=400, output_print=True, output_plot=True)</code>","text":"<p>Classe que encapsula todo o processo de recep\u00e7\u00e3o, desde o recebimento do sinal com ru\u00eddo (sinal do canal), at\u00e9 a recupera\u00e7\u00e3o do vetor de bit.  O processo de demodula\u00e7\u00e3o \u00e9 representado pelo diagrama de blocos abaixo.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>fs</code> <code>int</code> <p>Frequ\u00eancia de amostragem em Hz. Default \u00e9 128000 Hz.</p> <code>128000</code> <code>Rb</code> <code>int</code> <p>Taxa de bits em bps. Default \u00e9 400 bps.</p> <code>400</code> <code>output_print</code> <code>bool</code> <p>Se True, imprime os vetores intermedi\u00e1rios no console. Default \u00e9 True.</p> <code>True</code> <code>output_plot</code> <code>bool</code> <p>Se True, gera e salva os gr\u00e1ficos dos processos intermedi\u00e1rios. Default \u00e9 True.</p> <code>True</code>"},{"location":"api/receiver/#receiver.Receiver.demodulate","title":"<code>demodulate(s)</code>","text":"<p>Demodula o sinal \\(s'(t)\\) com ru\u00eddo recebido, recuperando os sinais \\(x'_{I}(t)\\) e \\(y'_{Q}(t)\\).</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>ndarray</code> <p>Sinal \\(s'(t)\\) a ser demodulado.</p> required <p>Returns:</p> Name Type Description <code>xI_prime</code> <code>ndarray</code> <p>Sinal \\(x'_{I}(t)\\) demodulado.</p> <code>yQ_prime</code> <code>ndarray</code> <p>Sinal \\(y'_{Q}(t)\\) demodulado.</p> Exemplo <ul> <li>Tempo: </li> <li>Frequ\u00eancia: </li> </ul>"},{"location":"api/receiver/#receiver.Receiver.lowpassfilter","title":"<code>lowpassfilter(cut_off, xI_prime, yQ_prime, t)</code>","text":"<p>Aplica o filtro passa-baixa com resposta ao impuslo \\(h(t)\\) aos sinais \\(x'_{I}(t)\\) e \\(y'_{Q}(t)\\).</p> <p>Parameters:</p> Name Type Description Default <code>cut_off</code> <code>float</code> <p>Frequ\u00eancia de corte do filtro.</p> required <code>xI_prime</code> <code>ndarray</code> <p>Sinal \\(x'_{I}(t)\\) a ser filtrado.</p> required <code>yQ_prime</code> <code>ndarray</code> <p>Sinal \\(y'_{Q}(t)\\) a ser filtrado.</p> required <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> required <p>Returns:</p> Name Type Description <code>dI_prime</code> <code>ndarray</code> <p>Sinal \\(d'_{I}(t)\\) filtrado.</p> <code>dQ_prime</code> <code>ndarray</code> <p>Sinal \\(d'_{Q}(t)\\) filtrado.</p> Exemplo <ul> <li>Tempo: </li> </ul>"},{"location":"api/receiver/#receiver.Receiver.matchedfilter","title":"<code>matchedfilter(dI_prime, dQ_prime, t)</code>","text":"<p>Aplica o filtro casado com resposta ao impuslo \\(h(t)\\) aos sinais \\(d'_{I}(t)\\) e \\(d'_{Q}(t)\\).</p> <p>Parameters:</p> Name Type Description Default <code>dI_prime</code> <code>ndarray</code> <p>Sinal \\(d'_{I}(t)\\) a ser filtrado.</p> required <code>dQ_prime</code> <code>ndarray</code> <p>Sinal \\(d'_{Q}(t)\\) a ser filtrado.</p> required <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> required <p>Returns:</p> Name Type Description <code>It_prime</code> <code>ndarray</code> <p>Sinal \\(I'(t)\\) filtrado.</p> <code>Qt_prime</code> <code>ndarray</code> <p>Sinal \\(Q'(t)\\) filtrado.</p> Exemplo <ul> <li>Tempo: </li> </ul>"},{"location":"api/receiver/#receiver.Receiver.sampler","title":"<code>sampler(It_prime, Qt_prime, t)</code>","text":"<p>Realiza a decis\u00e3o (amostragem e quantiza\u00e7\u00e3o) dos sinais \\(I'(t)\\) e \\(Q'(t)\\).</p> <p>Parameters:</p> Name Type Description Default <code>It_prime</code> <code>ndarray</code> <p>Sinal \\(I'(t)\\) a ser amostrado e quantizado.</p> required <code>Qt_prime</code> <code>ndarray</code> <p>Sinal \\(Q'(t)\\) a ser amostrado e quantizado.</p> required <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> required <p>Returns:</p> Name Type Description <code>Xnrz_prime</code> <code>ndarray</code> <p>Sinal \\(X'_{NRZ}[n]\\) amostrado e quantizado.</p> <code>Yman_prime</code> <code>ndarray</code> <p>Sinal \\(Y'_{MAN}[n]\\) amostrado e quantizado.</p> Exemplo <ul> <li>Tempo: </li> </ul>"},{"location":"api/receiver/#receiver.Receiver.decode","title":"<code>decode(Xnrz_prime, Yman_prime)</code>","text":"<p>Decodifica os sinais quantizados \\(X'_{NRZ}[n]\\) e \\(Y'_{MAN}[n]\\).</p> <p>Parameters:</p> Name Type Description Default <code>Xnrz_prime</code> <code>ndarray</code> <p>Sinal \\(X'_{NRZ}[n]\\) quantizado.</p> required <code>Yman_prime</code> <code>ndarray</code> <p>Sinal \\(Y'_{MAN}[n]\\) quantizado.</p> required <p>Returns:</p> Name Type Description <code>Xn_prime</code> <code>ndarray</code> <p>Sinal \\(X'n\\) decodificado.</p> <code>Yn_prime</code> <code>ndarray</code> <p>Sinal \\(Y'n\\) decodificado.</p> Exemplo <ul> <li>Tempo: </li> </ul>"},{"location":"api/receiver/#receiver.Receiver.remove_preamble","title":"<code>remove_preamble(Xn_prime, Yn_prime)</code>","text":"<p>Remove os 15 primeiros bits de cada sinal.</p> <p>Parameters:</p> Name Type Description Default <code>Xn_prime</code> <code>ndarray</code> <p>Sinal \\(X'n\\) decodificado.</p> required <code>Yn_prime</code> <code>ndarray</code> <p>Sinal \\(Y'n\\) decodificado.</p> required <p>Returns:</p> Name Type Description <code>Xn_prime</code> <code>ndarray</code> <p>Sinal \\(X'n\\) sem pre\u00e2mbulo.</p> <code>Yn_prime</code> <code>ndarray</code> <p>Sinal \\(Y'n\\) sem pre\u00e2mbulo.</p> Exemplo <ul> <li>Tempo: </li> </ul>"},{"location":"api/receiver/#receiver.Receiver.descrambler","title":"<code>descrambler(Xn_prime, Yn_prime)</code>","text":"<p>Desembaralha os vetores de bits dos canais I e Q.</p> <p>Parameters:</p> Name Type Description Default <code>Xn_prime</code> <code>ndarray</code> <p>Vetor de bits \\(X'n\\) embaralhados.</p> required <code>Yn_prime</code> <code>ndarray</code> <p>Vetor de bits \\(Y'n\\) embaralhados.</p> required <p>Returns:</p> Name Type Description <code>vt0</code> <code>ndarray</code> <p>Vetor de bits \\(v_{t}^{0'}\\) desembaralhado.</p> <code>vt1</code> <code>ndarray</code> <p>Vetor de bits \\(v_{t}^{1'}\\) desembaralhado.</p> Exemplo <ul> <li>Tempo: </li> </ul>"},{"location":"api/receiver/#receiver.Receiver.conv_decoder","title":"<code>conv_decoder(vt0, vt1)</code>","text":"<p>Decodifica os vetores de bits dos canais I e Q.</p> <p>Parameters:</p> Name Type Description Default <code>vt0</code> <code>ndarray</code> <p>Vetor de bits \\(v_{t}^{0'}\\) desembaralhado.</p> required <code>vt1</code> <code>ndarray</code> <p>Vetor de bits \\(v_{t}^{1'}\\) desembaralhado.</p> required <p>Returns:</p> Name Type Description <code>ut</code> <code>ndarray</code> <p>Vetor de bits \\(u_{t}'\\) decodificado.</p> Exemplo <ul> <li>Tempo: </li> </ul>"},{"location":"api/receiver/#receiver.Receiver.run","title":"<code>run(s, t, fc=4000)</code>","text":"<p>Executa o processo de recep\u00e7\u00e3o, retornando o resultado da recep\u00e7\u00e3o.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>ndarray</code> <p>Sinal \\(s(t)\\) recebido.</p> required <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> required <code>fc</code> <code>float</code> <p>Frequ\u00eancia de portadora.</p> <code>4000</code> <p>Returns:</p> Name Type Description <code>ut</code> <code>ndarray</code> <p>Vetor de bits \\(u_{t}'\\) decodificado.</p> Exemplo <ul> <li>Tempo: </li> </ul>"},{"location":"api/sampler/","title":"Decisor","text":""},{"location":"api/sampler/#sampler.Sampler.__init__","title":"<code>__init__(fs=128000, Rb=400, t=None, delay=0)</code>","text":"<p>Implementa\u00e7\u00e3o de decisor (amostragem e quantiza\u00e7\u00e3o) para o receptor.</p> <p>Parameters:</p> Name Type Description Default <code>fs</code> <code>int</code> <p>Frequ\u00eancia de amostragem.</p> <code>128000</code> <code>delay</code> <code>int</code> <p>Delay de amostragem.</p> <code>0</code> <code>Rb</code> <code>int</code> <p>Taxa de bits.</p> <code>400</code> <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> <code>None</code> Exemplo <p></p>"},{"location":"api/sampler/#sampler.Sampler.calc_indexes","title":"<code>calc_indexes(t)</code>","text":"<p>Calcula os \u00edndices de amostragem \\(I[n]\\) com base no vetor de tempo \\(t\\). O vetor de \u00edndices de amostragem \\(I[n]\\) \u00e9 dado pela express\u00e3o abaixo. </p> \\[ \\begin{align} I[n] = \\tau + n \\cdot \\left( \\frac{f_s}{R_b}\\right) \\text{ , onde: } \\quad I[n] &lt; \\text{len}(t) \\end{align} \\] Sendo <ul> <li>\\(\\tau\\): Delay inicial de amostragem.</li> <li>\\(f_s\\): Frequ\u00eancia de amostragem.</li> <li>\\(R_b\\): Taxa de bits.</li> <li>\\(n\\): \u00cdndice da amostra.</li> <li>\\(\\text{len}(t)\\): Comprimento do vetor de tempo.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> required <p>Returns:</p> Name Type Description <code>indexes</code> <code>ndarray</code> <p>Vetor de \u00edndices de amostragem \\(I[n]\\).</p>"},{"location":"api/sampler/#sampler.Sampler.sample","title":"<code>sample(signal)</code>","text":"<p>Amostra o sinal \\(s(t)\\) com base nos \u00edndices de amostragem \\(I[n]\\).</p> \\[     s(t) \\rightarrow  s([I[n]) \\rightarrow s[n] \\] Sendo <ul> <li>\\(s(t)\\): Sinal de entrada \\(s(t)\\).</li> <li>\\(s[n]\\) Sinal amostrado \\(s[n]\\).</li> <li>\\(I[n]\\) \u00cdndices de amostragem \\(I[n]\\).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>ndarray</code> <p>Sinal de entrada \\(s(t)\\) a ser amostrado.</p> required <p>Returns:</p> Name Type Description <code>sampled_signal</code> <code>ndarray</code> <p>Sinal amostrado \\(s[n]\\).</p>"},{"location":"api/sampler/#sampler.Sampler.quantize","title":"<code>quantize(signal)</code>","text":"<p>Quantiza o sinal \\(s[n]\\) em valores discretos. O processo de quantiza\u00e7\u00e3o \u00e9 dado pela express\u00e3o abaixo.</p> \\[ \\begin{align} s'[n] = \\begin{cases}     +1 &amp; \\text{se } s[n] \\geq 0 \\\\     -1 &amp; \\text{se } s[n] &lt; 0 \\end{cases} \\end{align} \\] Sendo <ul> <li>\\(s[n]\\) Simbolos amostrados \\(s[n]\\).</li> <li>\\(s'[n]\\) S\u00edmbolos quantizados \\(s'[n]\\).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>ndarray</code> <p>Sinal de entrada \\(s[n]\\).</p> required <p>Returns:</p> Name Type Description <code>symbols</code> <code>ndarray</code> <p>S\u00edmbolos quantizados \\(s'[n]\\).</p>"},{"location":"api/scrambler/","title":"Embaralhador","text":""},{"location":"api/scrambler/#scrambler.Scrambler.__init__","title":"<code>__init__()</code>","text":"<p>Inicializa o embaralhador no padr\u00e3o ARGOS-3.</p> Exemplo <p></p> Refer\u00eancia: AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.5)"},{"location":"api/scrambler/#scrambler.Scrambler.scramble","title":"<code>scramble(vt0, vt1)</code>","text":"<p>Embaralha os vetores \\(v_t^{(0)}\\) e \\(v_t^{(1)}\\), retornando os vetores \\(X_n\\) e \\(Y_n\\) embaralhados. O processo de embaralhamento \u00e9 dado pela express\u00e3o abaixo.</p> \\[\\begin{equation}     X_n = \\begin{cases}     A, &amp; \\text{se } n = 0 \\pmod{3} \\\\     B, &amp; \\text{se } n = 1 \\pmod{3} \\\\     C, &amp; \\text{se } n = 2 \\pmod{3}     \\end{cases} \\quad     Y_n = \\begin{cases}     A, &amp; \\text{se } n = 0 \\pmod{3} \\\\     B, &amp; \\text{se } n = 1 \\pmod{3} \\\\     C, &amp; \\text{se } n = 2 \\pmod{3}     \\end{cases} \\end{equation}\\] Sendo <ul> <li>\\(X_n\\) e \\(Y_n\\): Vetores de sa\u00edda embaralhados.</li> <li>\\(A\\), \\(B\\) e \\(C\\): Combina\u00e7\u00e3o de bits dos vetores de entrada \\(v_t^{(0)}\\) e \\(v_t^{(1)}\\).</li> <li>\\(n\\): Indice do bit a ser embaralhado.</li> </ul> <p>O processo de embaralhamento \u00e9 ilustrado pelo diagrama de blocos abaixo. </p> <p></p> <p>Parameters:</p> Name Type Description Default <code>vt0</code> <code>ndarray</code> <p>Vetor de entrada \\(v_t^{(0)}\\).</p> required <code>vt1</code> <code>ndarray</code> <p>Vetor de entrada \\(v_t^{(1)}\\).</p> required <p>Returns:</p> Name Type Description <code>X_scrambled</code> <code>ndarray</code> <p>Vetor \\(X_n\\) embaralhado.</p> <code>Y_scrambled</code> <code>ndarray</code> <p>Vetor \\(Y_n\\) embaralhado.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>Se os vetores X e Y n\u00e3o tiverem o mesmo comprimento.</p>"},{"location":"api/scrambler/#scrambler.Scrambler.descramble","title":"<code>descramble(X_prime, Y_prime)</code>","text":"<p>Desembaralha os vetores \\(X'_n\\) e \\(Y'_n\\) embaralhados, retornando os vetores \\(v_t^{(0)'}\\) e \\(v_t^{(1)'}\\) restaurados. O processo de desembaralhamento \u00e9 dado pela express\u00e3o abaixo.</p> \\[\\begin{equation}     v_t^{(0)'} = \\begin{cases}     A, &amp; \\text{se } n = 0 \\pmod{3} \\\\     B, &amp; \\text{se } n = 1 \\pmod{3} \\\\     C, &amp; \\text{se } n = 2 \\pmod{3}     \\end{cases}, \\quad     v_t^{(1)'} = \\begin{cases}     A, &amp; \\text{se } n = 0 \\pmod{3} \\\\     B, &amp; \\text{se } n = 1 \\pmod{3} \\\\     C, &amp; \\text{se } n = 2 \\pmod{3}     \\end{cases} \\text{ .}     \\label{eq:desembaralhador_Y} \\end{equation}\\] Sendo <ul> <li>\\(v_t^{(0)'}\\) e \\(v_t^{(1)'}\\): Vetores de saida desembaralhados.</li> <li>\\(A\\), \\(B\\) e \\(C\\): Combina\u00e7\u00e3o de bits dos vetores de entrada \\(X'_n\\) e \\(Y'_n\\) embaralhados.</li> <li>\\(n\\): Indice do bit a ser embaralhado.</li> </ul> <p>O processo de desembaralhamento \u00e9 ilustrado pelo diagrama de blocos abaixo.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>X_prime</code> <code>ndarray</code> <p>Vetor \\(X'_{n}\\) embaralhado.</p> required <code>Y_prime</code> <code>ndarray</code> <p>Vetor \\(Y'_{n}\\) embaralhado.</p> required <p>Returns:</p> Name Type Description <code>vt0_prime</code> <code>ndarray</code> <p>Vetor \\(v_t^{(0)}\\) restaurado.</p> <code>vt1_prime</code> <code>ndarray</code> <p>Vetor \\(v_t^{(1)}\\) restaurado.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>Se os vetores X e Y n\u00e3o tiverem o mesmo comprimento.</p>"},{"location":"api/transmitter/","title":"Transmissor","text":""},{"location":"api/transmitter/#transmitter.Transmitter.__init__","title":"<code>__init__(datagram, fc=4000, fs=128000, Rb=400, output_print=True, output_plot=True)</code>","text":"<p>Classe que encapsula todo o processo de transmiss\u00e3o, desde a prepara\u00e7\u00e3o do datagrama at\u00e9 a modula\u00e7\u00e3o do sinal. O processo de transmiss\u00e3o pode ser representado pelo diagrama de blocos abaixo.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>datagram</code> <code>Datagram</code> <p>Inst\u00e2ncia do datagrama a ser transmitido.</p> required <code>fc</code> <code>float</code> <p>Frequ\u00eancia da portadora em Hz. Default \u00e9 4000 Hz</p> <code>4000</code> <code>fs</code> <code>float</code> <p>Frequ\u00eancia de amostragem em Hz. Default \u00e9 128000 Hz.</p> <code>128000</code> <code>Rb</code> <code>float</code> <p>Taxa de bits em bps. Default \u00e9 400 b</p> <code>400</code> <code>output_print</code> <code>bool</code> <p>Se True, imprime os vetores intermedi\u00e1rios no console. Default \u00e9 True.</p> <code>True</code> <code>output_plot</code> <code>bool</code> <p>Se True, gera e salva os gr\u00e1ficos dos processos intermedi\u00e1rios.</p> <code>True</code>"},{"location":"api/transmitter/#transmitter.Transmitter.prepare_datagram","title":"<code>prepare_datagram()</code>","text":"<p>Prepara o datagrama para transmiss\u00e3o, retornando o vetor de bits \\(u_t\\).</p> <p>Returns:</p> Name Type Description <code>ut</code> <code>ndarray</code> <p>Vetor de bits do datagrama.</p> Exemplo <p></p>"},{"location":"api/transmitter/#transmitter.Transmitter.encode_convolutional","title":"<code>encode_convolutional(ut)</code>","text":"<p>Codifica o vetor de bits \\(u_t\\) usando codifica\u00e7\u00e3o convolucional.</p> <p>Parameters:</p> Name Type Description Default <code>ut</code> <code>ndarray</code> <p>Vetor de bits a ser codificado.</p> required <p>Returns:</p> Name Type Description <code>vt0</code> <code>ndarray</code> <p>Sa\u00edda do canal I.</p> <code>vt1</code> <code>ndarray</code> <p>Sa\u00edda do canal Q.</p> Exemplo <p></p>"},{"location":"api/transmitter/#transmitter.Transmitter.scramble","title":"<code>scramble(vt0, vt1)</code>","text":"<p>Embaralha os vetores de bits dos canais I e Q.</p> <p>Parameters:</p> Name Type Description Default <code>vt0</code> <code>ndarray</code> <p>Vetor de bits do canal I.</p> required <code>vt1</code> <code>ndarray</code> <p>Vetor de bits do canal Q.</p> required <p>Returns:</p> Name Type Description <code>Xn</code> <code>ndarray</code> <p>Vetor embaralhado do canal I.</p> <code>Yn</code> <code>ndarray</code> <p>Vetor embaralhado do canal Q.</p> Exemplo <p></p>"},{"location":"api/transmitter/#transmitter.Transmitter.generate_preamble","title":"<code>generate_preamble()</code>","text":"<p>Gera os vetores de pre\u00e2mbulo \\(S_I\\) e \\(S_Q\\).</p> <p>Returns:</p> Name Type Description <code>sI</code> <code>ndarray</code> <p>Vetor do pre\u00e2mbulo do canal I.</p> <code>sQ</code> <code>ndarray</code> <p>Vetor do pre\u00e2mbulo do canal Q.</p> Exemplo <p></p>"},{"location":"api/transmitter/#transmitter.Transmitter.multiplex","title":"<code>multiplex(sI, sQ, X, Y)</code>","text":"<p>Multiplexa os vetores de pre\u00e2mbulo e dados dos canais I e Q.</p> <p>Parameters:</p> Name Type Description Default <code>sI</code> <code>ndarray</code> <p>Vetor do pre\u00e2mbulo do canal I.</p> required <code>sQ</code> <code>ndarray</code> <p>Vetor do pre\u00e2mbulo do canal Q.</p> required <code>X</code> <code>ndarray</code> <p>Vetor de dados do canal I.</p> required <code>Y</code> <code>ndarray</code> <p>Vetor de dados do canal Q.</p> required <p>Returns:</p> Name Type Description <code>Xn</code> <code>ndarray</code> <p>Vetor multiplexado do canal I.</p> <code>Yn</code> <code>ndarray</code> <p>Vetor multiplexado do canal Q.</p> Exemplo <p></p>"},{"location":"api/transmitter/#transmitter.Transmitter.encode_channels","title":"<code>encode_channels(Xn, Yn)</code>","text":"<p>Codifica os vetores dos canais I e Q usando NRZ e Manchester, respectivamente.</p> <p>Parameters:</p> Name Type Description Default <code>Xn</code> <code>ndarray</code> <p>Vetor do canal I a ser codificado.</p> required <code>Yn</code> <code>ndarray</code> <p>Vetor do canal Q a ser codificado.</p> required <p>Returns:</p> Name Type Description <code>Xnrz</code> <code>ndarray</code> <p>Vetor codificado do canal I (NRZ).</p> <code>Yman</code> <code>ndarray</code> <p>Vetor codificado do canal Q (Manchester).</p> Exemplo <p></p>"},{"location":"api/transmitter/#transmitter.Transmitter.format_signals","title":"<code>format_signals(Xnrz, Yman)</code>","text":"<p>Formata os vetores dos canais I e Q usando filtro RRC.</p> <p>Parameters:</p> Name Type Description Default <code>Xnrz</code> <code>ndarray</code> <p>Vetor do canal I a ser formatado.</p> required <code>Yman</code> <code>ndarray</code> <p>Vetor do canal Q a ser formatado.</p> required <p>Returns:</p> Name Type Description <code>dI</code> <code>ndarray</code> <p>Vetor formatado do canal I.</p> <code>dQ</code> <code>ndarray</code> <p>Vetor formatado do canal Q.</p> Exemplo <p></p>"},{"location":"api/transmitter/#transmitter.Transmitter.modulate","title":"<code>modulate(dI, dQ)</code>","text":"<p>Modula os vetores formatados dos canais I e Q usando modula\u00e7\u00e3o QPSK.</p> <p>Parameters:</p> Name Type Description Default <code>dI</code> <code>ndarray</code> <p>Vetor formatado do canal I.</p> required <code>dQ</code> <code>ndarray</code> <p>Vetor formatado do canal Q.</p> required <p>Returns:</p> Name Type Description <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> <code>s</code> <code>ndarray</code> <p>Sinal modulado.</p> Exemplo <ul> <li>Tempo: </li> <li>Frequ\u00eancia: </li> <li>Constela\u00e7\u00e3o: </li> </ul>"},{"location":"api/transmitter/#transmitter.Transmitter.run","title":"<code>run()</code>","text":"<p>Executa o processo de transmiss\u00e3o, retornando o resultado da transmiss\u00e3o.</p> <p>Returns:</p> Name Type Description <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> <code>s</code> <code>ndarray</code> <p>Sinal modulado \\(s(t)\\).</p>"},{"location":"api/viterbi/","title":"Convolutional Decoder (Viterbi)","text":""},{"location":"api/viterbi/#convolutional.DecoderViterbi.__init__","title":"<code>__init__(G=np.array([[121, 91]]))</code>","text":"<p>Inicializa o decodificador convolucional (algoritmo Viterbi), com base em uma tupla de polin\u00f4mios geradores \\(G\\) que determinam a estrutura do decodificador.</p> \\[ \\begin{equation}     \\begin{split}         G_0 &amp;= 121_{10} \\quad \\mapsto \\quad G_0 = [1, 1, 1, 0, 0, 1, 1] \\\\         G_1 &amp;= 91_{10} \\quad \\mapsto \\quad G_1 = [1, 1, 0, 1, 1, 0, 1]     \\end{split} \\end{equation} \\] <p>Parameters:</p> Name Type Description Default <code>G</code> <code>ndarray</code> <p>Tupla de polin\u00f4mios geradores \\(G\\).</p> <code>array([[121, 91]])</code> Exemplo <p></p> Refer\u00eancia: <p>https://rwnobrega.page/apontamentos/codigos-convolucionais/</p> <p>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.4)</p>"},{"location":"api/viterbi/#convolutional.DecoderViterbi.build_trellis","title":"<code>build_trellis()</code>","text":"<p>Constroi a trelica do decodificador Viterbi.</p> <p>Returns:</p> Name Type Description <code>trellis</code> <code>dict</code> <p>Trelica do decodificador Viterbi.</p>"},{"location":"api/viterbi/#convolutional.DecoderViterbi.decode","title":"<code>decode(vt0, vt1)</code>","text":"<p>Decodifica os bits de entrada \\(v_t^{(0)}\\) e \\(v_t^{(1)}\\), retornando os bits decodificados \\(u_t\\).</p> <p>Parameters:</p> Name Type Description Default <code>vt0</code> <code>ndarray</code> <p>Bits de entrada do canal I.</p> required <code>vt1</code> <code>ndarray</code> <p>Bits de entrada do canal Q.</p> required <p>Returns:</p> Name Type Description <code>ut_hat</code> <code>ndarray</code> <p>Bits decodificados.</p>"}]}