{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Simulador ARGOS-3","text":"<p>O Simulador ARGOS-3 \u00e9 uma ferramenta computacional desenvolvida em Python com o objetivo de estudar, analisar e validar a comunica\u00e7\u00e3o via sat\u00e9lite no padr\u00e3o ARGOS-3.  </p> <p>O padr\u00e3o ARGOS-3 \u00e9 empregado pelo Sistema Brasileiro de Coleta de Dados Ambientais (SBCDA), sob responsabilidade do Instituto Nacional de Pesquisas Espaciais (INPE), para o recebimento de informa\u00e7\u00f5es provenientes de milhares de Plataformas de Coleta de Dados (PCDs) distribu\u00eddas em todo o territ\u00f3rio nacional. As transmiss\u00f5es realizadas pelas PCDs s\u00e3o retransmitidas por sat\u00e9lites como o SCD-1, SCD-2 e pela s\u00e9rie CBERS, que orbitam a aproximadamente 750 km de altitude.  </p> <p> </p> <p>O simulador foi projetado para reproduzir os principais aspectos e desafios da comunica\u00e7\u00e3o com sat\u00e9lites, incorporando conceitos fundamentais, tais como:</p> <ul> <li>T\u00e9cnicas de modula\u00e7\u00e3o, codifica\u00e7\u00e3o e sincroniza\u00e7\u00e3o de sinais  </li> <li>Modelagem de efeitos de canal, incluindo ru\u00eddo, interfer\u00eancias e atenua\u00e7\u00e3o</li> </ul> <p>Este reposit\u00f3rio consolida a documenta\u00e7\u00e3o, os testes e os resultados de simula\u00e7\u00e3o do ARGOS-3, constituindo uma base de refer\u00eancia para pesquisas acad\u00eamicas, iniciativas de desenvolvimento tecnol\u00f3gico e aplica\u00e7\u00f5es em monitoramento ambiental no Brasil.</p>"},{"location":"api/bersnr/","title":"BER vs SNR","text":"<p>Simula a transmiss\u00e3o e recep\u00e7\u00e3o de um datagrama ARGOS-III, para um dado SNR.</p> <p>Parameters:</p> Name Type Description Default <code>snr_db</code> <code>float</code> <p>Rela\u00e7\u00e3o sinal-ru\u00eddo em decib\u00e9is.</p> required <code>numblocks</code> <code>int</code> <p>N\u00famero de blocos a serem transmitidos.</p> <code>8</code> <code>fs</code> <code>int</code> <p>Frequ\u00eancia de amostragem.</p> <code>128000</code> <code>Rb</code> <code>int</code> <p>Taxa de bits. </p> <code>400</code> <p>Returns:</p> Name Type Description <code>ber</code> <code>float</code> <p>A taxa de erro de bit (BER) simulada.</p> <p>Executa a simula\u00e7\u00e3o completa de BER vs SNR. Retorna a tupla BER vs SNR.</p> <p>Parameters:</p> Name Type Description Default <code>SNR_values</code> <code>ndarray</code> <p>Valores de SNR a serem simulados.</p> <code>arange(-30, 31, 1)</code> <code>repetitions</code> <code>int</code> <p>N\u00famero de repeti\u00e7\u00f5es para cada valor de SNR.</p> <code>10</code> <code>numblocks</code> <code>int</code> <p>N\u00famero de blocos a serem transmitidos.</p> <code>1</code> <code>num_workers</code> <code>int</code> <p>N\u00famero de trabalhadores para a execu\u00e7\u00e3o paralela.</p> <code>16</code> <p>Returns:</p> Name Type Description <code>list</code> <p>Lista de tuplas (SNR, BER_m\u00e9dio).</p> <p>Salva os resultados de simula\u00e7\u00e3o em um arquivo .txt </p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>list</code> <p>Lista de tuplas (SNR, BER) a serem salvas.</p> required <code>filename</code> <code>str</code> <p>Caminho do arquivo de sa\u00edda.</p> <code>'../out/snr_vs_ber.txt'</code> <p>L\u00ea os resultados do arquivo TXT (relativo ao diret\u00f3rio do script) e gera o gr\u00e1fico BER vs SNR em PDF.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Caminho do arquivo de entrada.</p> <code>'../out/snr_vs_ber.txt'</code> <code>out_pdf</code> <code>str</code> <p>Caminho do arquivo PDF de sa\u00edda. </p> <code>'../out/snr_vs_ber.pdf'</code> <p></p>"},{"location":"api/convolutional/","title":"Convolutional Encoder","text":""},{"location":"api/convolutional/#convolutional.EncoderConvolutional.__init__","title":"<code>__init__(G=np.array([[121, 91]]))</code>","text":"<p>Inicializa o codificador convolucional com matriz de geradores.</p> Refer\u00eancia <ul> <li>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.4)</li> <li>CCSDS 131.1-G-2</li> </ul> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>ndarray</code> <p>Matriz de polin\u00f4mios geradores em formato bin\u00e1rio.</p> <code>array([[121, 91]])</code> Nota <ul> <li>O polin\u00f4mio gerador \\(G_0\\) \u00e9 representado por <code>G[0][0]</code> e \\(G_1\\) por <code>G[0][1]</code>.</li> <li>\\(G_0\\) \u00e9 definido como \\(1111001_{2}\\) ou \\(121_{10}\\)</li> <li>\\(G_1\\) \u00e9 definido como \\(1011011_{2}\\) ou \\(91_{10}\\)</li> </ul> <p>Com base nos polin\u00f4mios geradores, o codificador convolucional pode ser representado pelo diagrama de blocos abaixo.</p> <p></p>"},{"location":"api/convolutional/#convolutional.EncoderConvolutional.calc_taps","title":"<code>calc_taps(poly)</code>","text":"<p>Calcula os \u00edndices (\"taps\") dos bits ativos (ou seja, bits \\('1'\\)) no polin\u00f4mio gerador.</p> <p>Parameters:</p> Name Type Description Default <code>poly</code> <code>int</code> <p>Polin\u00f4mio em formato bin\u00e1rio. </p> required <p>Returns:</p> Name Type Description <code>taps</code> <code>int</code> <p>Lista com os \u00edndices dos taps ativos.</p>"},{"location":"api/convolutional/#convolutional.EncoderConvolutional.calc_free_distance","title":"<code>calc_free_distance()</code>","text":"<p>Calcula a dist\u00e2ncia livre do c\u00f3digo convolucional, definida como a menor dist\u00e2ncia de Hamming entre quaisquer duas sequ\u00eancias de sa\u00edda distintas.</p> <p>Returns:</p> Name Type Description <code>dist</code> <code>int</code> <p>Dist\u00e2ncia livre do c\u00f3digo.</p>"},{"location":"api/convolutional/#convolutional.EncoderConvolutional.encode","title":"<code>encode(input_bits)</code>","text":"<p>Codifica uma sequ\u00eancia bin\u00e1ria de entrada \\(u_t\\) utilizando os registradores deslizantes e os taps.</p> <p>Parameters:</p> Name Type Description Default <code>input_bits</code> <code>ndarray</code> <p>Vetor de bits \\(u_t\\) de entrada a serem codificados.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>(ndarray, ndarray)</code> <p>Tupla com os dois canais de sa\u00edda \\(v_t^{(0)}\\) e \\(v_t^{(1)}\\).</p>"},{"location":"api/convolutional/#convolutional-decoder-viterbi","title":"Convolutional Decoder (Viterbi)","text":"<p>Implementa o decodificador Viterbi, no padr\u00e3o CCSDS 131.1-G-2, utilizado no PTT-A3.</p> Refer\u00eancia <p>AS3-SP-516-274-CNES (3.1.4.4)</p>"},{"location":"api/convolutional/#convolutional.DecoderViterbi.__init__","title":"<code>__init__(G=np.array([[121, 91]]))</code>","text":"<p>Inicializa o decodificador Convolucional.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>ndarray</code> <p>Matriz de polin\u00f4mios geradores.</p> <code>array([[121, 91]])</code>"},{"location":"api/convolutional/#convolutional.DecoderViterbi.build_trellis","title":"<code>build_trellis()</code>","text":"<p>Constroi a trelica do decodificador Viterbi.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Trelica do decodificador Viterbi.</p>"},{"location":"api/convolutional/#convolutional.DecoderViterbi.decode","title":"<code>decode(vt0, vt1)</code>","text":"<p>Decodifica os bits de entrada.</p> <p>Parameters:</p> Name Type Description Default <code>vt0</code> <code>ndarray</code> <p>Bits de entrada do canal I.</p> required <code>vt1</code> <code>ndarray</code> <p>Bits de entrada do canal Q.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Bits decodificados.</p>"},{"location":"api/data/","title":"Data","text":""},{"location":"api/data/#data.ExportData","title":"<code>ExportData</code>","text":"<p>Classe para armazenar o resultado da transmiss\u00e3o, incluindo o sinal modulado e o vetor de tempo.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>ndarray</code> <p>Vetor de dados.</p> required <code>filename</code> <code>str</code> <p>Nome do arquivo de sa\u00edda.</p> required <code>path</code> <code>str</code> <p>Caminho do diret\u00f3rio de sa\u00edda.</p> <code>'../out'</code>"},{"location":"api/data/#data.ExportData.save","title":"<code>save(binary=True)</code>","text":"<p>Salva os resultados em arquivo bin\u00e1rio (.npy) ou em TXT.</p>"},{"location":"api/data/#data.ImportData","title":"<code>ImportData</code>","text":"<p>Classe para carregar um vetor salvo em arquivo.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Nome do arquivo (sem extens\u00e3o).</p> required <code>path</code> <code>str</code> <p>Caminho do diret\u00f3rio de entrada.</p> <code>'../out'</code>"},{"location":"api/data/#data.ImportData.load","title":"<code>load(mode='npy', dtype=np.float64)</code>","text":"<p>Carrega o vetor salvo.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>Formato do arquivo: - \"npy\" : arquivo bin\u00e1rio com metadados do NumPy (.npy) - \"bin\" : dados crus em bin\u00e1rio (.bin) - \"txt\" : arquivo de texto (.txt)</p> <code>'npy'</code> <code>dtype</code> <code>dtype</code> <p>Tipo de dado (usado apenas para \"bin\").</p> <code>float64</code> <p>Returns:</p> Type Description <p>np.ndarray: Vetor carregado.</p>"},{"location":"api/datagram/","title":"Datagram","text":""},{"location":"api/datagram/#datagram.Datagram.__init__","title":"<code>__init__(pcdnum=None, numblocks=None, streambits=None)</code>","text":"<p>Inicializa uma inst\u00e2ncia do datagrama. </p> <p></p> Refer\u00eancia <p>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4).</p> <p>Parameters:</p> Name Type Description Default <code>pcdnum</code> <code>int</code> <p>N\u00famero identificador da PCD. Necess\u00e1rio para o modo TX.</p> <code>None</code> <code>numblocks</code> <code>int</code> <p>Quantidade de blocos de dados (1 a 8). Necess\u00e1rio para o modo TX.</p> <code>None</code> <code>streambits</code> <code>ndarray</code> <p>Sequ\u00eancia de bits do datagrama. Necess\u00e1rio para o modo RX.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se o n\u00famero de blocos n\u00e3o estiver entre 1 e 8.</p> <code>ValueError</code> <p>Se o n\u00famero PCD n\u00e3o estiver entre 0 e 1048575 \\((2^{20} - 1)\\).</p> <code>ValueError</code> <p>Se os par\u00e2metros <code>pcdnum</code> e <code>numblocks</code> ou <code>streambits</code> n\u00e3o forem fornecidos.</p>"},{"location":"api/datagram/#datagram.Datagram.generate_blocks","title":"<code>generate_blocks()</code>","text":"<p>Gera os blocos de dados simulados (valores aleat\u00f3rios), com base na quantidade especificada de blocos.</p> Refer\u00eancia <p>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.2)</p> <p>Returns:</p> Name Type Description <code>blocks</code> <code>ndarray</code> <p>Vetor de bits representando os blocos de dados.</p>"},{"location":"api/datagram/#datagram.Datagram.generate_pcdid","title":"<code>generate_pcdid()</code>","text":"<p>Gera o campo PCD ID a partir do n\u00famero PCD, incluindo um checksum de 8 bits.</p> Refer\u00eancia <p>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.2)</p> <p>Returns:</p> Name Type Description <code>pcd_id</code> <code>ndarray</code> <p>Vetor de bits contendo o PCD ID e o checksum.</p>"},{"location":"api/datagram/#datagram.Datagram.generate_msglength","title":"<code>generate_msglength()</code>","text":"<p>Gera o campo Message Length com base na quantidade de blocos e calcula o bit de paridade.</p> Refer\u00eancia <p>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.2)</p> <p>Returns:</p> Name Type Description <code>msg_length</code> <code>ndarray</code> <p>Vetor de 4 bits representando o campo Message Length.</p>"},{"location":"api/datagram/#datagram.Datagram.generate_tail","title":"<code>generate_tail()</code>","text":"<p>Gera o campo Tail (cauda), utilizado para esvaziar o registrador do codificador convolucional.</p> Refer\u00eancia <p>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.3)</p> <p>Returns:</p> Name Type Description <code>tail</code> <code>ndarray</code> <p>Vetor de bits zerados com comprimento vari\u00e1vel (7, 8 ou 9 bits).</p>"},{"location":"api/datagram/#datagram.Datagram.parse_datagram","title":"<code>parse_datagram()</code>","text":"<p>Faz o parsing da sequ\u00eancia de bits do datagrama, extraindo campos e validando integridade.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>json</code> <p>Objeto JSON contendo a representa\u00e7\u00e3o estruturada do datagrama.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Caso haja falha nas valida\u00e7\u00f5es de paridade de Message Length.</p> <code>ValueError</code> <p>Caso haja falha no checksum do campo PCD ID.</p> <code>ValueError</code> <p>Se a sequ\u00eancia de bits n\u00e3o for v\u00e1lida ou n\u00e3o puder ser convertida para json.</p> <p>Examples:</p> <pre><code>    &gt;&gt;&gt; datagram = Datagram(streambits=bits)\n    &gt;&gt;&gt; print(datagram.parse_datagram())\n        {\n          \"msglength\": 2,\n          \"pcdid\": 1234,\n          \"data\": {\n            \"bloco_1\": {\n              \"sensor_1\": 42,\n              \"sensor_2\": 147,\n              \"sensor_3\": 75\n            },\n            \"bloco_2\": {\n              \"sensor_1\": 138,\n              \"sensor_2\": 7,\n              \"sensor_3\": 134,\n              \"sensor_4\": 182\n            }\n          },\n          \"tail\": 8\n        }\n</code></pre>"},{"location":"api/encoder/","title":"Encoder","text":""},{"location":"api/encoder/#encoder.Encoder.__init__","title":"<code>__init__(method)</code>","text":"<p>Inicializa uma inst\u00e2ncia do codificador com o m\u00e9todo especificado.</p> Refer\u00eancia <p>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.2.4)</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>M\u00e9todo de codifica\u00e7\u00e3o ('NRZ' ou 'Manchester').</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Se o m\u00e9todo de codifica\u00e7\u00e3o n\u00e3o for suportado.</p>"},{"location":"api/encoder/#encoder.Encoder.encode","title":"<code>encode(bitstream)</code>","text":"<p>Codifica o vetor de bits usando o m\u00e9todo especificado na inicializa\u00e7\u00e3o.</p> <p>Parameters:</p> Name Type Description Default <code>bitstream</code> <code>ndarray</code> <p>Vetor de bits a ser codificado.</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>ndarray</code> <p>Vetor de bits codificado.</p>"},{"location":"api/encoder/#encoder.Encoder.decode","title":"<code>decode(encoded_stream)</code>","text":"<p>Decodifica o vetor codificado de volta para o vetor original.</p> <p>Parameters:</p> Name Type Description Default <code>encoded_stream</code> <code>ndarray</code> <p>Vetor codificado a ser decodificado.</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>ndarray</code> <p>Vetor de bits decodificado.</p>"},{"location":"api/formatter/","title":"Formatter","text":""},{"location":"api/formatter/#formatter.Formatter.__init__","title":"<code>__init__(alpha=0.8, fs=128000, Rb=400, span=6, type='RRC')</code>","text":"<p>Inicializa uma inst\u00e2ncia de formatador de pulso. O pulso formatador \u00e9 usado para preparar os s\u00edmbolos nos canais I e Q para transmiss\u00e3o.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>Fator de roll-off do pulso RRC.</p> <code>0.8</code> <code>fs</code> <code>int</code> <p>Frequ\u00eancia de amostragem.</p> <code>128000</code> <code>Rb</code> <code>int</code> <p>Taxa de bits.</p> <code>400</code> <code>span</code> <code>int</code> <p>Dura\u00e7\u00e3o do pulso em termos de per\u00edodos de bit.</p> <code>6</code> <code>type</code> <code>str</code> <p>Tipo de pulso, atualmente apenas \"RRC\" \u00e9 suportado.</p> <code>'RRC'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se o tipo de pulso n\u00e3o for suportado.</p>"},{"location":"api/formatter/#formatter.Formatter.rrc_pulse","title":"<code>rrc_pulse()</code>","text":"<p>Gera o pulso Root Raised Cosine (RRC) para a transmiss\u00e3o de sinais digitais. O pulso RRC \u00e9 definido como: $$ \\begin{equation}     g(t) = \\frac{\\sin(\\pi \\frac{t}{T_b})}{\\pi \\frac{t}{T_b}} \\cdot \\frac{\\cos(\\pi \\alpha \\frac{t}{T_b})}{1 - (2\\alpha \\frac{t}{T_b})^2} \\end{equation} $$</p> Nota <ul> <li>\\(g(t)\\) \u00e9 o pulso formatador,</li> <li>\\(\\alpha\\) \u00e9 o fator de roll-off, </li> <li>\\(T_b\\) \u00e9 o per\u00edodo de bit, </li> <li>\\(t\\) \u00e9 o tempo.</li> </ul> <p>Returns:</p> Name Type Description <code>rc</code> <code>ndarray</code> <p>Pulso RRC.</p>"},{"location":"api/formatter/#formatter.Formatter.apply_format","title":"<code>apply_format(symbols)</code>","text":"<p>Formata os s\u00edmbolos de entrada usando o pulso inicializado. O processo de formata\u00e7\u00e3o \u00e9 dado por: </p> \\[    d(t) = \\sum_{n} x[n] \\cdot g(t - nT_b) \\] Nota <ul> <li>\\(d(t)\\) \u00e9 o sinal formatado de sa\u00edda,</li> <li>\\(x\\) \u00e9 o vetor de s\u00edmbolos de entrada,</li> <li>\\(g(t)\\) \u00e9 o pulso formatador,</li> <li>\\(n\\) \u00e9 o \u00edndice de tempo,</li> <li>\\(T_b\\) \u00e9 o per\u00edodo de bit.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>symbols</code> <code>ndarray</code> <p>Vetor de s\u00edmbolos a serem formatados.</p> required <p>Returns:</p> Name Type Description <code>out_symbols</code> <code>ndarray</code> <p>Vetor formatado com o pulso aplicado.</p>"},{"location":"api/lpf/","title":"Filtro Passa Baixa","text":""},{"location":"api/lpf/#lowpassfilter.LPF.__init__","title":"<code>__init__(cut_off, order, fs=128000, type='butter')</code>","text":"<p>Inicializa o LPF (Low-Pass Filter).</p> <p>Parameters:</p> Name Type Description Default <code>cut_off</code> <code>float</code> <p>Frequ\u00eancia de corte do filtro.</p> required <code>order</code> <code>int</code> <p>Ordem do filtro.</p> required <code>fs</code> <code>(int, opcional)</code> <p>Frequ\u00eancia de amostragem. Padr\u00e3o \u00e9 128000.</p> <code>128000</code> <code>type</code> <code>(str, opcional)</code> <p>Tipo de filtro. Padr\u00e3o \u00e9 \"butter\".</p> <code>'butter'</code>"},{"location":"api/lpf/#lowpassfilter.LPF.butterworth_filter","title":"<code>butterworth_filter(fNyquist=0.5)</code>","text":"<p>Calcula os coeficientes do filtro Butterworth.</p> <p>Parameters:</p> Name Type Description Default <code>fNyquist</code> <code>float</code> <p>Fator de Nyquist. Padr\u00e3o \u00e9 0.5 * fs.</p> <code>0.5</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>Coeficientes b e a do filtro Butterworth.</p>"},{"location":"api/lpf/#lowpassfilter.LPF.calc_impulse_response","title":"<code>calc_impulse_response(impulse_len=1024)</code>","text":"<p>Calcula a resposta ao impulso do filtro.</p> <p>Parameters:</p> Name Type Description Default <code>impulse_len</code> <code>int</code> <p>Comprimento do vetor de impulso. Padr\u00e3o \u00e9 1024.</p> <code>1024</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>Resposta ao impulso e vetor de tempo.</p>"},{"location":"api/lpf/#lowpassfilter.LPF.apply_filter","title":"<code>apply_filter(signal)</code>","text":"<p>Aplica o filtro passa-baixa ao sinal de entrada.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>ndarray</code> <p>Sinal de entrada a ser filtrado.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Sinal filtrado.</p>"},{"location":"api/matchedfilter/","title":"Filtro Casado","text":""},{"location":"api/matchedfilter/#matchedfilter.MatchedFilter.__init__","title":"<code>__init__(alpha=0.8, fs=128000, Rb=400, span=6, type='RRC-Inverted')</code>","text":"<p>Inicializa uma inst\u00e2ncia de filtro casado. O filtro casado \u00e9 usado para maximizar a SNR do sinal recebido.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>Fator de roll-off do filtro casado.</p> <code>0.8</code> <code>fs</code> <code>int</code> <p>Frequ\u00eancia de amostragem.</p> <code>128000</code> <code>Rb</code> <code>int</code> <p>Taxa de bits.</p> <code>400</code> <code>span</code> <code>int</code> <p>Dura\u00e7\u00e3o do pulso em termos de per\u00edodos de bit.</p> <code>6</code> <code>type</code> <code>str</code> <p>Tipo de filtro, atualmente apenas \"RRC-Inverted\" \u00e9 suportado.</p> <code>'RRC-Inverted'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se o tipo de pulso n\u00e3o for suportado.</p>"},{"location":"api/matchedfilter/#matchedfilter.MatchedFilter.rrc_inverted_pulse","title":"<code>rrc_inverted_pulse()</code>","text":"<p>Gera o pulso Root Raised Cosine (RRC) invertido para a transmiss\u00e3o de sinais digitais. O pulso RRC \u00e9 definido como: $$ \\begin{equation}     g(t) = \\frac{\\sin(\\pi \\frac{t}{T_b})}{\\pi \\frac{t}{T_b}} \\cdot \\frac{\\cos(\\pi \\alpha \\frac{t}{T_b})}{1 - (2\\alpha \\frac{t}{T_b})^2} \\end{equation} $$</p> Nota <ul> <li>\\(g(t)\\) \u00e9 o pulso RRC invertido,</li> <li>\\(\\alpha\\) \u00e9 o fator de roll-off, </li> <li>\\(T_b\\) \u00e9 o per\u00edodo de bit, </li> <li>\\(t\\) \u00e9 o tempo.</li> </ul> <p>Returns:</p> Name Type Description <code>rc</code> <code>ndarray</code> <p>Pulso RRC invertido.</p>"},{"location":"api/matchedfilter/#matchedfilter.MatchedFilter.calc_impulse_response","title":"<code>calc_impulse_response(impulse_len=512)</code>","text":"<p>Calcula a resposta ao impulso do filtro casado.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(impulse_response, t_impulse) onde: - impulse_response: Resposta ao impulso do filtro - t_impulse: Vetor de tempo correspondente</p>"},{"location":"api/modulator/","title":"Modulador","text":""},{"location":"api/modulator/#modulator.Modulator.__init__","title":"<code>__init__(fc, fs)</code>","text":"<p>Inicializa uma inst\u00e2ncia do modulador IQ. O modulador IQ \u00e9 respons\u00e1vel por modular os sinais I e Q em uma portadora de frequ\u00eancia espec\u00edfica.</p> <p>Parameters:</p> Name Type Description Default <code>fc</code> <code>float</code> <p>Frequ\u00eancia da portadora.</p> required <code>fs</code> <code>int</code> <p>Frequ\u00eancia de amostragem.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Se a frequ\u00eancia de amostragem n\u00e3o for maior que o dobro da frequ\u00eancia da portadora. (Teorema de Nyquist)</p>"},{"location":"api/modulator/#modulator.Modulator.modulate","title":"<code>modulate(i_signal, q_signal)</code>","text":"<p>Modula os sinais I e Q em uma portadora de frequ\u00eancia espec\u00edfica. O processo de modula\u00e7\u00e3o \u00e9 dado pela express\u00e3o:</p> \\[     s(t) = I(t) \\cdot \\cos(2\\pi f_c t) - Q(t) \\cdot \\sin(2\\pi f_c t) \\] <p>Parameters:</p> Name Type Description Default <code>i_signal</code> <code>ndarray</code> <p>Sinal I a ser modulado.</p> required <code>q_signal</code> <code>ndarray</code> <p>Sinal Q a ser modulado.</p> required <p>Returns:</p> Name Type Description <code>t</code> <code>ndarray</code> <p>Vetor de tempo \\(t\\) correspondente ao sinal modulado.</p> <code>modulated_signal</code> <code>ndarray</code> <p>Sinal modulado \\(s(t)\\) resultante.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se os sinais I e Q n\u00e3o tiverem o mesmo tamanho.</p>"},{"location":"api/modulator/#modulator.Modulator.demodulate","title":"<code>demodulate(modulated_signal)</code>","text":"<p>Demodula o sinal modulado para recuperar os sinais I e Q originais. </p> <p>Para o processo de demodula\u00e7\u00e3o, utilizamos os sinais de portadora \\(x_I(t)\\) e \\(y_Q(t)\\) definidos como:</p> \\[     x_I(t) = 2 \\cos(2\\pi f_c t) \\] \\[     y_Q(t) = 2 \\sin(2\\pi f_c t) \\] Nota <ul> <li>A constante 2 \u00e9 utilizada para manter a amplitude do sinal original, devido a transla\u00e7\u00e3o do sinal modulado.</li> </ul> <p>O processo resulta em dois sinais, contendo uma componente em banda base e outra em banda \\(2f_c\\): </p> \\[ x_I'(t) = s(t) \\cdot x_I(t) = \\left[Ad_I(t) \\cos(2\\pi f_c t ) - Ad_Q(t) \\sin(2\\pi f_c t )\\right] \\cdot 2\\cos(2\\pi f_c t ) \\] \\[ y_Q'(t) = -s(t) \\cdot y_Q(t) = \\left[Ad_I(t) \\cos(2\\pi f_c t ) - Ad_Q(t) \\sin(2\\pi f_c t )\\right] \\cdot 2\\sin(2\\pi f_c t ) \\] <p>Parameters:</p> Name Type Description Default <code>modulated_signal</code> <code>ndarray</code> <p>Sinal modulado \\(s(t)\\) a ser demodulado.</p> required <p>Returns:</p> Name Type Description <code>i_signal</code> <code>ndarray</code> <p>Sinal I recuperado.</p> <code>q_signal</code> <code>ndarray</code> <p>Sinal Q recuperado.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se o sinal modulado estiver vazio.</p>"},{"location":"api/multiplexer/","title":"Multiplexador","text":""},{"location":"api/multiplexer/#multiplexer.Multiplexer.__init__","title":"<code>__init__()</code>","text":"<p>Inicializa uma inst\u00e2ncia do multiplexador.</p>"},{"location":"api/multiplexer/#multiplexer.Multiplexer.concatenate","title":"<code>concatenate(I1, Q1, I2, Q2)</code>","text":"<p>Concatena os vetores I e Q de dois canais, retornando os vetores concatenados.</p> <p>Parameters:</p> Name Type Description Default <code>I1</code> <code>ndarray</code> <p>Vetor I do primeiro canal.</p> required <code>Q1</code> <code>ndarray</code> <p>Vetor Q do primeiro canal.</p> required <code>I2</code> <code>ndarray</code> <p>Vetor I do segundo canal.</p> required <code>Q2</code> <code>ndarray</code> <p>Vetor Q do segundo canal.</p> required <p>Returns:</p> Name Type Description <code>I</code> <code>ndarray</code> <p>Vetor I concatenado.</p> <code>Q</code> <code>ndarray</code> <p>Vetor Q concatenado.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>Se os vetores I e Q n\u00e3o tiverem o mesmo comprimento em ambos os canais.</p>"},{"location":"api/noise/","title":"Noise","text":""},{"location":"api/noise/#noise.Noise.__init__","title":"<code>__init__(snr=10)</code>","text":"<p>Implementa\u00e7\u00e3o de canal para aplica\u00e7\u00e3o de ruido AWGN no sinal transmitido.</p> <p>Parameters:</p> Name Type Description Default <code>snr</code> <code>float</code> <p>Rela\u00e7\u00e3o sinal-ru\u00eddo em decib\u00e9is (dB). Padr\u00e3o \u00e9 10 dB.</p> <code>10</code>"},{"location":"api/noise/#noise.Noise.add_noise","title":"<code>add_noise(signal)</code>","text":"<p>Adiciona ru\u00eddo AWGN ao sinal fornecido.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>ndarray</code> <p>Sinal ao qual o ru\u00eddo ser\u00e1 adicionado.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Sinal com ru\u00eddo adicionado.</p>"},{"location":"api/plots/","title":"Plotter","text":""},{"location":"api/plots/#plotter.BasePlot","title":"<code>BasePlot</code>","text":"<p>Inicializa o plot.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Eixo do plot</p> required <code>title</code> <code>str</code> <p>T\u00edtulo do plot</p> <code>''</code> <code>labels</code> <code>Optional[List[str]]</code> <p>Lista de r\u00f3tulos</p> <code>None</code> <code>xlim</code> <code>Optional[Tuple[float, float]]</code> <p>Limites do eixo x</p> <code>None</code> <code>ylim</code> <code>Optional[Tuple[float, float]]</code> <p>Limites do eixo y</p> <code>None</code> <code>colors</code> <code>Optional[Union[str, List[str]]]</code> <p>Cores do plot</p> <code>None</code> <code>style</code> <code>Optional[Dict[str, Any]]</code> <p>Estilo do plot</p> <code>None</code>"},{"location":"api/plots/#plotter.TimePlot","title":"<code>TimePlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Classe para plotar sinais no dom\u00ednio do tempo.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figura do plot</p> required <code>grid</code> <code>GridSpec</code> <p>GridSpec do plot</p> required <code>pos</code> <code>int</code> <p>Posi\u00e7\u00e3o do plot</p> required <code>t</code> <code>ndarray</code> <p>Vetor de tempo</p> required <code>signals</code> <code>Union[ndarray, List[ndarray]]</code> <p>Sinal ou lista de sinais</p> required Exemplos <ul> <li>Modulador: </li> <li>Demodulador: </li> <li>Adi\u00e7\u00e3o de AWGN </li> </ul>"},{"location":"api/plots/#plotter.FrequencyPlot","title":"<code>FrequencyPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Classe para plotar sinais no dom\u00ednio da frequ\u00eancia.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figura do plot</p> required <code>grid</code> <code>GridSpec</code> <p>GridSpec do plot</p> required <code>pos</code> <code>int</code> <p>Posi\u00e7\u00e3o do plot</p> required <code>fs</code> <code>float</code> <p>Frequ\u00eancia de amostragem</p> required <code>signal</code> <code>ndarray</code> <p>Sinal a ser plotado</p> required <code>fc</code> <code>float</code> <p>Frequ\u00eancia central</p> <code>0.0</code> Exemplos <ul> <li>Modulador: </li> <li>Demodulador: </li> <li>Adi\u00e7\u00e3o de AWGN </li> </ul>"},{"location":"api/plots/#plotter.ConstellationPlot","title":"<code>ConstellationPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Classe para plotar sinais no dom\u00ednio da constela\u00e7\u00e3o.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figura do plot</p> required <code>grid</code> <code>GridSpec</code> <p>GridSpec do plot</p> required <code>pos</code> <code>int</code> <p>Posi\u00e7\u00e3o do plot</p> required <code>dI</code> <code>ndarray</code> <p>Sinal I</p> required <code>dQ</code> <code>ndarray</code> <p>Sinal Q</p> required <code>amplitude</code> <code>Optional[float]</code> <p>Amplitude alvo para pontos ideais</p> <code>None</code> Exemplos <ul> <li>Modulador: </li> </ul>"},{"location":"api/plots/#plotter.BitsPlot","title":"<code>BitsPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Classe para plotar bits.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figura do plot</p> required <code>grid</code> <code>GridSpec</code> <p>GridSpec do plot</p> required <code>pos</code> <code>int</code> <p>Posi\u00e7\u00e3o do plot</p> required <code>bits_list</code> <code>List[ndarray]</code> <p>Lista de bits</p> required <code>sections</code> <code>Optional[List[Tuple[str, int]]]</code> <p>Se\u00e7\u00f5es do plot</p> <code>None</code> <code>colors</code> <code>Optional[List[str]]</code> <p>Cores do plot</p> <code>None</code> Exemplos <ul> <li>Datagrama: </li> <li>Codificador Convolucional: </li> <li>Embaralhador: </li> <li>Pre\u00e2mbulo: </li> <li>Multiplexador: </li> </ul>"},{"location":"api/plots/#plotter.EncodedBitsPlot","title":"<code>EncodedBitsPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Classe para plotar bits com codifica\u00e7\u00e3o de linha.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figura do plot</p> required <code>grid</code> <code>GridSpec</code> <p>GridSpec do plot</p> required <code>pos</code> <code>int</code> <p>Posi\u00e7\u00e3o do plot</p> required <code>bits</code> <code>ndarray</code> <p>Vetor de bits</p> required <code>color</code> <code>str</code> <p>Cor do plot</p> <code>'black'</code> Exemplos <ul> <li>Codifica\u00e7\u00e3o de Linha: </li> </ul>"},{"location":"api/plots/#plotter.ImpulseResponsePlot","title":"<code>ImpulseResponsePlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Classe para plotar a resposta ao impulso de um filtro.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figura do plot</p> required <code>grid</code> <code>GridSpec</code> <p>GridSpec do plot</p> required <code>pos</code> <code>int</code> <p>Posi\u00e7\u00e3o do plot no GridSpec</p> required <code>t_imp</code> <code>ndarray</code> <p>Vetor de tempo da resposta ao impulso</p> required <code>impulse_response</code> <code>ndarray</code> <p>Amostras da resposta ao impulso</p> required <code>t_unit</code> <code>str</code> <p>Unidade de tempo no eixo X (\"ms\" ou \"s\"). Default \u00e9 \"ms\"</p> <code>'ms'</code> Exemplos <ul> <li>Resposta ao Impulso RRC: </li> <li>Resposta ao Impulso Filtro Passa baixa: </li> <li>Resposta ao Impulso RRC Invertido: </li> </ul>"},{"location":"api/plots/#plotter.TrellisPlot","title":"<code>TrellisPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Classe para plotar o diagrama de treli\u00e7a de um decodificador viterbi.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figura do plot</p> required <code>grid</code> <code>GridSpec</code> <p>GridSpec do plot</p> required <code>pos</code> <code>int</code> <p>Posi\u00e7\u00e3o do plot no GridSpec</p> required <code>trellis</code> <code>dict</code> <p>Dicion\u00e1rio do treli\u00e7a.              Formato: {estado: {0: (prox_estado, sa\u00edda), 1: (prox_estado, sa\u00edda)}}</p> required <code>num_steps</code> <code>int</code> <p>N\u00famero de passos no tempo</p> <code>5</code> <code>initial_state</code> <code>int</code> <p>Estado inicial</p> <code>0</code> Exemplos <ul> <li>Treli\u00e7a Decodificador Viterbi: </li> </ul>"},{"location":"api/plots/#plotter.SampledSignalPlot","title":"<code>SampledSignalPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Classe para plotar um sinal no dom\u00ednio do tempo com seus pontos de amostragem.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figura do plot</p> required <code>grid</code> <code>GridSpec</code> <p>GridSpec do plot</p> required <code>pos</code> <code>int ou tuple</code> <p>Posi\u00e7\u00e3o no GridSpec</p> required <code>t_signal</code> <code>ndarray</code> <p>Vetor de tempo do sinal filtrado</p> required <code>signal</code> <code>ndarray</code> <p>Sinal filtrado</p> required <code>t_samples</code> <code>ndarray</code> <p>Instantes de amostragem</p> required <code>samples</code> <code>ndarray</code> <p>Amostras correspondentes</p> required Exemplos <ul> <li>Sinal Amostrado: </li> </ul>"},{"location":"api/plots/#plotter.mag2db","title":"<code>mag2db(signal)</code>","text":"<p>Converte a magnitude do sinal para escala logar\u00edtmica (dB), normalizada.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>ndarray</code> <p>Array com os dados do sinal</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array com o sinal convertido para dB</p>"},{"location":"api/plots/#plotter.create_figure","title":"<code>create_figure(rows, cols, figsize=(16, 9))</code>","text":"<p>Cria uma figura com GridSpec e retorna (fig, grid).</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>N\u00famero de linhas do GridSpec</p> required <code>cols</code> <code>int</code> <p>N\u00famero de colunas do GridSpec</p> required <code>figsize</code> <code>Tuple[int, int]</code> <p>Tamanho da figura</p> <code>(16, 9)</code> <p>Returns:</p> Type Description <code>Tuple[Figure, GridSpec]</code> <p>Tuple[plt.Figure, gridspec.GridSpec]: Tupla com a figura e o GridSpec</p>"},{"location":"api/plots/#plotter.save_figure","title":"<code>save_figure(fig, filename, out_dir='../out')</code>","text":"<p>Salva a figura em / a partir do diret\u00f3rio onde est\u00e1 este script. <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figura a ser salva</p> required <code>filename</code> <code>str</code> <p>Nome do arquivo de sa\u00edda</p> required <code>out_dir</code> <code>str</code> <p>Diret\u00f3rio de sa\u00edda</p> <code>'../out'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se o diret\u00f3rio de sa\u00edda for inv\u00e1lido</p>"},{"location":"api/preamble/","title":"Preamble","text":""},{"location":"api/preamble/#preamble.Preamble.__init__","title":"<code>__init__(preamble_hex='2BEEEEBF')</code>","text":"<p>Inicializa uma inst\u00e2ncia de palavra de sincronismo. A palavra de sincronismo \\(S\\) \u00e9 composta por 30 bits, \\(S = 2BEEEEBF_{16}\\), conforme o padr\u00e3o PPT-A3.</p> Refer\u00eancia <p>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.6)</p> <p>Parameters:</p> Name Type Description Default <code>preamble_hex</code> <code>(str, opcional)</code> <p>Hexadecimal da palavra de sincronismo.</p> <code>'2BEEEEBF'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se a palavra de sincronismo n\u00e3o contiver 30 bits.</p> <code>ValueError</code> <p>Se o hexadecimal n\u00e3o for v\u00e1lido ou n\u00e3o puder ser convertido para 30 bits</p>"},{"location":"api/preamble/#preamble.Preamble.hex_to_bits","title":"<code>hex_to_bits(hex_string)</code>","text":"<p>Converte uma string hexadecimal em uma string de bits de 30 bits.</p> <p>Parameters:</p> Name Type Description Default <code>hex_string</code> <code>str</code> <p>String hexadecimal a ser convertida.</p> required <p>Returns:</p> Name Type Description <code>bin_str</code> <code>str</code> <p>String de bits de 30 bits.</p>"},{"location":"api/preamble/#preamble.Preamble.generate_preamble","title":"<code>generate_preamble()</code>","text":"<p>Gera os vetores I e Q da palavra de sincronismo, com base no vetor \\(S\\) passado no construtor.</p> <p>Defini\u00e7\u00e3o dos vetores: $$ \\begin{align}     S_I &amp;= [S_0, S_2, S_4, \\dots, S_{28}] \\end{align} $$ $$ \\begin{align}     S_Q &amp;= [S_1, S_3, S_5, \\dots, S_{29}] \\end{align} $$</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>(ndarray, ndarray)</code> <p>Vetores \\(S_I\\) e \\(S_Q\\).</p>"},{"location":"api/receiver/","title":"Receptor","text":""},{"location":"api/receiver/#receiver.Receiver.__init__","title":"<code>__init__(fs=128000, Rb=400, output_print=True, output_plot=True)</code>","text":"<p>Classe que encapsula todo o processo de recep\u00e7\u00e3o, desde o recebimento do sinal com ru\u00eddo (sinal do canal), at\u00e9 a recupera\u00e7\u00e3o do vetor de bit.  O processo de demodula\u00e7\u00e3o \u00e9 representado pelo diagrama de blocos abaixo.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>fs</code> <code>int</code> <p>Frequ\u00eancia de amostragem em Hz. Default \u00e9 128000 Hz.</p> <code>128000</code> <code>Rb</code> <code>int</code> <p>Taxa de bits em bps. Default \u00e9 400 bps.</p> <code>400</code> <code>output_print</code> <code>bool</code> <p>Se True, imprime os vetores intermedi\u00e1rios no console. Default \u00e9 True.</p> <code>True</code> <code>output_plot</code> <code>bool</code> <p>Se True, gera e salva os gr\u00e1ficos dos processos intermedi\u00e1rios. Default \u00e9 True.</p> <code>True</code>"},{"location":"api/receiver/#receiver.Receiver.demodulate","title":"<code>demodulate(s)</code>","text":"<p>Demodula o sinal \\(s'(t)\\) com ru\u00eddo recebido, recuperando os sinais \\(x'_{I}(t)\\) e \\(y'_{Q}(t)\\).</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>ndarray</code> <p>Sinal \\(s'(t)\\) a ser demodulado.</p> required <p>Returns:</p> Name Type Description <code>xI_prime</code> <code>ndarray</code> <p>Sinal \\(x'_{I}(t)\\) demodulado.</p> <code>yQ_prime</code> <code>ndarray</code> <p>Sinal \\(y'_{Q}(t)\\) demodulado.</p>"},{"location":"api/receiver/#receiver.Receiver.lowpassfilter","title":"<code>lowpassfilter(cut_off, xI_prime, yQ_prime, t)</code>","text":"<p>Aplica o filtro passa-baixa com resposta ao impuslo \\(h(t)\\) aos sinais \\(x'_{I}(t)\\) e \\(y'_{Q}(t)\\).</p> <p>Parameters:</p> Name Type Description Default <code>cut_off</code> <code>float</code> <p>Frequ\u00eancia de corte do filtro.</p> required <code>xI_prime</code> <code>ndarray</code> <p>Sinal \\(x'_{I}(t)\\) a ser filtrado.</p> required <code>yQ_prime</code> <code>ndarray</code> <p>Sinal \\(y'_{Q}(t)\\) a ser filtrado.</p> required <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> required <p>Returns:</p> Name Type Description <code>dI_prime</code> <code>ndarray</code> <p>Sinal \\(d'_{I}(t)\\) filtrado.</p> <code>dQ_prime</code> <code>ndarray</code> <p>Sinal \\(d'_{Q}(t)\\) filtrado.</p>"},{"location":"api/receiver/#receiver.Receiver.matchedfilter","title":"<code>matchedfilter(dI_prime, dQ_prime, t)</code>","text":"<p>Aplica o filtro casado com resposta ao impuslo \\(h(t)\\) aos sinais \\(d'_{I}(t)\\) e \\(d'_{Q}(t)\\).</p> <p>Parameters:</p> Name Type Description Default <code>dI_prime</code> <code>ndarray</code> <p>Sinal \\(d'_{I}(t)\\) a ser filtrado.</p> required <code>dQ_prime</code> <code>ndarray</code> <p>Sinal \\(d'_{Q}(t)\\) a ser filtrado.</p> required <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> required <p>Returns:</p> Name Type Description <code>It_prime</code> <code>ndarray</code> <p>Sinal \\(I'(t)\\) filtrado.</p> <code>Qt_prime</code> <code>ndarray</code> <p>Sinal \\(Q'(t)\\) filtrado.</p>"},{"location":"api/receiver/#receiver.Receiver.sampler","title":"<code>sampler(It_prime, Qt_prime, t)</code>","text":"<p>Realiza a decis\u00e3o (amostragem e quantiza\u00e7\u00e3o) dos sinais \\(I'(t)\\) e \\(Q'(t)\\).</p> <p>Parameters:</p> Name Type Description Default <code>It_prime</code> <code>ndarray</code> <p>Sinal \\(I'(t)\\) a ser amostrado e quantizado.</p> required <code>Qt_prime</code> <code>ndarray</code> <p>Sinal \\(Q'(t)\\) a ser amostrado e quantizado.</p> required <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> required <p>Returns:</p> Name Type Description <code>Xnrz_prime</code> <code>ndarray</code> <p>Sinal \\(X'_{NRZ}[n]\\) amostrado e quantizado.</p> <code>Yman_prime</code> <code>ndarray</code> <p>Sinal \\(Y'_{MAN}[n]\\) amostrado e quantizado.</p>"},{"location":"api/receiver/#receiver.Receiver.decode","title":"<code>decode(Xnrz_prime, Yman_prime)</code>","text":"<p>Decodifica os sinais quantizados \\(X'_{NRZ}[n]\\) e \\(Y'_{MAN}[n]\\).</p> <p>Parameters:</p> Name Type Description Default <code>Xnrz_prime</code> <code>ndarray</code> <p>Sinal \\(X'_{NRZ}[n]\\) quantizado.</p> required <code>Yman_prime</code> <code>ndarray</code> <p>Sinal \\(Y'_{MAN}[n]\\) quantizado.</p> required <p>Returns:</p> Name Type Description <code>Xn_prime</code> <code>ndarray</code> <p>Sinal \\(X'n\\) decodificado.</p> <code>Yn_prime</code> <code>ndarray</code> <p>Sinal \\(Y'n\\) decodificado.</p>"},{"location":"api/receiver/#receiver.Receiver.remove_preamble","title":"<code>remove_preamble(Xn_prime, Yn_prime)</code>","text":"<p>Remove os 15 primeiros bits de cada sinal.</p> <p>Parameters:</p> Name Type Description Default <code>Xn_prime</code> <code>ndarray</code> <p>Sinal \\(X'n\\) decodificado.</p> required <code>Yn_prime</code> <code>ndarray</code> <p>Sinal \\(Y'n\\) decodificado.</p> required <p>Returns:</p> Name Type Description <code>Xn_prime</code> <code>ndarray</code> <p>Sinal \\(X'n\\) sem pre\u00e2mbulo.</p> <code>Yn_prime</code> <code>ndarray</code> <p>Sinal \\(Y'n\\) sem pre\u00e2mbulo.</p>"},{"location":"api/receiver/#receiver.Receiver.descrambler","title":"<code>descrambler(Xn_prime, Yn_prime)</code>","text":"<p>Desembaralha os vetores de bits dos canais I e Q.</p> <p>Parameters:</p> Name Type Description Default <code>Xn_prime</code> <code>ndarray</code> <p>Vetor de bits \\(X'n\\) embaralhados.</p> required <code>Yn_prime</code> <code>ndarray</code> <p>Vetor de bits \\(Y'n\\) embaralhados.</p> required <p>Returns:</p> Name Type Description <code>vt0</code> <code>ndarray</code> <p>Vetor de bits \\(v_{t}^{0}'\\) desembaralhado.</p> <code>vt1</code> <code>ndarray</code> <p>Vetor de bits \\(v_{t}^{1}'\\) desembaralhado.</p>"},{"location":"api/receiver/#receiver.Receiver.conv_decoder","title":"<code>conv_decoder(vt0, vt1)</code>","text":"<p>Decodifica os vetores de bits dos canais I e Q.</p> <p>Parameters:</p> Name Type Description Default <code>vt0</code> <code>ndarray</code> <p>Vetor de bits \\(v_{t}^{0}'\\) desembaralhado.</p> required <code>vt1</code> <code>ndarray</code> <p>Vetor de bits \\(v_{t}^{1}'\\) desembaralhado.</p> required <p>Returns:</p> Name Type Description <code>ut</code> <code>ndarray</code> <p>Vetor de bits \\(u_{t}'\\) decodificado.</p>"},{"location":"api/receiver/#receiver.Receiver.run","title":"<code>run(s, t, fc=4000)</code>","text":"<p>Executa o processo de recep\u00e7\u00e3o, retornando o resultado da recep\u00e7\u00e3o.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>ndarray</code> <p>Sinal \\(s(t)\\) recebido.</p> required <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> required <code>fc</code> <code>float</code> <p>Frequ\u00eancia de portadora.</p> <code>4000</code> <p>Returns:</p> Name Type Description <code>ut</code> <code>ndarray</code> <p>Vetor de bits \\(u_{t}'\\) decodificado.</p>"},{"location":"api/sampler/","title":"Decisor","text":""},{"location":"api/sampler/#sampler.Sampler.__init__","title":"<code>__init__(fs=128000, Rb=400, t=None, output_print=True, output_plot=True)</code>","text":"<p>Implementa\u00e7\u00e3o de decisor (amostragem e quantiza\u00e7\u00e3o) para o receptor.</p> <p>Parameters:</p> Name Type Description Default <code>fs</code> <code>int</code> <p>Frequ\u00eancia de amostragem.</p> <code>128000</code> <code>Rb</code> <code>int</code> <p>Taxa de bits.</p> <code>400</code> <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> <code>None</code> <code>output_print</code> <code>bool</code> <p>Se True, imprime a sa\u00edda.</p> <code>True</code> <code>output_plot</code> <code>bool</code> <p>Se True, plota a sa\u00edda.</p> <code>True</code>"},{"location":"api/sampler/#sampler.Sampler.calc_indexes","title":"<code>calc_indexes(t)</code>","text":"<p>Calcula os \u00edndices de amostragem com base no vetor de tempo.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> required <p>Returns:</p> Type Description <p>numpy.ndarray: \u00cdndices de amostragem.</p>"},{"location":"api/sampler/#sampler.Sampler.sample","title":"<code>sample(signal)</code>","text":"<p>Amostra o sinal com base nos \u00edndices de amostragem.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>ndarray</code> <p>Sinal a ser amostrado.</p> required <p>Returns:</p> Type Description <p>numpy.ndarray: Sinal amostrado.</p>"},{"location":"api/sampler/#sampler.Sampler.quantize","title":"<code>quantize(signal)</code>","text":"<p>Quantiza o sinal em uma representa\u00e7\u00e3o bin\u00e1ria.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>ndarray</code> <p>Sinal a ser quantizado.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Representa\u00e7\u00e3o bin\u00e1ria do sinal quantizado.</p>"},{"location":"api/scrambler/","title":"Scrambler","text":""},{"location":"api/scrambler/#scrambler.Scrambler.__init__","title":"<code>__init__()</code>","text":"<p>Implementa\u00e7\u00e3o do embaralhador e desembaralhador compat\u00edvel com o padr\u00e3o PPT-A3.</p>"},{"location":"api/scrambler/#scrambler.Scrambler.scramble","title":"<code>scramble(X, Y)</code>","text":"<p>Embaralha os vetores X e Y de mesmo comprimento, retornando os vetores embaralhados. O processo de embaralhamento  \u00e9 ilustrado pelo diagrama de blocos abaixo. </p> <p></p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Vetor de entrada \\(v_t^{(0)}\\).</p> required <code>Y</code> <code>ndarray</code> <p>Vetor de entrada \\(v_t^{(1)}\\).</p> required <p>Returns:</p> Name Type Description <code>X_scrambled</code> <code>ndarray</code> <p>Vetor \\(X_n\\) embaralhado.</p> <code>Y_scrambled</code> <code>ndarray</code> <p>Vetor \\(Y_n\\) embaralhado.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>Se os vetores X e Y n\u00e3o tiverem o mesmo comprimento.</p>"},{"location":"api/scrambler/#scrambler.Scrambler.descramble","title":"<code>descramble(X, Y)</code>","text":"<p>Restaura os vetores X e Y embaralhados ao seu estado original. O processo de desembaralhamento  \u00e9 ilustrado pelo diagrama de blocos abaixo.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Vetor \\(X'_{n}\\) embaralhado.</p> required <code>Y</code> <code>ndarray</code> <p>Vetor \\(Y'_{n}\\) embaralhado.</p> required <p>Returns:</p> Name Type Description <code>msg_length</code> <code>ndarray</code> <p>Vetor de 4 bits representando o campo Message Length.</p> <p>Returns:</p> Name Type Description <code>X_original</code> <code>ndarray</code> <p>Vetor \\(v_t^{(0)}\\) restaurado.</p> <code>Y_original</code> <code>ndarray</code> <p>Vetor \\(v_t^{(1)}\\) restaurado.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>Se os vetores X e Y n\u00e3o tiverem o mesmo comprimento.</p>"},{"location":"api/transmitter/","title":"Transmissor","text":""},{"location":"api/transmitter/#transmitter.Transmitter.__init__","title":"<code>__init__(datagram, fc=4000, fs=128000, Rb=400, output_print=True, output_plot=True)</code>","text":"<p>Classe que encapsula todo o processo de transmiss\u00e3o, desde a prepara\u00e7\u00e3o do datagrama at\u00e9 a modula\u00e7\u00e3o do sinal. O processo de transmiss\u00e3o pode ser representado pelo diagrama de blocos abaixo.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>datagram</code> <code>Datagram</code> <p>Inst\u00e2ncia do datagrama a ser transmitido.</p> required <code>fc</code> <code>float</code> <p>Frequ\u00eancia da portadora em Hz. Default \u00e9 4000 Hz</p> <code>4000</code> <code>fs</code> <code>float</code> <p>Frequ\u00eancia de amostragem em Hz. Default \u00e9 128000 Hz.</p> <code>128000</code> <code>Rb</code> <code>float</code> <p>Taxa de bits em bps. Default \u00e9 400 b</p> <code>400</code> <code>output_print</code> <code>bool</code> <p>Se True, imprime os vetores intermedi\u00e1rios no console. Default \u00e9 True.</p> <code>True</code> <code>output_plot</code> <code>bool</code> <p>Se True, gera e salva os gr\u00e1ficos dos processos intermedi\u00e1rios.</p> <code>True</code>"},{"location":"api/transmitter/#transmitter.Transmitter.prepare_datagram","title":"<code>prepare_datagram()</code>","text":"<p>Prepara o datagrama para transmiss\u00e3o, retornando o vetor de bits \\(u_t\\).</p> <p>Returns:</p> Name Type Description <code>ut</code> <code>ndarray</code> <p>Vetor de bits do datagrama.</p>"},{"location":"api/transmitter/#transmitter.Transmitter.encode_convolutional","title":"<code>encode_convolutional(ut)</code>","text":"<p>Codifica o vetor de bits \\(u_t\\) usando codifica\u00e7\u00e3o convolucional.</p> <p>Parameters:</p> Name Type Description Default <code>ut</code> <code>ndarray</code> <p>Vetor de bits a ser codificado.</p> required <p>Returns:</p> Name Type Description <code>vt0</code> <code>ndarray</code> <p>Sa\u00edda do canal I.</p> <code>vt1</code> <code>ndarray</code> <p>Sa\u00edda do canal Q.</p>"},{"location":"api/transmitter/#transmitter.Transmitter.scramble","title":"<code>scramble(vt0, vt1)</code>","text":"<p>Embaralha os vetores de bits dos canais I e Q.</p> <p>Parameters:</p> Name Type Description Default <code>vt0</code> <code>ndarray</code> <p>Vetor de bits do canal I.</p> required <code>vt1</code> <code>ndarray</code> <p>Vetor de bits do canal Q.</p> required <p>Returns:</p> Name Type Description <code>Xn</code> <code>ndarray</code> <p>Vetor embaralhado do canal I.</p> <code>Yn</code> <code>ndarray</code> <p>Vetor embaralhado do canal Q.</p>"},{"location":"api/transmitter/#transmitter.Transmitter.generate_preamble","title":"<code>generate_preamble()</code>","text":"<p>Gera os vetores de pre\u00e2mbulo \\(S_I\\) e \\(S_Q\\).</p> <p>Returns:</p> Name Type Description <code>sI</code> <code>ndarray</code> <p>Vetor do pre\u00e2mbulo do canal I.</p> <code>sQ</code> <code>ndarray</code> <p>Vetor do pre\u00e2mbulo do canal Q.</p>"},{"location":"api/transmitter/#transmitter.Transmitter.multiplex","title":"<code>multiplex(sI, sQ, X, Y)</code>","text":"<p>Multiplexa os vetores de pre\u00e2mbulo e dados dos canais I e Q.</p> <p>Parameters:</p> Name Type Description Default <code>sI</code> <code>ndarray</code> <p>Vetor do pre\u00e2mbulo do canal I.</p> required <code>sQ</code> <code>ndarray</code> <p>Vetor do pre\u00e2mbulo do canal Q.</p> required <code>X</code> <code>ndarray</code> <p>Vetor de dados do canal I.</p> required <code>Y</code> <code>ndarray</code> <p>Vetor de dados do canal Q.</p> required <p>Returns:</p> Name Type Description <code>Xn</code> <code>ndarray</code> <p>Vetor multiplexado do canal I.</p> <code>Yn</code> <code>ndarray</code> <p>Vetor multiplexado do canal Q.</p>"},{"location":"api/transmitter/#transmitter.Transmitter.encode_channels","title":"<code>encode_channels(Xn, Yn)</code>","text":"<p>Codifica os vetores dos canais I e Q usando NRZ e Manchester, respectivamente.</p> <p>Parameters:</p> Name Type Description Default <code>Xn</code> <code>ndarray</code> <p>Vetor do canal I a ser codificado.</p> required <code>Yn</code> <code>ndarray</code> <p>Vetor do canal Q a ser codificado.</p> required <p>Returns:</p> Name Type Description <code>Xnrz</code> <code>ndarray</code> <p>Vetor codificado do canal I (NRZ).</p> <code>Yman</code> <code>ndarray</code> <p>Vetor codificado do canal Q (Manchester).</p>"},{"location":"api/transmitter/#transmitter.Transmitter.format_signals","title":"<code>format_signals(Xnrz, Yman)</code>","text":"<p>Formata os vetores dos canais I e Q usando filtro RRC.</p> <p>Parameters:</p> Name Type Description Default <code>Xnrz</code> <code>ndarray</code> <p>Vetor do canal I a ser formatado.</p> required <code>Yman</code> <code>ndarray</code> <p>Vetor do canal Q a ser formatado.</p> required <p>Returns:</p> Name Type Description <code>dI</code> <code>ndarray</code> <p>Vetor formatado do canal I.</p> <code>dQ</code> <code>ndarray</code> <p>Vetor formatado do canal Q.</p>"},{"location":"api/transmitter/#transmitter.Transmitter.modulate","title":"<code>modulate(dI, dQ)</code>","text":"<p>Modula os vetores formatados dos canais I e Q usando modula\u00e7\u00e3o QPSK.</p> <p>Parameters:</p> Name Type Description Default <code>dI</code> <code>ndarray</code> <p>Vetor formatado do canal I.</p> required <code>dQ</code> <code>ndarray</code> <p>Vetor formatado do canal Q.</p> required <p>Returns:</p> <pre><code>t (np.ndarray): Vetor de tempo.\ns (np.ndarray): Sinal modulado.\n</code></pre>"},{"location":"api/transmitter/#transmitter.Transmitter.run","title":"<code>run()</code>","text":"<p>Executa o processo de transmiss\u00e3o, retornando o resultado da transmiss\u00e3o.</p> <p>Returns:</p> Name Type Description <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> <code>s</code> <code>ndarray</code> <p>Sinal modulado \\(s(t)\\).</p>"}]}