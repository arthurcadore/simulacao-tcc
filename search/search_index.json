{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Simulador ARGOS-3","text":"<p>Documenta\u00e7\u00e3o gerada automaticamente com MkDocs + mkdocstrings.</p>"},{"location":"api/bersnr/","title":"BER vs SNR","text":"<p>Implementa\u00e7\u00e3o de simula\u00e7\u00e3o para curva BER vs SNR. </p> <p>Autor: Arthur Cadore Data: 28-07-2025</p>"},{"location":"api/bersnr/#bersnr.simulate_ber","title":"<code>simulate_ber(snr_db, numblocks=8, fs=128000, Rb=400)</code>","text":"<p>Simula a transmiss\u00e3o e recep\u00e7\u00e3o de um datagrama ARGOS-III, para um dado SNR.</p> <p>Parameters:</p> Name Type Description Default <code>snr_db</code> <code>float</code> <p>Rela\u00e7\u00e3o sinal-ru\u00eddo em decib\u00e9is.</p> required <code>numblocks</code> <code>int</code> <p>N\u00famero de blocos a serem transmitidos.</p> <code>8</code> <code>fs</code> <code>int</code> <p>Frequ\u00eancia de amostragem.</p> <code>128000</code> <code>Rb</code> <code>int</code> <p>Taxa de bits. </p> <code>400</code> <p>Returns:</p> Name Type Description <code>ber</code> <code>float</code> <p>A taxa de erro de bit (BER) simulada.</p> Source code in <code>src/bersnr.py</code> <pre><code>def simulate_ber(snr_db, numblocks=8, fs=128_000, Rb=400):\n    r\"\"\"\n    Simula a transmiss\u00e3o e recep\u00e7\u00e3o de um datagrama ARGOS-III, para um dado SNR.\n\n    Args: \n        snr_db (float): Rela\u00e7\u00e3o sinal-ru\u00eddo em decib\u00e9is.\n        numblocks (int): N\u00famero de blocos a serem transmitidos.\n        fs (int): Frequ\u00eancia de amostragem.\n        Rb (int): Taxa de bits. \n\n    Returns: \n        ber (float): A taxa de erro de bit (BER) simulada.\n    \"\"\"\n    datagramTX = Datagram(pcdnum=1234, numblocks=numblocks)\n    bitsTX = datagramTX.streambits\n\n    transmitter = Transmitter(datagramTX, output_print=False, output_plot=False)\n    t, s = transmitter.run()\n\n    add_noise = Noise(snr=snr_db)\n    s_noisy = add_noise.add_noise(s)\n\n    receiver = Receiver(fs=fs, Rb=Rb, output_print=False, output_plot=False)\n    bitsRX = receiver.run(s_noisy, t)\n\n    # Calcula BER\n    num_errors = sum(1 for tx, rx in zip(bitsTX, bitsRX) if tx != rx)\n    ber = num_errors / len(bitsTX)\n    return ber\n</code></pre>"},{"location":"api/bersnr/#bersnr.run_simulation","title":"<code>run_simulation(SNR_values=np.arange(-30, 31, 1), repetitions=10, numblocks=1, num_workers=16)</code>","text":"<p>Executa a simula\u00e7\u00e3o completa de BER vs SNR. Retorna a tupla BER vs SNR.</p> <p>Parameters:</p> Name Type Description Default <code>SNR_values</code> <code>ndarray</code> <p>Valores de SNR a serem simulados.</p> <code>arange(-30, 31, 1)</code> <code>repetitions</code> <code>int</code> <p>N\u00famero de repeti\u00e7\u00f5es para cada valor de SNR.</p> <code>10</code> <code>numblocks</code> <code>int</code> <p>N\u00famero de blocos a serem transmitidos.</p> <code>1</code> <code>num_workers</code> <code>int</code> <p>N\u00famero de trabalhadores para a execu\u00e7\u00e3o paralela.</p> <code>16</code> <p>Returns:</p> Name Type Description <code>list</code> <p>Lista de tuplas (SNR, BER_m\u00e9dio).</p> Source code in <code>src/bersnr.py</code> <pre><code>def run_simulation(SNR_values=np.arange(-30, 31, 1), repetitions=10, numblocks=1, num_workers=16):\n    r\"\"\"\n    Executa a simula\u00e7\u00e3o completa de BER vs SNR. Retorna a tupla BER vs SNR.\n\n    Args: \n        SNR_values (np.ndarray): Valores de SNR a serem simulados.\n        repetitions (int): N\u00famero de repeti\u00e7\u00f5es para cada valor de SNR.\n        numblocks (int): N\u00famero de blocos a serem transmitidos.\n        num_workers (int): N\u00famero de trabalhadores para a execu\u00e7\u00e3o paralela.\n\n    Returns:\n        list: Lista de tuplas (SNR, BER_m\u00e9dio).\n    \"\"\"\n    results = []\n    total_tasks = len(SNR_values) * repetitions\n    ber_accumulator = {snr: [] for snr in SNR_values}\n\n    with concurrent.futures.ProcessPoolExecutor(max_workers=num_workers) as executor:\n        futures = {\n            executor.submit(simulate_ber, snr, numblocks): snr\n            for snr in SNR_values\n            for _ in range(repetitions)\n        }\n        for future in tqdm(concurrent.futures.as_completed(futures), total=total_tasks, desc=\"Simulando\"):\n            snr = futures[future]\n            try:\n                ber = future.result()\n                ber_accumulator[snr].append(ber)\n            except Exception as e:\n                print(f\"Erro na simula\u00e7\u00e3o SNR={snr}: {e}\")\n\n    # Calcula m\u00e9dia por SNR\n    for snr in SNR_values:\n        mean_ber = np.mean(ber_accumulator[snr])\n        results.append((snr, mean_ber))\n\n    return results\n</code></pre>"},{"location":"api/bersnr/#bersnr.save_results","title":"<code>save_results(results, filename='../out/snr_vs_ber.txt')</code>","text":"<p>Salva os resultados de simula\u00e7\u00e3o em um arquivo .txt </p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>list</code> <p>Lista de tuplas (SNR, BER) a serem salvas.</p> required <code>filename</code> <code>str</code> <p>Caminho do arquivo de sa\u00edda.</p> <code>'../out/snr_vs_ber.txt'</code> Source code in <code>src/bersnr.py</code> <pre><code>def save_results(results, filename=\"../out/snr_vs_ber.txt\"):\n    r\"\"\"\n    Salva os resultados de simula\u00e7\u00e3o em um arquivo .txt \n\n    Args:\n        results (list): Lista de tuplas (SNR, BER) a serem salvas.\n        filename (str): Caminho do arquivo de sa\u00edda.\n    \"\"\"\n    script_dir = os.path.dirname(os.path.abspath(__file__))\n    filepath = os.path.normpath(os.path.join(script_dir, filename))\n\n    os.makedirs(os.path.dirname(filepath), exist_ok=True)\n    with open(filepath, \"w\") as f:\n        f.write(\"SNR_dB\\tBER\\n\")\n        for snr, ber in results:\n            f.write(f\"{snr}\\t{ber:.8e}\\n\")\n</code></pre>"},{"location":"api/bersnr/#bersnr.plot_from_file","title":"<code>plot_from_file(filename='../out/snr_vs_ber.txt', out_pdf='../out/snr_vs_ber.pdf')</code>","text":"<p>L\u00ea os resultados do arquivo TXT (relativo ao diret\u00f3rio do script) e gera o gr\u00e1fico BER vs SNR em PDF.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Caminho do arquivo de entrada.</p> <code>'../out/snr_vs_ber.txt'</code> <code>out_pdf</code> <code>str</code> <p>Caminho do arquivo PDF de sa\u00edda. </p> <code>'../out/snr_vs_ber.pdf'</code> <p></p> Source code in <code>src/bersnr.py</code> <pre><code>def plot_from_file(filename=\"../out/snr_vs_ber.txt\", out_pdf=\"../out/snr_vs_ber.pdf\"):\n    r\"\"\"\n    L\u00ea os resultados do arquivo TXT (relativo ao diret\u00f3rio do script) e gera o gr\u00e1fico BER vs SNR em PDF.\n\n    Args:\n        filename (str): Caminho do arquivo de entrada.\n        out_pdf (str): Caminho do arquivo PDF de sa\u00edda. \n\n    ![bersnr](assets/snr_vs_ber.svg)\n    \"\"\"\n    script_dir = os.path.dirname(os.path.abspath(__file__))\n    filepath = os.path.normpath(os.path.join(script_dir, filename))\n    outpath = os.path.normpath(os.path.join(script_dir, out_pdf))\n\n    data = np.loadtxt(filepath, skiprows=1)  # ignora cabe\u00e7alho\n    snr_list, ber_list = data[:, 0], data[:, 1]\n\n    plt.figure()\n    plt.semilogy(snr_list, ber_list, marker='o')\n    plt.grid(True, which=\"both\", ls=\"--\")\n    plt.xlabel(\"SNR (dB)\")\n    plt.ylabel(\"BER\")\n    plt.title(\"SNR vs BER\")\n\n    os.makedirs(os.path.dirname(outpath), exist_ok=True)\n    plt.savefig(outpath, dpi=300)\n    plt.close()\n</code></pre>"},{"location":"api/convolutional/","title":"Convolutional Encoder","text":"Source code in <code>src/convolutional.py</code> <pre><code>class EncoderConvolutional: \n    def __init__(self, G=np.array([[0b1111001, 0b1011011]])):\n        r\"\"\"\n        Inicializa o codificador convolucional com matriz de geradores.\n\n        Refer\u00eancia:\n            - AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.4)\n            - CCSDS 131.1-G-2\n\n        Args:\n            G (np.ndarray): Matriz de polin\u00f4mios geradores em formato bin\u00e1rio.\n\n        Nota: \n            - O polin\u00f4mio gerador $G_0$ \u00e9 representado por `G[0][0]` e $G_1$ por `G[0][1]`.\n            - $G_0$ \u00e9 definido como $1111001_{2}$ ou $121_{10}$\n            - $G_1$ \u00e9 definido como $1011011_{2}$ ou $91_{10}$\n\n        \"\"\"\n        self.G = G\n        self.G0 = int(G[0][0])\n        self.G1 = int(G[0][1])\n        self.K = max(self.G0.bit_length(), self.G1.bit_length())\n        self.g0_taps = self.calc_taps(self.G0)\n        self.g1_taps = self.calc_taps(self.G1)\n        self.shift_register = np.zeros(self.K, dtype=int)\n        self.komm = komm.ConvolutionalCode(G)\n\n    def calc_taps(self, poly):\n        r\"\"\"\n        Calcula os \u00edndices (\"taps\") dos bits ativos (ou seja, bits $'1'$) no polin\u00f4mio gerador.\n\n        Args:\n            poly (int): Polin\u00f4mio em formato bin\u00e1rio. \n\n        Returns:\n            taps (int): Lista com os \u00edndices dos taps ativos.\n        \"\"\"\n        bin_str = f\"{poly:0{self.K}b}\"\n        taps = [i for i, b in enumerate(bin_str) if b == '1']\n        return taps\n\n    def calc_free_distance(self):\n        r\"\"\"\n        Calcula a dist\u00e2ncia livre do c\u00f3digo convolucional, definida como a menor\n        dist\u00e2ncia de Hamming entre quaisquer duas sequ\u00eancias de sa\u00edda distintas.\n\n        Returns:\n            dist (int): Dist\u00e2ncia livre do c\u00f3digo.\n        \"\"\"\n        return self.komm.free_distance()\n\n    def encode(self, input_bits):\n        r\"\"\"\n        Codifica uma sequ\u00eancia bin\u00e1ria de entrada $u_t$ utilizando os registradores deslizantes e os taps.\n\n        Args:\n            input_bits (np.ndarray): Vetor de bits $u_t$ de entrada a serem codificados.\n\n        Returns:\n            tuple (np.ndarray, np.ndarray): Tupla com os dois canais de sa\u00edda $v_t^{(0)}$ e $v_t^{(1)}$.\n        \"\"\"\n        input_bits = np.array(input_bits, dtype=int)\n        vt0 = []\n        vt1 = []\n\n        for bit in input_bits:\n            self.shift_register = np.insert(self.shift_register, 0, bit)[:self.K]\n            out0 = np.sum(self.shift_register[self.g0_taps]) % 2\n            out1 = np.sum(self.shift_register[self.g1_taps]) % 2\n            vt0.append(out0)\n            vt1.append(out1)\n\n        return np.array(vt0, dtype=int), np.array(vt1, dtype=int)\n</code></pre>"},{"location":"api/convolutional/#convolutional.EncoderConvolutional.__init__","title":"<code>__init__(G=np.array([[121, 91]]))</code>","text":"<p>Inicializa o codificador convolucional com matriz de geradores.</p> Refer\u00eancia <ul> <li>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.4)</li> <li>CCSDS 131.1-G-2</li> </ul> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>ndarray</code> <p>Matriz de polin\u00f4mios geradores em formato bin\u00e1rio.</p> <code>array([[121, 91]])</code> Nota <ul> <li>O polin\u00f4mio gerador \\(G_0\\) \u00e9 representado por <code>G[0][0]</code> e \\(G_1\\) por <code>G[0][1]</code>.</li> <li>\\(G_0\\) \u00e9 definido como \\(1111001_{2}\\) ou \\(121_{10}\\)</li> <li>\\(G_1\\) \u00e9 definido como \\(1011011_{2}\\) ou \\(91_{10}\\)</li> </ul> Source code in <code>src/convolutional.py</code> <pre><code>def __init__(self, G=np.array([[0b1111001, 0b1011011]])):\n    r\"\"\"\n    Inicializa o codificador convolucional com matriz de geradores.\n\n    Refer\u00eancia:\n        - AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.4)\n        - CCSDS 131.1-G-2\n\n    Args:\n        G (np.ndarray): Matriz de polin\u00f4mios geradores em formato bin\u00e1rio.\n\n    Nota: \n        - O polin\u00f4mio gerador $G_0$ \u00e9 representado por `G[0][0]` e $G_1$ por `G[0][1]`.\n        - $G_0$ \u00e9 definido como $1111001_{2}$ ou $121_{10}$\n        - $G_1$ \u00e9 definido como $1011011_{2}$ ou $91_{10}$\n\n    \"\"\"\n    self.G = G\n    self.G0 = int(G[0][0])\n    self.G1 = int(G[0][1])\n    self.K = max(self.G0.bit_length(), self.G1.bit_length())\n    self.g0_taps = self.calc_taps(self.G0)\n    self.g1_taps = self.calc_taps(self.G1)\n    self.shift_register = np.zeros(self.K, dtype=int)\n    self.komm = komm.ConvolutionalCode(G)\n</code></pre>"},{"location":"api/convolutional/#convolutional.EncoderConvolutional.calc_taps","title":"<code>calc_taps(poly)</code>","text":"<p>Calcula os \u00edndices (\"taps\") dos bits ativos (ou seja, bits \\('1'\\)) no polin\u00f4mio gerador.</p> <p>Parameters:</p> Name Type Description Default <code>poly</code> <code>int</code> <p>Polin\u00f4mio em formato bin\u00e1rio. </p> required <p>Returns:</p> Name Type Description <code>taps</code> <code>int</code> <p>Lista com os \u00edndices dos taps ativos.</p> Source code in <code>src/convolutional.py</code> <pre><code>def calc_taps(self, poly):\n    r\"\"\"\n    Calcula os \u00edndices (\"taps\") dos bits ativos (ou seja, bits $'1'$) no polin\u00f4mio gerador.\n\n    Args:\n        poly (int): Polin\u00f4mio em formato bin\u00e1rio. \n\n    Returns:\n        taps (int): Lista com os \u00edndices dos taps ativos.\n    \"\"\"\n    bin_str = f\"{poly:0{self.K}b}\"\n    taps = [i for i, b in enumerate(bin_str) if b == '1']\n    return taps\n</code></pre>"},{"location":"api/convolutional/#convolutional.EncoderConvolutional.calc_free_distance","title":"<code>calc_free_distance()</code>","text":"<p>Calcula a dist\u00e2ncia livre do c\u00f3digo convolucional, definida como a menor dist\u00e2ncia de Hamming entre quaisquer duas sequ\u00eancias de sa\u00edda distintas.</p> <p>Returns:</p> Name Type Description <code>dist</code> <code>int</code> <p>Dist\u00e2ncia livre do c\u00f3digo.</p> Source code in <code>src/convolutional.py</code> <pre><code>def calc_free_distance(self):\n    r\"\"\"\n    Calcula a dist\u00e2ncia livre do c\u00f3digo convolucional, definida como a menor\n    dist\u00e2ncia de Hamming entre quaisquer duas sequ\u00eancias de sa\u00edda distintas.\n\n    Returns:\n        dist (int): Dist\u00e2ncia livre do c\u00f3digo.\n    \"\"\"\n    return self.komm.free_distance()\n</code></pre>"},{"location":"api/convolutional/#convolutional.EncoderConvolutional.encode","title":"<code>encode(input_bits)</code>","text":"<p>Codifica uma sequ\u00eancia bin\u00e1ria de entrada \\(u_t\\) utilizando os registradores deslizantes e os taps.</p> <p>Parameters:</p> Name Type Description Default <code>input_bits</code> <code>ndarray</code> <p>Vetor de bits \\(u_t\\) de entrada a serem codificados.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>(ndarray, ndarray)</code> <p>Tupla com os dois canais de sa\u00edda \\(v_t^{(0)}\\) e \\(v_t^{(1)}\\).</p> Source code in <code>src/convolutional.py</code> <pre><code>def encode(self, input_bits):\n    r\"\"\"\n    Codifica uma sequ\u00eancia bin\u00e1ria de entrada $u_t$ utilizando os registradores deslizantes e os taps.\n\n    Args:\n        input_bits (np.ndarray): Vetor de bits $u_t$ de entrada a serem codificados.\n\n    Returns:\n        tuple (np.ndarray, np.ndarray): Tupla com os dois canais de sa\u00edda $v_t^{(0)}$ e $v_t^{(1)}$.\n    \"\"\"\n    input_bits = np.array(input_bits, dtype=int)\n    vt0 = []\n    vt1 = []\n\n    for bit in input_bits:\n        self.shift_register = np.insert(self.shift_register, 0, bit)[:self.K]\n        out0 = np.sum(self.shift_register[self.g0_taps]) % 2\n        out1 = np.sum(self.shift_register[self.g1_taps]) % 2\n        vt0.append(out0)\n        vt1.append(out1)\n\n    return np.array(vt0, dtype=int), np.array(vt1, dtype=int)\n</code></pre>"},{"location":"api/convolutional/#convolutional-decoder-viterbi","title":"Convolutional Decoder (Viterbi)","text":"<p>Implementa o decodificador Viterbi, no padr\u00e3o CCSDS 131.1-G-2, utilizado no PTT-A3.</p> Refer\u00eancia <p>AS3-SP-516-274-CNES (3.1.4.4)</p> Source code in <code>src/convolutional.py</code> <pre><code>class DecoderViterbi:\n    r\"\"\"\n    Implementa o decodificador Viterbi, no padr\u00e3o CCSDS 131.1-G-2, utilizado no PTT-A3.\n\n    Refer\u00eancia:\n        AS3-SP-516-274-CNES (3.1.4.4)\n    \"\"\"\n    def __init__(self, G=np.array([[0b1111001, 0b1011011]])):\n        r\"\"\"\n        Inicializa o decodificador Convolucional.\n\n        Args:\n            G (np.ndarray): Matriz de polin\u00f4mios geradores.\n        \"\"\"\n        self.G = G\n        self.G0 = int(G[0][0])\n        self.G1 = int(G[0][1])\n        self.K = max(self.G0.bit_length(), self.G1.bit_length())\n        self.num_states = 2**(self.K - 1)\n        self.trellis = self.build_trellis()\n\n    def build_trellis(self):\n        r\"\"\"\n        Constroi a trelica do decodificador Viterbi.\n\n        Returns:\n            dict: Trelica do decodificador Viterbi.\n        \"\"\"\n        trellis = {}\n        for state in range(self.num_states):\n            trellis[state] = {}\n            for bit in [0, 1]:\n                # reconstruir o shift register (bit atual + estado anterior)\n                sr = [bit] + [int(b) for b in format(state, f'0{self.K - 1}b')]\n                out0 = sum([sr[i] for i in range(self.K) if (self.G0 &gt;&gt; (self.K - 1 - i)) &amp; 1]) % 2\n                out1 = sum([sr[i] for i in range(self.K) if (self.G1 &gt;&gt; (self.K - 1 - i)) &amp; 1]) % 2\n                out = [out0, out1]\n\n                # remove \u00faltimo bit para pr\u00f3ximo estado\n                next_state = int(''.join(str(b) for b in sr[:-1]), 2)  \n                trellis[state][bit] = (next_state, out)\n        return trellis\n\n    def decode(self, vt0, vt1):\n        r\"\"\"\n        Decodifica os bits de entrada.\n\n        Args:\n            vt0 (np.ndarray): Bits de entrada do canal I.\n            vt1 (np.ndarray): Bits de entrada do canal Q.\n\n        Returns:\n            np.ndarray: Bits decodificados.\n        \"\"\"\n        vt0 = np.array(vt0, dtype=int)\n        vt1 = np.array(vt1, dtype=int)\n        T = len(vt0)\n\n        # Inicializar m\u00e9tricas\n        path_metrics = np.full((T + 1, self.num_states), np.inf)\n        path_metrics[0][0] = 0\n        prev_state = np.full((T + 1, self.num_states), -1, dtype=int)\n        prev_input = np.full((T + 1, self.num_states), -1, dtype=int)\n\n        # Viterbi\n        for t in range(T):\n            for state in range(self.num_states):\n                if path_metrics[t, state] &lt; np.inf:\n                    for bit in [0, 1]:\n                        next_state, expected_out = self.trellis[state][bit]\n                        dist = (expected_out[0] != vt0[t]) + (expected_out[1] != vt1[t])\n                        metric = path_metrics[t, state] + dist\n                        if metric &lt; path_metrics[t + 1, next_state]:\n                            path_metrics[t + 1, next_state] = metric\n                            prev_state[t + 1, next_state] = state\n                            prev_input[t + 1, next_state] = bit\n\n        # Traceback\n        state = np.argmin(path_metrics[T])\n        ut_hat = []\n        for t in range(T, 0, -1):\n            bit = prev_input[t, state]\n            ut_hat.append(bit)\n            state = prev_state[t, state]\n\n        return np.array(ut_hat[::-1], dtype=int)\n</code></pre>"},{"location":"api/convolutional/#convolutional.DecoderViterbi.__init__","title":"<code>__init__(G=np.array([[121, 91]]))</code>","text":"<p>Inicializa o decodificador Convolucional.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>ndarray</code> <p>Matriz de polin\u00f4mios geradores.</p> <code>array([[121, 91]])</code> Source code in <code>src/convolutional.py</code> <pre><code>def __init__(self, G=np.array([[0b1111001, 0b1011011]])):\n    r\"\"\"\n    Inicializa o decodificador Convolucional.\n\n    Args:\n        G (np.ndarray): Matriz de polin\u00f4mios geradores.\n    \"\"\"\n    self.G = G\n    self.G0 = int(G[0][0])\n    self.G1 = int(G[0][1])\n    self.K = max(self.G0.bit_length(), self.G1.bit_length())\n    self.num_states = 2**(self.K - 1)\n    self.trellis = self.build_trellis()\n</code></pre>"},{"location":"api/convolutional/#convolutional.DecoderViterbi.build_trellis","title":"<code>build_trellis()</code>","text":"<p>Constroi a trelica do decodificador Viterbi.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Trelica do decodificador Viterbi.</p> Source code in <code>src/convolutional.py</code> <pre><code>def build_trellis(self):\n    r\"\"\"\n    Constroi a trelica do decodificador Viterbi.\n\n    Returns:\n        dict: Trelica do decodificador Viterbi.\n    \"\"\"\n    trellis = {}\n    for state in range(self.num_states):\n        trellis[state] = {}\n        for bit in [0, 1]:\n            # reconstruir o shift register (bit atual + estado anterior)\n            sr = [bit] + [int(b) for b in format(state, f'0{self.K - 1}b')]\n            out0 = sum([sr[i] for i in range(self.K) if (self.G0 &gt;&gt; (self.K - 1 - i)) &amp; 1]) % 2\n            out1 = sum([sr[i] for i in range(self.K) if (self.G1 &gt;&gt; (self.K - 1 - i)) &amp; 1]) % 2\n            out = [out0, out1]\n\n            # remove \u00faltimo bit para pr\u00f3ximo estado\n            next_state = int(''.join(str(b) for b in sr[:-1]), 2)  \n            trellis[state][bit] = (next_state, out)\n    return trellis\n</code></pre>"},{"location":"api/convolutional/#convolutional.DecoderViterbi.decode","title":"<code>decode(vt0, vt1)</code>","text":"<p>Decodifica os bits de entrada.</p> <p>Parameters:</p> Name Type Description Default <code>vt0</code> <code>ndarray</code> <p>Bits de entrada do canal I.</p> required <code>vt1</code> <code>ndarray</code> <p>Bits de entrada do canal Q.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Bits decodificados.</p> Source code in <code>src/convolutional.py</code> <pre><code>def decode(self, vt0, vt1):\n    r\"\"\"\n    Decodifica os bits de entrada.\n\n    Args:\n        vt0 (np.ndarray): Bits de entrada do canal I.\n        vt1 (np.ndarray): Bits de entrada do canal Q.\n\n    Returns:\n        np.ndarray: Bits decodificados.\n    \"\"\"\n    vt0 = np.array(vt0, dtype=int)\n    vt1 = np.array(vt1, dtype=int)\n    T = len(vt0)\n\n    # Inicializar m\u00e9tricas\n    path_metrics = np.full((T + 1, self.num_states), np.inf)\n    path_metrics[0][0] = 0\n    prev_state = np.full((T + 1, self.num_states), -1, dtype=int)\n    prev_input = np.full((T + 1, self.num_states), -1, dtype=int)\n\n    # Viterbi\n    for t in range(T):\n        for state in range(self.num_states):\n            if path_metrics[t, state] &lt; np.inf:\n                for bit in [0, 1]:\n                    next_state, expected_out = self.trellis[state][bit]\n                    dist = (expected_out[0] != vt0[t]) + (expected_out[1] != vt1[t])\n                    metric = path_metrics[t, state] + dist\n                    if metric &lt; path_metrics[t + 1, next_state]:\n                        path_metrics[t + 1, next_state] = metric\n                        prev_state[t + 1, next_state] = state\n                        prev_input[t + 1, next_state] = bit\n\n    # Traceback\n    state = np.argmin(path_metrics[T])\n    ut_hat = []\n    for t in range(T, 0, -1):\n        bit = prev_input[t, state]\n        ut_hat.append(bit)\n        state = prev_state[t, state]\n\n    return np.array(ut_hat[::-1], dtype=int)\n</code></pre>"},{"location":"api/datagram/","title":"Datagram","text":"Source code in <code>src/datagram.py</code> <pre><code>class Datagram: \n    def __init__(self, pcdnum=None, numblocks=None, streambits=None):\n        r\"\"\"\n        Inicializa uma inst\u00e2ncia do datagrama.\n\n        Refer\u00eancia:\n            AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4).\n\n        Args:\n            pcdnum (int): N\u00famero identificador da PCD. Necess\u00e1rio para o modo TX.\n            numblocks (int): Quantidade de blocos de dados (1 a 8). Necess\u00e1rio para o modo TX.\n            streambits (np.ndarray): Sequ\u00eancia de bits do datagrama. Necess\u00e1rio para o modo RX.\n\n        Raises:\n            ValueError: Se o n\u00famero de blocos n\u00e3o estiver entre 1 e 8.\n            ValueError: Se o n\u00famero PCD n\u00e3o estiver entre 0 e 1048575 $(2^{20} - 1)$.\n            ValueError: Se os par\u00e2metros `pcdnum` e `numblocks` ou `streambits` n\u00e3o forem fornecidos.\n\n        \"\"\"\n\n        # construtor TX\n        if pcdnum is not None and numblocks is not None:\n            if not (1 &lt;= numblocks &lt;= 8):\n                raise ValueError(\"O n\u00famero de blocos deve estar entre 1 e 8.\")\n            if not (0 &lt;= pcdnum &lt;= 1048575):  # 2^20 - 1\n                raise ValueError(\"O n\u00famero PCD deve estar entre 0 e 1048575.\")\n\n            self.pcdnum = pcdnum\n            self.numblocks = numblocks\n            self.blocks = self.generate_blocks()\n            self.pcdid = self.generate_pcdid()\n            self.tail = self.generate_tail()\n            self.msglength = self.generate_msglength()\n            self.streambits = np.concatenate((self.msglength, self.pcdid, self.blocks, self.tail))\n            self.blocks_json = self.parse_datagram()\n\n        # construtor RX  \n        elif streambits is not None:\n            self.streambits = streambits\n            self.blocks_json = self.parse_datagram()\n        else:\n            raise ValueError(\"Voc\u00ea deve fornecer ou (pcdnum e numblocks) ou streambits\")\n\n    def generate_blocks(self):\n        r\"\"\"\n        Gera os blocos de dados simulados (valores aleat\u00f3rios), com base na quantidade especificada de blocos.\n\n        Refer\u00eancia:\n            AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.2)\n\n        Returns:\n            blocks (np.ndarray): Vetor de bits representando os blocos de dados.\n        \"\"\"\n\n        length = [24] + [32] * (self.numblocks - 1)\n        total_length = sum(length)\n        return np.random.randint(0, 2, size=total_length, dtype=np.uint8)\n\n    def generate_pcdid(self):\n        r\"\"\"\n        Gera o campo PCD ID a partir do n\u00famero PCD, incluindo um checksum de 8 bits.\n\n        Refer\u00eancia:\n            AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.2)\n\n        Returns:\n            pcd_id (np.ndarray): Vetor de bits contendo o PCD ID e o checksum.\n        \"\"\"\n\n        bin_str = format(self.pcdnum, '020b')\n        pcd_bits = np.array([int(b) for b in bin_str], dtype=np.uint8)\n\n        checksum_val = pcd_bits.sum() % 256\n        checksum_bits = np.array([int(b) for b in format(checksum_val, '08b')], dtype=np.uint8)\n        return np.concatenate((pcd_bits, checksum_bits))\n\n    def generate_msglength(self):\n        r\"\"\"\n        Gera o campo Message Length com base na quantidade de blocos e calcula o bit de paridade.\n\n        Refer\u00eancia:\n            AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.2)\n\n        Returns:\n           msg_length (np.ndarray): Vetor de 4 bits representando o campo Message Length.\n        \"\"\"\n\n        n = self.numblocks - 1\n        bin_str = format(n, '03b')\n        bits = np.array([int(b) for b in bin_str], dtype=np.uint8)\n        paridade = bits.sum() % 2\n        return np.append(bits, paridade)\n\n    def generate_tail(self):\n        r\"\"\"\n        Gera o campo Tail (cauda), utilizado para esvaziar o registrador do codificador convolucional.\n\n        Refer\u00eancia:\n            AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.3)\n\n        Returns:\n            tail (np.ndarray): Vetor de bits zerados com comprimento vari\u00e1vel (7, 8 ou 9 bits).\n        \"\"\"\n\n        tail_pad = [7, 8, 9]\n        tail_length = tail_pad[(self.numblocks - 1) % 3]\n        return np.zeros(tail_length, dtype=np.uint8)\n\n    def parse_datagram(self):\n        r\"\"\"\n        Faz o parsing da sequ\u00eancia de bits do datagrama, extraindo campos e validando integridade.\n\n        Returns:\n            str (json): Objeto JSON contendo a representa\u00e7\u00e3o estruturada do datagrama.\n\n        Raises:\n            ValueError: Caso haja falha nas valida\u00e7\u00f5es de paridade de Message Length.\n            ValueError: Caso haja falha no checksum do campo PCD ID.\n            ValueError: Se a sequ\u00eancia de bits n\u00e3o for v\u00e1lida ou n\u00e3o puder ser convertida para json.\n\n        Examples:\n\n                &gt;&gt;&gt; datagram = Datagram(streambits=bits)\n                &gt;&gt;&gt; print(datagram.parse_datagram())\n                    {\n                      \"msglength\": 2,\n                      \"pcdid\": 1234,\n                      \"data\": {\n                        \"bloco_1\": {\n                          \"sensor_1\": 42,\n                          \"sensor_2\": 147,\n                          \"sensor_3\": 75\n                        },\n                        \"bloco_2\": {\n                          \"sensor_1\": 138,\n                          \"sensor_2\": 7,\n                          \"sensor_3\": 134,\n                          \"sensor_4\": 182\n                        }\n                      },\n                      \"tail\": 8\n                    }\n        \"\"\"\n\n        msglength_bits = self.streambits[:4]\n        value_bits = msglength_bits[:3]\n        paridade_bit = msglength_bits[3]\n\n        if paridade_bit != value_bits.sum() % 2:\n            raise ValueError(\"Paridade inv\u00e1lida no campo Message Length.\")\n\n        numblocks = int(\"\".join(map(str, value_bits)), 2) + 1\n        pcdid_bits = self.streambits[4:32]\n\n        pcdnum_bits = pcdid_bits[:20]\n        checksum_bits = pcdid_bits[20:28]\n        checksum_val = pcdnum_bits.sum() % 256\n        if checksum_val != int(\"\".join(map(str, checksum_bits)), 2):\n            raise ValueError(\"Checksum inv\u00e1lido no campo PCD ID.\")\n        pcdnum = int(\"\".join(map(str, pcdnum_bits)), 2)\n\n        data_bits = self.streambits[32:32 + 24 + (32 * (numblocks - 1))]\n        tail_bits = self.streambits[32 + 24 + (32 * (numblocks - 1)):]\n        tail_length = len(tail_bits)\n        data = {\n            \"msglength\": numblocks,\n            \"pcdid\": pcdnum,\n            \"data\": {},\n            \"tail\": tail_length\n        }\n\n        index = 0\n        for bloco in range(numblocks):\n            bloco_nome = f\"bloco_{bloco+1}\"\n            data[\"data\"][bloco_nome] = {}\n\n            num_sensores = 3 if bloco == 0 else 4\n            for sensor in range(num_sensores):\n                sensor_nome = f\"sensor_{sensor+1}\"\n                sensor_bits = data_bits[index:index+8]\n                sensor_valor = int(\"\".join(map(str, sensor_bits)), 2)\n                data[\"data\"][bloco_nome][sensor_nome] = sensor_valor\n                index += 8\n\n        return json.dumps(data, indent=2)\n</code></pre>"},{"location":"api/datagram/#datagram.Datagram.__init__","title":"<code>__init__(pcdnum=None, numblocks=None, streambits=None)</code>","text":"<p>Inicializa uma inst\u00e2ncia do datagrama.</p> Refer\u00eancia <p>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4).</p> <p>Parameters:</p> Name Type Description Default <code>pcdnum</code> <code>int</code> <p>N\u00famero identificador da PCD. Necess\u00e1rio para o modo TX.</p> <code>None</code> <code>numblocks</code> <code>int</code> <p>Quantidade de blocos de dados (1 a 8). Necess\u00e1rio para o modo TX.</p> <code>None</code> <code>streambits</code> <code>ndarray</code> <p>Sequ\u00eancia de bits do datagrama. Necess\u00e1rio para o modo RX.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se o n\u00famero de blocos n\u00e3o estiver entre 1 e 8.</p> <code>ValueError</code> <p>Se o n\u00famero PCD n\u00e3o estiver entre 0 e 1048575 \\((2^{20} - 1)\\).</p> <code>ValueError</code> <p>Se os par\u00e2metros <code>pcdnum</code> e <code>numblocks</code> ou <code>streambits</code> n\u00e3o forem fornecidos.</p> Source code in <code>src/datagram.py</code> <pre><code>def __init__(self, pcdnum=None, numblocks=None, streambits=None):\n    r\"\"\"\n    Inicializa uma inst\u00e2ncia do datagrama.\n\n    Refer\u00eancia:\n        AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4).\n\n    Args:\n        pcdnum (int): N\u00famero identificador da PCD. Necess\u00e1rio para o modo TX.\n        numblocks (int): Quantidade de blocos de dados (1 a 8). Necess\u00e1rio para o modo TX.\n        streambits (np.ndarray): Sequ\u00eancia de bits do datagrama. Necess\u00e1rio para o modo RX.\n\n    Raises:\n        ValueError: Se o n\u00famero de blocos n\u00e3o estiver entre 1 e 8.\n        ValueError: Se o n\u00famero PCD n\u00e3o estiver entre 0 e 1048575 $(2^{20} - 1)$.\n        ValueError: Se os par\u00e2metros `pcdnum` e `numblocks` ou `streambits` n\u00e3o forem fornecidos.\n\n    \"\"\"\n\n    # construtor TX\n    if pcdnum is not None and numblocks is not None:\n        if not (1 &lt;= numblocks &lt;= 8):\n            raise ValueError(\"O n\u00famero de blocos deve estar entre 1 e 8.\")\n        if not (0 &lt;= pcdnum &lt;= 1048575):  # 2^20 - 1\n            raise ValueError(\"O n\u00famero PCD deve estar entre 0 e 1048575.\")\n\n        self.pcdnum = pcdnum\n        self.numblocks = numblocks\n        self.blocks = self.generate_blocks()\n        self.pcdid = self.generate_pcdid()\n        self.tail = self.generate_tail()\n        self.msglength = self.generate_msglength()\n        self.streambits = np.concatenate((self.msglength, self.pcdid, self.blocks, self.tail))\n        self.blocks_json = self.parse_datagram()\n\n    # construtor RX  \n    elif streambits is not None:\n        self.streambits = streambits\n        self.blocks_json = self.parse_datagram()\n    else:\n        raise ValueError(\"Voc\u00ea deve fornecer ou (pcdnum e numblocks) ou streambits\")\n</code></pre>"},{"location":"api/datagram/#datagram.Datagram.generate_blocks","title":"<code>generate_blocks()</code>","text":"<p>Gera os blocos de dados simulados (valores aleat\u00f3rios), com base na quantidade especificada de blocos.</p> Refer\u00eancia <p>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.2)</p> <p>Returns:</p> Name Type Description <code>blocks</code> <code>ndarray</code> <p>Vetor de bits representando os blocos de dados.</p> Source code in <code>src/datagram.py</code> <pre><code>def generate_blocks(self):\n    r\"\"\"\n    Gera os blocos de dados simulados (valores aleat\u00f3rios), com base na quantidade especificada de blocos.\n\n    Refer\u00eancia:\n        AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.2)\n\n    Returns:\n        blocks (np.ndarray): Vetor de bits representando os blocos de dados.\n    \"\"\"\n\n    length = [24] + [32] * (self.numblocks - 1)\n    total_length = sum(length)\n    return np.random.randint(0, 2, size=total_length, dtype=np.uint8)\n</code></pre>"},{"location":"api/datagram/#datagram.Datagram.generate_pcdid","title":"<code>generate_pcdid()</code>","text":"<p>Gera o campo PCD ID a partir do n\u00famero PCD, incluindo um checksum de 8 bits.</p> Refer\u00eancia <p>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.2)</p> <p>Returns:</p> Name Type Description <code>pcd_id</code> <code>ndarray</code> <p>Vetor de bits contendo o PCD ID e o checksum.</p> Source code in <code>src/datagram.py</code> <pre><code>def generate_pcdid(self):\n    r\"\"\"\n    Gera o campo PCD ID a partir do n\u00famero PCD, incluindo um checksum de 8 bits.\n\n    Refer\u00eancia:\n        AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.2)\n\n    Returns:\n        pcd_id (np.ndarray): Vetor de bits contendo o PCD ID e o checksum.\n    \"\"\"\n\n    bin_str = format(self.pcdnum, '020b')\n    pcd_bits = np.array([int(b) for b in bin_str], dtype=np.uint8)\n\n    checksum_val = pcd_bits.sum() % 256\n    checksum_bits = np.array([int(b) for b in format(checksum_val, '08b')], dtype=np.uint8)\n    return np.concatenate((pcd_bits, checksum_bits))\n</code></pre>"},{"location":"api/datagram/#datagram.Datagram.generate_msglength","title":"<code>generate_msglength()</code>","text":"<p>Gera o campo Message Length com base na quantidade de blocos e calcula o bit de paridade.</p> Refer\u00eancia <p>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.2)</p> <p>Returns:</p> Name Type Description <code>msg_length</code> <code>ndarray</code> <p>Vetor de 4 bits representando o campo Message Length.</p> Source code in <code>src/datagram.py</code> <pre><code>def generate_msglength(self):\n    r\"\"\"\n    Gera o campo Message Length com base na quantidade de blocos e calcula o bit de paridade.\n\n    Refer\u00eancia:\n        AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.2)\n\n    Returns:\n       msg_length (np.ndarray): Vetor de 4 bits representando o campo Message Length.\n    \"\"\"\n\n    n = self.numblocks - 1\n    bin_str = format(n, '03b')\n    bits = np.array([int(b) for b in bin_str], dtype=np.uint8)\n    paridade = bits.sum() % 2\n    return np.append(bits, paridade)\n</code></pre>"},{"location":"api/datagram/#datagram.Datagram.generate_tail","title":"<code>generate_tail()</code>","text":"<p>Gera o campo Tail (cauda), utilizado para esvaziar o registrador do codificador convolucional.</p> Refer\u00eancia <p>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.3)</p> <p>Returns:</p> Name Type Description <code>tail</code> <code>ndarray</code> <p>Vetor de bits zerados com comprimento vari\u00e1vel (7, 8 ou 9 bits).</p> Source code in <code>src/datagram.py</code> <pre><code>def generate_tail(self):\n    r\"\"\"\n    Gera o campo Tail (cauda), utilizado para esvaziar o registrador do codificador convolucional.\n\n    Refer\u00eancia:\n        AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.3)\n\n    Returns:\n        tail (np.ndarray): Vetor de bits zerados com comprimento vari\u00e1vel (7, 8 ou 9 bits).\n    \"\"\"\n\n    tail_pad = [7, 8, 9]\n    tail_length = tail_pad[(self.numblocks - 1) % 3]\n    return np.zeros(tail_length, dtype=np.uint8)\n</code></pre>"},{"location":"api/datagram/#datagram.Datagram.parse_datagram","title":"<code>parse_datagram()</code>","text":"<p>Faz o parsing da sequ\u00eancia de bits do datagrama, extraindo campos e validando integridade.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>json</code> <p>Objeto JSON contendo a representa\u00e7\u00e3o estruturada do datagrama.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Caso haja falha nas valida\u00e7\u00f5es de paridade de Message Length.</p> <code>ValueError</code> <p>Caso haja falha no checksum do campo PCD ID.</p> <code>ValueError</code> <p>Se a sequ\u00eancia de bits n\u00e3o for v\u00e1lida ou n\u00e3o puder ser convertida para json.</p> <p>Examples:</p> <pre><code>    &gt;&gt;&gt; datagram = Datagram(streambits=bits)\n    &gt;&gt;&gt; print(datagram.parse_datagram())\n        {\n          \"msglength\": 2,\n          \"pcdid\": 1234,\n          \"data\": {\n            \"bloco_1\": {\n              \"sensor_1\": 42,\n              \"sensor_2\": 147,\n              \"sensor_3\": 75\n            },\n            \"bloco_2\": {\n              \"sensor_1\": 138,\n              \"sensor_2\": 7,\n              \"sensor_3\": 134,\n              \"sensor_4\": 182\n            }\n          },\n          \"tail\": 8\n        }\n</code></pre> Source code in <code>src/datagram.py</code> <pre><code>def parse_datagram(self):\n    r\"\"\"\n    Faz o parsing da sequ\u00eancia de bits do datagrama, extraindo campos e validando integridade.\n\n    Returns:\n        str (json): Objeto JSON contendo a representa\u00e7\u00e3o estruturada do datagrama.\n\n    Raises:\n        ValueError: Caso haja falha nas valida\u00e7\u00f5es de paridade de Message Length.\n        ValueError: Caso haja falha no checksum do campo PCD ID.\n        ValueError: Se a sequ\u00eancia de bits n\u00e3o for v\u00e1lida ou n\u00e3o puder ser convertida para json.\n\n    Examples:\n\n            &gt;&gt;&gt; datagram = Datagram(streambits=bits)\n            &gt;&gt;&gt; print(datagram.parse_datagram())\n                {\n                  \"msglength\": 2,\n                  \"pcdid\": 1234,\n                  \"data\": {\n                    \"bloco_1\": {\n                      \"sensor_1\": 42,\n                      \"sensor_2\": 147,\n                      \"sensor_3\": 75\n                    },\n                    \"bloco_2\": {\n                      \"sensor_1\": 138,\n                      \"sensor_2\": 7,\n                      \"sensor_3\": 134,\n                      \"sensor_4\": 182\n                    }\n                  },\n                  \"tail\": 8\n                }\n    \"\"\"\n\n    msglength_bits = self.streambits[:4]\n    value_bits = msglength_bits[:3]\n    paridade_bit = msglength_bits[3]\n\n    if paridade_bit != value_bits.sum() % 2:\n        raise ValueError(\"Paridade inv\u00e1lida no campo Message Length.\")\n\n    numblocks = int(\"\".join(map(str, value_bits)), 2) + 1\n    pcdid_bits = self.streambits[4:32]\n\n    pcdnum_bits = pcdid_bits[:20]\n    checksum_bits = pcdid_bits[20:28]\n    checksum_val = pcdnum_bits.sum() % 256\n    if checksum_val != int(\"\".join(map(str, checksum_bits)), 2):\n        raise ValueError(\"Checksum inv\u00e1lido no campo PCD ID.\")\n    pcdnum = int(\"\".join(map(str, pcdnum_bits)), 2)\n\n    data_bits = self.streambits[32:32 + 24 + (32 * (numblocks - 1))]\n    tail_bits = self.streambits[32 + 24 + (32 * (numblocks - 1)):]\n    tail_length = len(tail_bits)\n    data = {\n        \"msglength\": numblocks,\n        \"pcdid\": pcdnum,\n        \"data\": {},\n        \"tail\": tail_length\n    }\n\n    index = 0\n    for bloco in range(numblocks):\n        bloco_nome = f\"bloco_{bloco+1}\"\n        data[\"data\"][bloco_nome] = {}\n\n        num_sensores = 3 if bloco == 0 else 4\n        for sensor in range(num_sensores):\n            sensor_nome = f\"sensor_{sensor+1}\"\n            sensor_bits = data_bits[index:index+8]\n            sensor_valor = int(\"\".join(map(str, sensor_bits)), 2)\n            data[\"data\"][bloco_nome][sensor_nome] = sensor_valor\n            index += 8\n\n    return json.dumps(data, indent=2)\n</code></pre>"},{"location":"api/encoder/","title":"Encoder","text":"Source code in <code>src/encoder.py</code> <pre><code>class Encoder:\n    def __init__(self, method):\n        r\"\"\"\n        Inicializa uma inst\u00e2ncia do codificador com o m\u00e9todo especificado.\n\n        Refer\u00eancia:\n            AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.2.4)\n\n        Args:\n            method (str): M\u00e9todo de codifica\u00e7\u00e3o ('NRZ' ou 'Manchester').\n\n        Raises:\n            ValueError: Se o m\u00e9todo de codifica\u00e7\u00e3o n\u00e3o for suportado.\n        \"\"\"\n        method_map = {\n            \"nrz\": 0,\n            \"manchester\": 1\n        }\n\n        method = method.lower()\n        if method not in method_map:\n            raise ValueError(\"M\u00e9todo de codifica\u00e7\u00e3o inv\u00e1lido. Use 'NRZ' ou 'Manchester'.\")\n\n        self.method = method_map[method]\n\n    def encode(self, bitstream):\n        r\"\"\"\n        Codifica o vetor de bits usando o m\u00e9todo especificado na inicializa\u00e7\u00e3o.\n\n        Args:\n            bitstream (np.ndarray): Vetor de bits a ser codificado.\n\n        Returns:\n            out (np.ndarray): Vetor de bits codificado.\n        \"\"\"\n        out = np.empty(bitstream.size * 2, dtype=int)\n\n        if self.method == 0:  # NRZ\n            for i, bit in enumerate(bitstream):\n                if bit == 0:\n                    out[2*i] = 0\n                    out[2*i + 1] = 0\n                elif bit == 1:\n                    out[2*i] = 1\n                    out[2*i + 1] = 1\n\n        elif self.method == 1:  # Manchester\n            for i, bit in enumerate(bitstream):\n                if bit == 0:\n                    out[2*i] = 0\n                    out[2*i + 1] = 1\n                elif bit == 1:\n                    out[2*i] = 1\n                    out[2*i + 1] = 0\n\n        else:\n            raise ValueError(f\"M\u00e9todo de codifica\u00e7\u00e3o n\u00e3o implementado: {self.method}\")\n\n        return out\n\n\n    def decode(self, encoded_stream):\n        r\"\"\"\n        Decodifica o vetor codificado de volta para o vetor original.\n\n        Args:\n            encoded_stream (np.ndarray): Vetor codificado a ser decodificado.\n\n        Returns:\n            out (np.ndarray): Vetor de bits decodificado.\n\n        \"\"\"\n        if encoded_stream.size % 2 != 0:\n            raise ValueError(\"Tamanho do vetor codificado inv\u00e1lido. Deve ser m\u00faltiplo de 2.\")\n\n        n = encoded_stream.size // 2\n        decoded = np.empty(n, dtype=int)\n\n        if self.method == 0:  # NRZ\n            for i in range(n):\n                pair = encoded_stream[2*i:2*i + 2]\n                if np.array_equal(pair, [0, 0]):\n                    decoded[i] = 0\n                else:\n                    decoded[i] = 1\n\n\n        elif self.method == 1:  # Manchester\n            for i in range(n):\n                pair = encoded_stream[2*i:2*i + 2]\n                if np.array_equal(pair, [0, 1]):\n                    decoded[i] = 0\n                else:\n                    decoded[i] = 1\n\n        else:\n            raise ValueError(f\"M\u00e9todo de decodifica\u00e7\u00e3o n\u00e3o implementado: {self.method}\")\n\n        return decoded\n</code></pre>"},{"location":"api/encoder/#encoder.Encoder.__init__","title":"<code>__init__(method)</code>","text":"<p>Inicializa uma inst\u00e2ncia do codificador com o m\u00e9todo especificado.</p> Refer\u00eancia <p>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.2.4)</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>M\u00e9todo de codifica\u00e7\u00e3o ('NRZ' ou 'Manchester').</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Se o m\u00e9todo de codifica\u00e7\u00e3o n\u00e3o for suportado.</p> Source code in <code>src/encoder.py</code> <pre><code>def __init__(self, method):\n    r\"\"\"\n    Inicializa uma inst\u00e2ncia do codificador com o m\u00e9todo especificado.\n\n    Refer\u00eancia:\n        AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.2.4)\n\n    Args:\n        method (str): M\u00e9todo de codifica\u00e7\u00e3o ('NRZ' ou 'Manchester').\n\n    Raises:\n        ValueError: Se o m\u00e9todo de codifica\u00e7\u00e3o n\u00e3o for suportado.\n    \"\"\"\n    method_map = {\n        \"nrz\": 0,\n        \"manchester\": 1\n    }\n\n    method = method.lower()\n    if method not in method_map:\n        raise ValueError(\"M\u00e9todo de codifica\u00e7\u00e3o inv\u00e1lido. Use 'NRZ' ou 'Manchester'.\")\n\n    self.method = method_map[method]\n</code></pre>"},{"location":"api/encoder/#encoder.Encoder.encode","title":"<code>encode(bitstream)</code>","text":"<p>Codifica o vetor de bits usando o m\u00e9todo especificado na inicializa\u00e7\u00e3o.</p> <p>Parameters:</p> Name Type Description Default <code>bitstream</code> <code>ndarray</code> <p>Vetor de bits a ser codificado.</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>ndarray</code> <p>Vetor de bits codificado.</p> Source code in <code>src/encoder.py</code> <pre><code>def encode(self, bitstream):\n    r\"\"\"\n    Codifica o vetor de bits usando o m\u00e9todo especificado na inicializa\u00e7\u00e3o.\n\n    Args:\n        bitstream (np.ndarray): Vetor de bits a ser codificado.\n\n    Returns:\n        out (np.ndarray): Vetor de bits codificado.\n    \"\"\"\n    out = np.empty(bitstream.size * 2, dtype=int)\n\n    if self.method == 0:  # NRZ\n        for i, bit in enumerate(bitstream):\n            if bit == 0:\n                out[2*i] = 0\n                out[2*i + 1] = 0\n            elif bit == 1:\n                out[2*i] = 1\n                out[2*i + 1] = 1\n\n    elif self.method == 1:  # Manchester\n        for i, bit in enumerate(bitstream):\n            if bit == 0:\n                out[2*i] = 0\n                out[2*i + 1] = 1\n            elif bit == 1:\n                out[2*i] = 1\n                out[2*i + 1] = 0\n\n    else:\n        raise ValueError(f\"M\u00e9todo de codifica\u00e7\u00e3o n\u00e3o implementado: {self.method}\")\n\n    return out\n</code></pre>"},{"location":"api/encoder/#encoder.Encoder.decode","title":"<code>decode(encoded_stream)</code>","text":"<p>Decodifica o vetor codificado de volta para o vetor original.</p> <p>Parameters:</p> Name Type Description Default <code>encoded_stream</code> <code>ndarray</code> <p>Vetor codificado a ser decodificado.</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>ndarray</code> <p>Vetor de bits decodificado.</p> Source code in <code>src/encoder.py</code> <pre><code>def decode(self, encoded_stream):\n    r\"\"\"\n    Decodifica o vetor codificado de volta para o vetor original.\n\n    Args:\n        encoded_stream (np.ndarray): Vetor codificado a ser decodificado.\n\n    Returns:\n        out (np.ndarray): Vetor de bits decodificado.\n\n    \"\"\"\n    if encoded_stream.size % 2 != 0:\n        raise ValueError(\"Tamanho do vetor codificado inv\u00e1lido. Deve ser m\u00faltiplo de 2.\")\n\n    n = encoded_stream.size // 2\n    decoded = np.empty(n, dtype=int)\n\n    if self.method == 0:  # NRZ\n        for i in range(n):\n            pair = encoded_stream[2*i:2*i + 2]\n            if np.array_equal(pair, [0, 0]):\n                decoded[i] = 0\n            else:\n                decoded[i] = 1\n\n\n    elif self.method == 1:  # Manchester\n        for i in range(n):\n            pair = encoded_stream[2*i:2*i + 2]\n            if np.array_equal(pair, [0, 1]):\n                decoded[i] = 0\n            else:\n                decoded[i] = 1\n\n    else:\n        raise ValueError(f\"M\u00e9todo de decodifica\u00e7\u00e3o n\u00e3o implementado: {self.method}\")\n\n    return decoded\n</code></pre>"},{"location":"api/formatter/","title":"Formatter","text":"Source code in <code>src/formatter.py</code> <pre><code>class Formatter:\n    def __init__(self, alpha=0.8, fs=128_000, Rb=400, span=6, type=\"RRC\"):\n        r\"\"\"\n        Inicializa uma inst\u00e2ncia de formatador de pulso. O pulso formatador \u00e9 usado para preparar os s\u00edmbolos nos canais I e Q para transmiss\u00e3o.\n\n        Args:\n            alpha (float): Fator de roll-off do pulso RRC.\n            fs (int): Frequ\u00eancia de amostragem.\n            Rb (int): Taxa de bits.\n            span (int): Dura\u00e7\u00e3o do pulso em termos de per\u00edodos de bit.\n            type (str): Tipo de pulso, atualmente apenas \"RRC\" \u00e9 suportado.\n\n        Raises:\n            ValueError: Se o tipo de pulso n\u00e3o for suportado.\n        \"\"\"\n        self.alpha = alpha\n        self.fs = fs\n        self.Rb = Rb\n        self.Tb = 1 / Rb\n        self.sps = int(fs / Rb)\n        self.span = span\n        self.t_rc = np.linspace(-span * self.Tb, span * self.Tb, span * self.sps * 2)\n\n        type_map = {\n            \"rrc\": 0\n        }\n\n        type = type.lower()\n        if type not in type_map:\n            raise ValueError(\"Tipo de pulso inv\u00e1lido. Use 'RRC'.\")\n\n        self.type = type_map[type]\n\n        if self.type == 0:  # RRC\n            self.g = self.rrc_pulse()\n\n    def rrc_pulse(self):\n        r\"\"\"\n        Gera o pulso Root Raised Cosine (RRC) para a transmiss\u00e3o de sinais digitais. O pulso RRC \u00e9 definido como:\n        $$\n        \\begin{equation}\n            g(t) = \\frac{\\sin(\\pi \\frac{t}{T_b})}{\\pi \\frac{t}{T_b}} \\cdot \\frac{\\cos(\\pi \\alpha \\frac{t}{T_b})}{1 - (2\\alpha \\frac{t}{T_b})^2}\n        \\end{equation}\n        $$\n\n        Nota:\n            - $g(t)$ \u00e9 o pulso formatador,\n            - $\\alpha$ \u00e9 o fator de roll-off, \n            - $T_b$ \u00e9 o per\u00edodo de bit, \n            - $t$ \u00e9 o tempo.\n\n        Args:\n            None\n\n        Returns:\n           rc (np.ndarray): Pulso RRC.\n        \"\"\"\n        self.t_rc = np.array(self.t_rc, dtype=float) \n        rc = np.zeros_like(self.t_rc)\n        for i, ti in enumerate(self.t_rc):\n            if np.isclose(ti, 0.0):\n                rc[i] = 1.0 + self.alpha * (4/np.pi - 1)\n            elif self.alpha != 0 and np.isclose(np.abs(ti), self.Tb/(4*self.alpha)):\n                rc[i] = (self.alpha/np.sqrt(2)) * (\n                    (1 + 2/np.pi) * np.sin(np.pi/(4*self.alpha)) +\n                    (1 - 2/np.pi) * np.cos(np.pi/(4*self.alpha))\n                )\n            else:\n                num = np.sin(np.pi * ti * (1 - self.alpha) / self.Tb) + \\\n                      4 * self.alpha * (ti / self.Tb) * np.cos(np.pi * ti * (1 + self.alpha) / self.Tb)\n                den = np.pi * ti * (1 - (4 * self.alpha * ti / self.Tb) ** 2) / self.Tb\n                rc[i] = num / den\n        # Normaliza energia para 1\n        rc = rc / np.sqrt(np.sum(rc**2))\n        return rc\n\n    def apply_format(self, symbols):\n        r\"\"\"\n        Formata os s\u00edmbolos de entrada usando o pulso inicializado. O processo de formata\u00e7\u00e3o \u00e9 dado por: \n\n        $$\n           d(t) = \\sum_{n} x[n] \\cdot g(t - nT_b)\n        $$\n\n        Nota: \n            - $d(t)$ \u00e9 o sinal formatado de sa\u00edda,\n            - $x$ \u00e9 o vetor de s\u00edmbolos de entrada,\n            - $g(t)$ \u00e9 o pulso formatador,\n            - $n$ \u00e9 o \u00edndice de tempo,\n            - $T_b$ \u00e9 o per\u00edodo de bit.\n\n        Args:\n            symbols (np.ndarray): Vetor de s\u00edmbolos a serem formatados.\n\n        Returns:\n            out_symbols (np.ndarray): Vetor formatado com o pulso aplicado.\n        \"\"\"\n        pulse = self.g\n        sps = self.sps\n        upsampled = np.zeros(len(symbols) * sps)\n        upsampled[::sps] = symbols\n        return np.convolve(upsampled, pulse, mode='same')\n</code></pre>"},{"location":"api/formatter/#formatter.Formatter.__init__","title":"<code>__init__(alpha=0.8, fs=128000, Rb=400, span=6, type='RRC')</code>","text":"<p>Inicializa uma inst\u00e2ncia de formatador de pulso. O pulso formatador \u00e9 usado para preparar os s\u00edmbolos nos canais I e Q para transmiss\u00e3o.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>Fator de roll-off do pulso RRC.</p> <code>0.8</code> <code>fs</code> <code>int</code> <p>Frequ\u00eancia de amostragem.</p> <code>128000</code> <code>Rb</code> <code>int</code> <p>Taxa de bits.</p> <code>400</code> <code>span</code> <code>int</code> <p>Dura\u00e7\u00e3o do pulso em termos de per\u00edodos de bit.</p> <code>6</code> <code>type</code> <code>str</code> <p>Tipo de pulso, atualmente apenas \"RRC\" \u00e9 suportado.</p> <code>'RRC'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se o tipo de pulso n\u00e3o for suportado.</p> Source code in <code>src/formatter.py</code> <pre><code>def __init__(self, alpha=0.8, fs=128_000, Rb=400, span=6, type=\"RRC\"):\n    r\"\"\"\n    Inicializa uma inst\u00e2ncia de formatador de pulso. O pulso formatador \u00e9 usado para preparar os s\u00edmbolos nos canais I e Q para transmiss\u00e3o.\n\n    Args:\n        alpha (float): Fator de roll-off do pulso RRC.\n        fs (int): Frequ\u00eancia de amostragem.\n        Rb (int): Taxa de bits.\n        span (int): Dura\u00e7\u00e3o do pulso em termos de per\u00edodos de bit.\n        type (str): Tipo de pulso, atualmente apenas \"RRC\" \u00e9 suportado.\n\n    Raises:\n        ValueError: Se o tipo de pulso n\u00e3o for suportado.\n    \"\"\"\n    self.alpha = alpha\n    self.fs = fs\n    self.Rb = Rb\n    self.Tb = 1 / Rb\n    self.sps = int(fs / Rb)\n    self.span = span\n    self.t_rc = np.linspace(-span * self.Tb, span * self.Tb, span * self.sps * 2)\n\n    type_map = {\n        \"rrc\": 0\n    }\n\n    type = type.lower()\n    if type not in type_map:\n        raise ValueError(\"Tipo de pulso inv\u00e1lido. Use 'RRC'.\")\n\n    self.type = type_map[type]\n\n    if self.type == 0:  # RRC\n        self.g = self.rrc_pulse()\n</code></pre>"},{"location":"api/formatter/#formatter.Formatter.rrc_pulse","title":"<code>rrc_pulse()</code>","text":"<p>Gera o pulso Root Raised Cosine (RRC) para a transmiss\u00e3o de sinais digitais. O pulso RRC \u00e9 definido como: $$ \\begin{equation}     g(t) = \\frac{\\sin(\\pi \\frac{t}{T_b})}{\\pi \\frac{t}{T_b}} \\cdot \\frac{\\cos(\\pi \\alpha \\frac{t}{T_b})}{1 - (2\\alpha \\frac{t}{T_b})^2} \\end{equation} $$</p> Nota <ul> <li>\\(g(t)\\) \u00e9 o pulso formatador,</li> <li>\\(\\alpha\\) \u00e9 o fator de roll-off, </li> <li>\\(T_b\\) \u00e9 o per\u00edodo de bit, </li> <li>\\(t\\) \u00e9 o tempo.</li> </ul> <p>Returns:</p> Name Type Description <code>rc</code> <code>ndarray</code> <p>Pulso RRC.</p> Source code in <code>src/formatter.py</code> <pre><code>def rrc_pulse(self):\n    r\"\"\"\n    Gera o pulso Root Raised Cosine (RRC) para a transmiss\u00e3o de sinais digitais. O pulso RRC \u00e9 definido como:\n    $$\n    \\begin{equation}\n        g(t) = \\frac{\\sin(\\pi \\frac{t}{T_b})}{\\pi \\frac{t}{T_b}} \\cdot \\frac{\\cos(\\pi \\alpha \\frac{t}{T_b})}{1 - (2\\alpha \\frac{t}{T_b})^2}\n    \\end{equation}\n    $$\n\n    Nota:\n        - $g(t)$ \u00e9 o pulso formatador,\n        - $\\alpha$ \u00e9 o fator de roll-off, \n        - $T_b$ \u00e9 o per\u00edodo de bit, \n        - $t$ \u00e9 o tempo.\n\n    Args:\n        None\n\n    Returns:\n       rc (np.ndarray): Pulso RRC.\n    \"\"\"\n    self.t_rc = np.array(self.t_rc, dtype=float) \n    rc = np.zeros_like(self.t_rc)\n    for i, ti in enumerate(self.t_rc):\n        if np.isclose(ti, 0.0):\n            rc[i] = 1.0 + self.alpha * (4/np.pi - 1)\n        elif self.alpha != 0 and np.isclose(np.abs(ti), self.Tb/(4*self.alpha)):\n            rc[i] = (self.alpha/np.sqrt(2)) * (\n                (1 + 2/np.pi) * np.sin(np.pi/(4*self.alpha)) +\n                (1 - 2/np.pi) * np.cos(np.pi/(4*self.alpha))\n            )\n        else:\n            num = np.sin(np.pi * ti * (1 - self.alpha) / self.Tb) + \\\n                  4 * self.alpha * (ti / self.Tb) * np.cos(np.pi * ti * (1 + self.alpha) / self.Tb)\n            den = np.pi * ti * (1 - (4 * self.alpha * ti / self.Tb) ** 2) / self.Tb\n            rc[i] = num / den\n    # Normaliza energia para 1\n    rc = rc / np.sqrt(np.sum(rc**2))\n    return rc\n</code></pre>"},{"location":"api/formatter/#formatter.Formatter.apply_format","title":"<code>apply_format(symbols)</code>","text":"<p>Formata os s\u00edmbolos de entrada usando o pulso inicializado. O processo de formata\u00e7\u00e3o \u00e9 dado por: </p> \\[    d(t) = \\sum_{n} x[n] \\cdot g(t - nT_b) \\] Nota <ul> <li>\\(d(t)\\) \u00e9 o sinal formatado de sa\u00edda,</li> <li>\\(x\\) \u00e9 o vetor de s\u00edmbolos de entrada,</li> <li>\\(g(t)\\) \u00e9 o pulso formatador,</li> <li>\\(n\\) \u00e9 o \u00edndice de tempo,</li> <li>\\(T_b\\) \u00e9 o per\u00edodo de bit.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>symbols</code> <code>ndarray</code> <p>Vetor de s\u00edmbolos a serem formatados.</p> required <p>Returns:</p> Name Type Description <code>out_symbols</code> <code>ndarray</code> <p>Vetor formatado com o pulso aplicado.</p> Source code in <code>src/formatter.py</code> <pre><code>def apply_format(self, symbols):\n    r\"\"\"\n    Formata os s\u00edmbolos de entrada usando o pulso inicializado. O processo de formata\u00e7\u00e3o \u00e9 dado por: \n\n    $$\n       d(t) = \\sum_{n} x[n] \\cdot g(t - nT_b)\n    $$\n\n    Nota: \n        - $d(t)$ \u00e9 o sinal formatado de sa\u00edda,\n        - $x$ \u00e9 o vetor de s\u00edmbolos de entrada,\n        - $g(t)$ \u00e9 o pulso formatador,\n        - $n$ \u00e9 o \u00edndice de tempo,\n        - $T_b$ \u00e9 o per\u00edodo de bit.\n\n    Args:\n        symbols (np.ndarray): Vetor de s\u00edmbolos a serem formatados.\n\n    Returns:\n        out_symbols (np.ndarray): Vetor formatado com o pulso aplicado.\n    \"\"\"\n    pulse = self.g\n    sps = self.sps\n    upsampled = np.zeros(len(symbols) * sps)\n    upsampled[::sps] = symbols\n    return np.convolve(upsampled, pulse, mode='same')\n</code></pre>"},{"location":"api/lpf/","title":"Filtro Passa Baixa","text":"Source code in <code>src/lowpassfilter.py</code> <pre><code>class LPF:\n    def __init__(self, cut_off, order, fs=128_000, type=\"butter\"):\n        r\"\"\"\n        Inicializa o LPF (Low-Pass Filter).\n\n        Args:\n            cut_off (float): Frequ\u00eancia de corte do filtro.\n            order (int): Ordem do filtro.\n            fs (int, opcional): Frequ\u00eancia de amostragem. Padr\u00e3o \u00e9 128000.\n            type (str, opcional): Tipo de filtro. Padr\u00e3o \u00e9 \"butter\".\n        \"\"\"\n\n        self.cut_off = cut_off\n        self.order = order\n        self.fs = fs\n\n        type = type.lower()\n        if type != \"butter\":\n            raise ValueError(\"Tipo de filtro inv\u00e1lido. Use 'butter'.\")\n\n        # Coeficientes b (numerador) e a (denominador) do filtro\n        self.b, self.a = self.butterworth_filter()\n        self.impulse_response, self.t_impulse = self.calc_impulse_response()\n\n    def butterworth_filter(self, fNyquist=0.5):\n        r\"\"\"\n        Calcula os coeficientes do filtro Butterworth.\n\n        Args: \n            fNyquist (float): Fator de Nyquist. Padr\u00e3o \u00e9 0.5 * fs.\n\n        Returns:\n            tuple: Coeficientes b e a do filtro Butterworth.\n        \"\"\"\n        b, a = butter(self.order, self.cut_off / (fNyquist * self.fs), btype='low')\n        return b, a\n\n    def calc_impulse_response(self, impulse_len=512):\n        r\"\"\"\n        Calcula a resposta ao impulso do filtro.\n\n        Args: \n            impulse_len (int): Comprimento do vetor de impulso. Padr\u00e3o \u00e9 512.\n\n        Returns:\n            tuple: Resposta ao impulso e vetor de tempo.\n        \"\"\"\n        # Impulso unit\u00e1rio\n        impulse_input = np.zeros(impulse_len)\n        impulse_input[0] = 1\n\n        # Resposta ao impulso\n        impulse_response = lfilter(self.b, self.a, impulse_input)\n        t_impulse = np.arange(impulse_len) / self.fs\n        return impulse_response, t_impulse\n\n    def apply_filter(self, signal):\n        r\"\"\"\n        Aplica o filtro passa-baixa ao sinal de entrada.\n\n        Args:\n            signal (np.ndarray): Sinal de entrada a ser filtrado.\n\n        Returns:\n            np.ndarray: Sinal filtrado.\n        \"\"\"\n        signal_filtered = filtfilt(self.b, self.a, signal)\n\n        # Remover offset DC\n        signal_filtered -= np.mean(signal_filtered)\n\n        # Normalizar amplitude\n        signal_filtered *= 2\n\n        return signal_filtered\n</code></pre>"},{"location":"api/lpf/#lowpassfilter.LPF.__init__","title":"<code>__init__(cut_off, order, fs=128000, type='butter')</code>","text":"<p>Inicializa o LPF (Low-Pass Filter).</p> <p>Parameters:</p> Name Type Description Default <code>cut_off</code> <code>float</code> <p>Frequ\u00eancia de corte do filtro.</p> required <code>order</code> <code>int</code> <p>Ordem do filtro.</p> required <code>fs</code> <code>(int, opcional)</code> <p>Frequ\u00eancia de amostragem. Padr\u00e3o \u00e9 128000.</p> <code>128000</code> <code>type</code> <code>(str, opcional)</code> <p>Tipo de filtro. Padr\u00e3o \u00e9 \"butter\".</p> <code>'butter'</code> Source code in <code>src/lowpassfilter.py</code> <pre><code>def __init__(self, cut_off, order, fs=128_000, type=\"butter\"):\n    r\"\"\"\n    Inicializa o LPF (Low-Pass Filter).\n\n    Args:\n        cut_off (float): Frequ\u00eancia de corte do filtro.\n        order (int): Ordem do filtro.\n        fs (int, opcional): Frequ\u00eancia de amostragem. Padr\u00e3o \u00e9 128000.\n        type (str, opcional): Tipo de filtro. Padr\u00e3o \u00e9 \"butter\".\n    \"\"\"\n\n    self.cut_off = cut_off\n    self.order = order\n    self.fs = fs\n\n    type = type.lower()\n    if type != \"butter\":\n        raise ValueError(\"Tipo de filtro inv\u00e1lido. Use 'butter'.\")\n\n    # Coeficientes b (numerador) e a (denominador) do filtro\n    self.b, self.a = self.butterworth_filter()\n    self.impulse_response, self.t_impulse = self.calc_impulse_response()\n</code></pre>"},{"location":"api/lpf/#lowpassfilter.LPF.butterworth_filter","title":"<code>butterworth_filter(fNyquist=0.5)</code>","text":"<p>Calcula os coeficientes do filtro Butterworth.</p> <p>Parameters:</p> Name Type Description Default <code>fNyquist</code> <code>float</code> <p>Fator de Nyquist. Padr\u00e3o \u00e9 0.5 * fs.</p> <code>0.5</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>Coeficientes b e a do filtro Butterworth.</p> Source code in <code>src/lowpassfilter.py</code> <pre><code>def butterworth_filter(self, fNyquist=0.5):\n    r\"\"\"\n    Calcula os coeficientes do filtro Butterworth.\n\n    Args: \n        fNyquist (float): Fator de Nyquist. Padr\u00e3o \u00e9 0.5 * fs.\n\n    Returns:\n        tuple: Coeficientes b e a do filtro Butterworth.\n    \"\"\"\n    b, a = butter(self.order, self.cut_off / (fNyquist * self.fs), btype='low')\n    return b, a\n</code></pre>"},{"location":"api/lpf/#lowpassfilter.LPF.calc_impulse_response","title":"<code>calc_impulse_response(impulse_len=512)</code>","text":"<p>Calcula a resposta ao impulso do filtro.</p> <p>Parameters:</p> Name Type Description Default <code>impulse_len</code> <code>int</code> <p>Comprimento do vetor de impulso. Padr\u00e3o \u00e9 512.</p> <code>512</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>Resposta ao impulso e vetor de tempo.</p> Source code in <code>src/lowpassfilter.py</code> <pre><code>def calc_impulse_response(self, impulse_len=512):\n    r\"\"\"\n    Calcula a resposta ao impulso do filtro.\n\n    Args: \n        impulse_len (int): Comprimento do vetor de impulso. Padr\u00e3o \u00e9 512.\n\n    Returns:\n        tuple: Resposta ao impulso e vetor de tempo.\n    \"\"\"\n    # Impulso unit\u00e1rio\n    impulse_input = np.zeros(impulse_len)\n    impulse_input[0] = 1\n\n    # Resposta ao impulso\n    impulse_response = lfilter(self.b, self.a, impulse_input)\n    t_impulse = np.arange(impulse_len) / self.fs\n    return impulse_response, t_impulse\n</code></pre>"},{"location":"api/lpf/#lowpassfilter.LPF.apply_filter","title":"<code>apply_filter(signal)</code>","text":"<p>Aplica o filtro passa-baixa ao sinal de entrada.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>ndarray</code> <p>Sinal de entrada a ser filtrado.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Sinal filtrado.</p> Source code in <code>src/lowpassfilter.py</code> <pre><code>def apply_filter(self, signal):\n    r\"\"\"\n    Aplica o filtro passa-baixa ao sinal de entrada.\n\n    Args:\n        signal (np.ndarray): Sinal de entrada a ser filtrado.\n\n    Returns:\n        np.ndarray: Sinal filtrado.\n    \"\"\"\n    signal_filtered = filtfilt(self.b, self.a, signal)\n\n    # Remover offset DC\n    signal_filtered -= np.mean(signal_filtered)\n\n    # Normalizar amplitude\n    signal_filtered *= 2\n\n    return signal_filtered\n</code></pre>"},{"location":"api/matchedfilter/","title":"Filtro Casado","text":"Source code in <code>src/matchedfilter.py</code> <pre><code>class MatchedFilter:\n    def __init__(self, alpha=0.8, fs=128_000, Rb=400, span=6, type=\"RRC-Inverted\"):\n        r\"\"\"\n        Inicializa uma inst\u00e2ncia de filtro casado. O filtro casado \u00e9 usado para maximizar a SNR do sinal recebido.\n\n        Args:\n            alpha (float): Fator de roll-off do filtro casado.\n            fs (int): Frequ\u00eancia de amostragem.\n            Rb (int): Taxa de bits.\n            span (int): Dura\u00e7\u00e3o do pulso em termos de per\u00edodos de bit.\n            type (str): Tipo de filtro, atualmente apenas \"RRC-Inverted\" \u00e9 suportado.\n\n        Raises:\n            ValueError: Se o tipo de pulso n\u00e3o for suportado.\n        \"\"\"\n        self.alpha = alpha\n        self.fs = fs\n        self.Rb = Rb\n        self.Tb = 1 / Rb\n        self.sps = int(fs / Rb)\n        self.span = span\n        self.t_rc = np.linspace(-span * self.Tb, span * self.Tb, span * self.sps * 2)\n\n        type_map = {\n            \"rrc-inverted\": 0\n        }\n\n        type = type.lower()\n        if type not in type_map:\n            raise ValueError(\"Tipo de filtro inv\u00e1lido. Use 'RRC-inverted'.\")\n\n        self.type = type_map[type]\n\n        if self.type == 0:  # RRC\n            self.g = self.rrc_inverted_pulse()\n\n        # Calculate impulse response\n        self.impulse_response, self.t_impulse = self.calc_impulse_response()\n\n    def rrc_inverted_pulse(self):\n        r\"\"\"\n        Gera o pulso Root Raised Cosine (RRC) invertido para a transmiss\u00e3o de sinais digitais. O pulso RRC \u00e9 definido como:\n        $$\n        \\begin{equation}\n            g(t) = \\frac{\\sin(\\pi \\frac{t}{T_b})}{\\pi \\frac{t}{T_b}} \\cdot \\frac{\\cos(\\pi \\alpha \\frac{t}{T_b})}{1 - (2\\alpha \\frac{t}{T_b})^2}\n        \\end{equation}\n        $$\n\n        Nota:\n            - $g(t)$ \u00e9 o pulso RRC invertido,\n            - $\\alpha$ \u00e9 o fator de roll-off, \n            - $T_b$ \u00e9 o per\u00edodo de bit, \n            - $t$ \u00e9 o tempo.\n\n        Args:\n            None\n\n        Returns:\n           rc (np.ndarray): Pulso RRC invertido.\n        \"\"\"\n        self.t_rc = np.array(self.t_rc, dtype=float) \n        rc = np.zeros_like(self.t_rc)\n        for i, ti in enumerate(self.t_rc):\n            if np.isclose(ti, 0.0):\n                rc[i] = 1.0 + self.alpha * (4/np.pi - 1)\n            elif self.alpha != 0 and np.isclose(np.abs(ti), self.Tb/(4*self.alpha)):\n                rc[i] = (self.alpha/np.sqrt(2)) * (\n                    (1 + 2/np.pi) * np.sin(np.pi/(4*self.alpha)) +\n                    (1 - 2/np.pi) * np.cos(np.pi/(4*self.alpha))\n                )\n            else:\n                num = np.sin(np.pi * ti * (1 - self.alpha) / self.Tb) + \\\n                      4 * self.alpha * (ti / self.Tb) * np.cos(np.pi * ti * (1 + self.alpha) / self.Tb)\n                den = np.pi * ti * (1 - (4 * self.alpha * ti / self.Tb) ** 2) / self.Tb\n                rc[i] = num / den\n        # Normaliza energia para 1\n        rc = rc / np.sqrt(np.sum(rc**2))\n\n        # Inverte o pulso no tempo para criar o filtro casado\n        rc = rc[::-1]\n        return rc\n\n    def calc_impulse_response(self, impulse_len=512):\n        \"\"\"\n        Calcula a resposta ao impulso do filtro casado.\n\n        Returns:\n            tuple: (impulse_response, t_impulse) onde:\n                - impulse_response: Resposta ao impulso do filtro\n                - t_impulse: Vetor de tempo correspondente\n        \"\"\"\n        # Usa o comprimento do pulso RRC como base para garantir que capturamos toda a resposta\n        pulse_len = len(self.g)\n\n        # Cria um impulso unit\u00e1rio no meio do vetor\n        impulse = np.zeros(pulse_len)\n        impulse[pulse_len // 2] = 1\n\n        # Aplica o filtro casado ao impulso\n        impulse_response = np.convolve(impulse, self.g, mode='full')\n\n        # Cria o vetor de tempo centrado em zero\n        t_impulse = (np.arange(len(impulse_response)) - len(impulse_response) // 2) / self.fs\n\n        return impulse_response, t_impulse\n\n    def apply_filter(self, signal):\n        return np.convolve(signal, self.impulse_response, mode='same')\n</code></pre>"},{"location":"api/matchedfilter/#matchedfilter.MatchedFilter.__init__","title":"<code>__init__(alpha=0.8, fs=128000, Rb=400, span=6, type='RRC-Inverted')</code>","text":"<p>Inicializa uma inst\u00e2ncia de filtro casado. O filtro casado \u00e9 usado para maximizar a SNR do sinal recebido.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>Fator de roll-off do filtro casado.</p> <code>0.8</code> <code>fs</code> <code>int</code> <p>Frequ\u00eancia de amostragem.</p> <code>128000</code> <code>Rb</code> <code>int</code> <p>Taxa de bits.</p> <code>400</code> <code>span</code> <code>int</code> <p>Dura\u00e7\u00e3o do pulso em termos de per\u00edodos de bit.</p> <code>6</code> <code>type</code> <code>str</code> <p>Tipo de filtro, atualmente apenas \"RRC-Inverted\" \u00e9 suportado.</p> <code>'RRC-Inverted'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se o tipo de pulso n\u00e3o for suportado.</p> Source code in <code>src/matchedfilter.py</code> <pre><code>def __init__(self, alpha=0.8, fs=128_000, Rb=400, span=6, type=\"RRC-Inverted\"):\n    r\"\"\"\n    Inicializa uma inst\u00e2ncia de filtro casado. O filtro casado \u00e9 usado para maximizar a SNR do sinal recebido.\n\n    Args:\n        alpha (float): Fator de roll-off do filtro casado.\n        fs (int): Frequ\u00eancia de amostragem.\n        Rb (int): Taxa de bits.\n        span (int): Dura\u00e7\u00e3o do pulso em termos de per\u00edodos de bit.\n        type (str): Tipo de filtro, atualmente apenas \"RRC-Inverted\" \u00e9 suportado.\n\n    Raises:\n        ValueError: Se o tipo de pulso n\u00e3o for suportado.\n    \"\"\"\n    self.alpha = alpha\n    self.fs = fs\n    self.Rb = Rb\n    self.Tb = 1 / Rb\n    self.sps = int(fs / Rb)\n    self.span = span\n    self.t_rc = np.linspace(-span * self.Tb, span * self.Tb, span * self.sps * 2)\n\n    type_map = {\n        \"rrc-inverted\": 0\n    }\n\n    type = type.lower()\n    if type not in type_map:\n        raise ValueError(\"Tipo de filtro inv\u00e1lido. Use 'RRC-inverted'.\")\n\n    self.type = type_map[type]\n\n    if self.type == 0:  # RRC\n        self.g = self.rrc_inverted_pulse()\n\n    # Calculate impulse response\n    self.impulse_response, self.t_impulse = self.calc_impulse_response()\n</code></pre>"},{"location":"api/matchedfilter/#matchedfilter.MatchedFilter.rrc_inverted_pulse","title":"<code>rrc_inverted_pulse()</code>","text":"<p>Gera o pulso Root Raised Cosine (RRC) invertido para a transmiss\u00e3o de sinais digitais. O pulso RRC \u00e9 definido como: $$ \\begin{equation}     g(t) = \\frac{\\sin(\\pi \\frac{t}{T_b})}{\\pi \\frac{t}{T_b}} \\cdot \\frac{\\cos(\\pi \\alpha \\frac{t}{T_b})}{1 - (2\\alpha \\frac{t}{T_b})^2} \\end{equation} $$</p> Nota <ul> <li>\\(g(t)\\) \u00e9 o pulso RRC invertido,</li> <li>\\(\\alpha\\) \u00e9 o fator de roll-off, </li> <li>\\(T_b\\) \u00e9 o per\u00edodo de bit, </li> <li>\\(t\\) \u00e9 o tempo.</li> </ul> <p>Returns:</p> Name Type Description <code>rc</code> <code>ndarray</code> <p>Pulso RRC invertido.</p> Source code in <code>src/matchedfilter.py</code> <pre><code>def rrc_inverted_pulse(self):\n    r\"\"\"\n    Gera o pulso Root Raised Cosine (RRC) invertido para a transmiss\u00e3o de sinais digitais. O pulso RRC \u00e9 definido como:\n    $$\n    \\begin{equation}\n        g(t) = \\frac{\\sin(\\pi \\frac{t}{T_b})}{\\pi \\frac{t}{T_b}} \\cdot \\frac{\\cos(\\pi \\alpha \\frac{t}{T_b})}{1 - (2\\alpha \\frac{t}{T_b})^2}\n    \\end{equation}\n    $$\n\n    Nota:\n        - $g(t)$ \u00e9 o pulso RRC invertido,\n        - $\\alpha$ \u00e9 o fator de roll-off, \n        - $T_b$ \u00e9 o per\u00edodo de bit, \n        - $t$ \u00e9 o tempo.\n\n    Args:\n        None\n\n    Returns:\n       rc (np.ndarray): Pulso RRC invertido.\n    \"\"\"\n    self.t_rc = np.array(self.t_rc, dtype=float) \n    rc = np.zeros_like(self.t_rc)\n    for i, ti in enumerate(self.t_rc):\n        if np.isclose(ti, 0.0):\n            rc[i] = 1.0 + self.alpha * (4/np.pi - 1)\n        elif self.alpha != 0 and np.isclose(np.abs(ti), self.Tb/(4*self.alpha)):\n            rc[i] = (self.alpha/np.sqrt(2)) * (\n                (1 + 2/np.pi) * np.sin(np.pi/(4*self.alpha)) +\n                (1 - 2/np.pi) * np.cos(np.pi/(4*self.alpha))\n            )\n        else:\n            num = np.sin(np.pi * ti * (1 - self.alpha) / self.Tb) + \\\n                  4 * self.alpha * (ti / self.Tb) * np.cos(np.pi * ti * (1 + self.alpha) / self.Tb)\n            den = np.pi * ti * (1 - (4 * self.alpha * ti / self.Tb) ** 2) / self.Tb\n            rc[i] = num / den\n    # Normaliza energia para 1\n    rc = rc / np.sqrt(np.sum(rc**2))\n\n    # Inverte o pulso no tempo para criar o filtro casado\n    rc = rc[::-1]\n    return rc\n</code></pre>"},{"location":"api/matchedfilter/#matchedfilter.MatchedFilter.calc_impulse_response","title":"<code>calc_impulse_response(impulse_len=512)</code>","text":"<p>Calcula a resposta ao impulso do filtro casado.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(impulse_response, t_impulse) onde: - impulse_response: Resposta ao impulso do filtro - t_impulse: Vetor de tempo correspondente</p> Source code in <code>src/matchedfilter.py</code> <pre><code>def calc_impulse_response(self, impulse_len=512):\n    \"\"\"\n    Calcula a resposta ao impulso do filtro casado.\n\n    Returns:\n        tuple: (impulse_response, t_impulse) onde:\n            - impulse_response: Resposta ao impulso do filtro\n            - t_impulse: Vetor de tempo correspondente\n    \"\"\"\n    # Usa o comprimento do pulso RRC como base para garantir que capturamos toda a resposta\n    pulse_len = len(self.g)\n\n    # Cria um impulso unit\u00e1rio no meio do vetor\n    impulse = np.zeros(pulse_len)\n    impulse[pulse_len // 2] = 1\n\n    # Aplica o filtro casado ao impulso\n    impulse_response = np.convolve(impulse, self.g, mode='full')\n\n    # Cria o vetor de tempo centrado em zero\n    t_impulse = (np.arange(len(impulse_response)) - len(impulse_response) // 2) / self.fs\n\n    return impulse_response, t_impulse\n</code></pre>"},{"location":"api/modulator/","title":"Modulador","text":"Source code in <code>src/modulator.py</code> <pre><code>class Modulator:\n    def __init__(self, fc, fs):\n        r\"\"\"\n        Inicializa uma inst\u00e2ncia do modulador IQ.\n        O modulador IQ \u00e9 respons\u00e1vel por modular os sinais I e Q em uma portadora de frequ\u00eancia espec\u00edfica.\n\n        Args:\n            fc (float): Frequ\u00eancia da portadora.\n            fs (int): Frequ\u00eancia de amostragem.\n\n        Raises:\n            ValueError: Se a frequ\u00eancia de amostragem n\u00e3o for maior que o dobro da frequ\u00eancia da portadora. (Teorema de Nyquist)\n        \"\"\"\n        if fc &lt;= 0:\n            raise ValueError(\"A frequ\u00eancia da portadora deve ser maior que zero.\")\n\n        if fs &lt;= fc*2:\n            raise ValueError(\"A frequ\u00eancia de amostragem deve ser maior que o dobro da frequ\u00eancia da portadora.\")\n\n        self.fc = fc\n        self.fs = fs\n\n    def modulate(self, i_signal, q_signal):\n        r\"\"\"\n        Modula os sinais I e Q em uma portadora de frequ\u00eancia espec\u00edfica. O processo de modula\u00e7\u00e3o \u00e9 dado pela express\u00e3o:\n\n        $$\n            s(t) = I(t) \\cdot \\cos(2\\pi f_c t) - Q(t) \\cdot \\sin(2\\pi f_c t)\n        $$\n\n        Args:\n            i_signal (np.ndarray): Sinal I a ser modulado.\n            q_signal (np.ndarray): Sinal Q a ser modulado.\n\n        Returns:\n            t (np.ndarray): Vetor de tempo $t$ correspondente ao sinal modulado.\n            modulated_signal (np.ndarray): Sinal modulado $s(t)$ resultante.\n\n        Raises:\n            ValueError: Se os sinais I e Q n\u00e3o tiverem o mesmo tamanho.\n        \"\"\"\n        n = len(i_signal)\n        if len(q_signal) != n:\n            raise ValueError(\"i_signal e q_signal devem ter o mesmo tamanho.\")\n\n        t = np.arange(n) / self.fs\n        carrier_cos = np.cos(2 * np.pi * self.fc * t)\n        carrier_sin = np.sin(2 * np.pi * self.fc * t)\n\n        modulated_signal = i_signal * carrier_cos - q_signal * carrier_sin\n        return t, modulated_signal\n\n    def demodulate(self, modulated_signal):\n        r\"\"\"\n        Demodula o sinal modulado para recuperar os sinais I e Q originais. \n\n        Para o processo de demodula\u00e7\u00e3o, utilizamos os sinais de portadora $x_I(t)$ e $y_Q(t)$ definidos como:\n\n        $$\n            x_I(t) = 2 \\cos(2\\pi f_c t)\n        $$\n\n        $$\n            y_Q(t) = 2 \\sin(2\\pi f_c t)\n        $$\n\n        Nota: \n            - A constante 2 \u00e9 utilizada para manter a amplitude do sinal original, devido a transla\u00e7\u00e3o do sinal modulado.\n\n        O processo resulta em dois sinais, contendo uma componente em banda base e outra em banda $2f_c$: \n\n        $$\n        x_I'(t) = s(t) \\cdot x_I(t) = \\left[Ad_I(t) \\cos(2\\pi f_c t ) - Ad_Q(t) \\sin(2\\pi f_c t )\\right] \\cdot 2\\cos(2\\pi f_c t )\n        $$\n\n        $$\n        y_Q'(t) = -s(t) \\cdot y_Q(t) = \\left[Ad_I(t) \\cos(2\\pi f_c t ) - Ad_Q(t) \\sin(2\\pi f_c t )\\right] \\cdot 2\\sin(2\\pi f_c t )\n        $$\n\n        Args:\n            modulated_signal (np.ndarray): Sinal modulado $s(t)$ a ser demodulado.\n\n        Returns:\n            i_signal (np.ndarray): Sinal I recuperado.\n            q_signal (np.ndarray): Sinal Q recuperado.\n\n        Raises:\n            ValueError: Se o sinal modulado estiver vazio.\n        \"\"\"\n        n = len(modulated_signal)\n        if n == 0:\n            raise ValueError(\"O sinal modulado n\u00e3o pode estar vazio.\")\n\n        t = np.arange(n) / self.fs\n        carrier_cos = 2 * np.cos(2 * np.pi * self.fc * t)\n        carrier_sin = 2 * np.sin(2 * np.pi * self.fc * t)\n\n        i_signal = modulated_signal * carrier_cos\n        q_signal = -modulated_signal * carrier_sin\n\n        return i_signal, q_signal\n</code></pre>"},{"location":"api/modulator/#modulator.Modulator.__init__","title":"<code>__init__(fc, fs)</code>","text":"<p>Inicializa uma inst\u00e2ncia do modulador IQ. O modulador IQ \u00e9 respons\u00e1vel por modular os sinais I e Q em uma portadora de frequ\u00eancia espec\u00edfica.</p> <p>Parameters:</p> Name Type Description Default <code>fc</code> <code>float</code> <p>Frequ\u00eancia da portadora.</p> required <code>fs</code> <code>int</code> <p>Frequ\u00eancia de amostragem.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Se a frequ\u00eancia de amostragem n\u00e3o for maior que o dobro da frequ\u00eancia da portadora. (Teorema de Nyquist)</p> Source code in <code>src/modulator.py</code> <pre><code>def __init__(self, fc, fs):\n    r\"\"\"\n    Inicializa uma inst\u00e2ncia do modulador IQ.\n    O modulador IQ \u00e9 respons\u00e1vel por modular os sinais I e Q em uma portadora de frequ\u00eancia espec\u00edfica.\n\n    Args:\n        fc (float): Frequ\u00eancia da portadora.\n        fs (int): Frequ\u00eancia de amostragem.\n\n    Raises:\n        ValueError: Se a frequ\u00eancia de amostragem n\u00e3o for maior que o dobro da frequ\u00eancia da portadora. (Teorema de Nyquist)\n    \"\"\"\n    if fc &lt;= 0:\n        raise ValueError(\"A frequ\u00eancia da portadora deve ser maior que zero.\")\n\n    if fs &lt;= fc*2:\n        raise ValueError(\"A frequ\u00eancia de amostragem deve ser maior que o dobro da frequ\u00eancia da portadora.\")\n\n    self.fc = fc\n    self.fs = fs\n</code></pre>"},{"location":"api/modulator/#modulator.Modulator.modulate","title":"<code>modulate(i_signal, q_signal)</code>","text":"<p>Modula os sinais I e Q em uma portadora de frequ\u00eancia espec\u00edfica. O processo de modula\u00e7\u00e3o \u00e9 dado pela express\u00e3o:</p> \\[     s(t) = I(t) \\cdot \\cos(2\\pi f_c t) - Q(t) \\cdot \\sin(2\\pi f_c t) \\] <p>Parameters:</p> Name Type Description Default <code>i_signal</code> <code>ndarray</code> <p>Sinal I a ser modulado.</p> required <code>q_signal</code> <code>ndarray</code> <p>Sinal Q a ser modulado.</p> required <p>Returns:</p> Name Type Description <code>t</code> <code>ndarray</code> <p>Vetor de tempo \\(t\\) correspondente ao sinal modulado.</p> <code>modulated_signal</code> <code>ndarray</code> <p>Sinal modulado \\(s(t)\\) resultante.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se os sinais I e Q n\u00e3o tiverem o mesmo tamanho.</p> Source code in <code>src/modulator.py</code> <pre><code>def modulate(self, i_signal, q_signal):\n    r\"\"\"\n    Modula os sinais I e Q em uma portadora de frequ\u00eancia espec\u00edfica. O processo de modula\u00e7\u00e3o \u00e9 dado pela express\u00e3o:\n\n    $$\n        s(t) = I(t) \\cdot \\cos(2\\pi f_c t) - Q(t) \\cdot \\sin(2\\pi f_c t)\n    $$\n\n    Args:\n        i_signal (np.ndarray): Sinal I a ser modulado.\n        q_signal (np.ndarray): Sinal Q a ser modulado.\n\n    Returns:\n        t (np.ndarray): Vetor de tempo $t$ correspondente ao sinal modulado.\n        modulated_signal (np.ndarray): Sinal modulado $s(t)$ resultante.\n\n    Raises:\n        ValueError: Se os sinais I e Q n\u00e3o tiverem o mesmo tamanho.\n    \"\"\"\n    n = len(i_signal)\n    if len(q_signal) != n:\n        raise ValueError(\"i_signal e q_signal devem ter o mesmo tamanho.\")\n\n    t = np.arange(n) / self.fs\n    carrier_cos = np.cos(2 * np.pi * self.fc * t)\n    carrier_sin = np.sin(2 * np.pi * self.fc * t)\n\n    modulated_signal = i_signal * carrier_cos - q_signal * carrier_sin\n    return t, modulated_signal\n</code></pre>"},{"location":"api/modulator/#modulator.Modulator.demodulate","title":"<code>demodulate(modulated_signal)</code>","text":"<p>Demodula o sinal modulado para recuperar os sinais I e Q originais. </p> <p>Para o processo de demodula\u00e7\u00e3o, utilizamos os sinais de portadora \\(x_I(t)\\) e \\(y_Q(t)\\) definidos como:</p> \\[     x_I(t) = 2 \\cos(2\\pi f_c t) \\] \\[     y_Q(t) = 2 \\sin(2\\pi f_c t) \\] Nota <ul> <li>A constante 2 \u00e9 utilizada para manter a amplitude do sinal original, devido a transla\u00e7\u00e3o do sinal modulado.</li> </ul> <p>O processo resulta em dois sinais, contendo uma componente em banda base e outra em banda \\(2f_c\\): </p> \\[ x_I'(t) = s(t) \\cdot x_I(t) = \\left[Ad_I(t) \\cos(2\\pi f_c t ) - Ad_Q(t) \\sin(2\\pi f_c t )\\right] \\cdot 2\\cos(2\\pi f_c t ) \\] \\[ y_Q'(t) = -s(t) \\cdot y_Q(t) = \\left[Ad_I(t) \\cos(2\\pi f_c t ) - Ad_Q(t) \\sin(2\\pi f_c t )\\right] \\cdot 2\\sin(2\\pi f_c t ) \\] <p>Parameters:</p> Name Type Description Default <code>modulated_signal</code> <code>ndarray</code> <p>Sinal modulado \\(s(t)\\) a ser demodulado.</p> required <p>Returns:</p> Name Type Description <code>i_signal</code> <code>ndarray</code> <p>Sinal I recuperado.</p> <code>q_signal</code> <code>ndarray</code> <p>Sinal Q recuperado.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se o sinal modulado estiver vazio.</p> Source code in <code>src/modulator.py</code> <pre><code>def demodulate(self, modulated_signal):\n    r\"\"\"\n    Demodula o sinal modulado para recuperar os sinais I e Q originais. \n\n    Para o processo de demodula\u00e7\u00e3o, utilizamos os sinais de portadora $x_I(t)$ e $y_Q(t)$ definidos como:\n\n    $$\n        x_I(t) = 2 \\cos(2\\pi f_c t)\n    $$\n\n    $$\n        y_Q(t) = 2 \\sin(2\\pi f_c t)\n    $$\n\n    Nota: \n        - A constante 2 \u00e9 utilizada para manter a amplitude do sinal original, devido a transla\u00e7\u00e3o do sinal modulado.\n\n    O processo resulta em dois sinais, contendo uma componente em banda base e outra em banda $2f_c$: \n\n    $$\n    x_I'(t) = s(t) \\cdot x_I(t) = \\left[Ad_I(t) \\cos(2\\pi f_c t ) - Ad_Q(t) \\sin(2\\pi f_c t )\\right] \\cdot 2\\cos(2\\pi f_c t )\n    $$\n\n    $$\n    y_Q'(t) = -s(t) \\cdot y_Q(t) = \\left[Ad_I(t) \\cos(2\\pi f_c t ) - Ad_Q(t) \\sin(2\\pi f_c t )\\right] \\cdot 2\\sin(2\\pi f_c t )\n    $$\n\n    Args:\n        modulated_signal (np.ndarray): Sinal modulado $s(t)$ a ser demodulado.\n\n    Returns:\n        i_signal (np.ndarray): Sinal I recuperado.\n        q_signal (np.ndarray): Sinal Q recuperado.\n\n    Raises:\n        ValueError: Se o sinal modulado estiver vazio.\n    \"\"\"\n    n = len(modulated_signal)\n    if n == 0:\n        raise ValueError(\"O sinal modulado n\u00e3o pode estar vazio.\")\n\n    t = np.arange(n) / self.fs\n    carrier_cos = 2 * np.cos(2 * np.pi * self.fc * t)\n    carrier_sin = 2 * np.sin(2 * np.pi * self.fc * t)\n\n    i_signal = modulated_signal * carrier_cos\n    q_signal = -modulated_signal * carrier_sin\n\n    return i_signal, q_signal\n</code></pre>"},{"location":"api/multiplexer/","title":"Multiplexador","text":"Source code in <code>src/multiplexer.py</code> <pre><code>class Multiplexer:\n    def __init__(self):\n        r\"\"\"\n        Inicializa uma inst\u00e2ncia do multiplexador.\n        \"\"\"\n        pass\n\n    def concatenate(self, I1, Q1, I2, Q2):\n        r\"\"\"\n        Concatena os vetores I e Q de dois canais, retornando os vetores concatenados.\n\n        Args:\n            I1 (np.ndarray): Vetor I do primeiro canal.\n            Q1 (np.ndarray): Vetor Q do primeiro canal.\n            I2 (np.ndarray): Vetor I do segundo canal.\n            Q2 (np.ndarray): Vetor Q do segundo canal.\n\n        Returns:\n            I (np.ndarray): Vetor I concatenado.\n            Q (np.ndarray): Vetor Q concatenado.\n\n        Raises:\n            AssertionError: Se os vetores I e Q n\u00e3o tiverem o mesmo comprimento em ambos os canais.\n        \"\"\"\n        assert len(I1) == len(Q1) and len(I2) == len(Q2), \"Os vetores I e Q devem ter o mesmo comprimento em ambos os canais.\"\n\n        I = np.concatenate((I1, I2))\n        Q = np.concatenate((Q1, Q2))\n\n        return I, Q\n</code></pre>"},{"location":"api/multiplexer/#multiplexer.Multiplexer.__init__","title":"<code>__init__()</code>","text":"<p>Inicializa uma inst\u00e2ncia do multiplexador.</p> Source code in <code>src/multiplexer.py</code> <pre><code>def __init__(self):\n    r\"\"\"\n    Inicializa uma inst\u00e2ncia do multiplexador.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/multiplexer/#multiplexer.Multiplexer.concatenate","title":"<code>concatenate(I1, Q1, I2, Q2)</code>","text":"<p>Concatena os vetores I e Q de dois canais, retornando os vetores concatenados.</p> <p>Parameters:</p> Name Type Description Default <code>I1</code> <code>ndarray</code> <p>Vetor I do primeiro canal.</p> required <code>Q1</code> <code>ndarray</code> <p>Vetor Q do primeiro canal.</p> required <code>I2</code> <code>ndarray</code> <p>Vetor I do segundo canal.</p> required <code>Q2</code> <code>ndarray</code> <p>Vetor Q do segundo canal.</p> required <p>Returns:</p> Name Type Description <code>I</code> <code>ndarray</code> <p>Vetor I concatenado.</p> <code>Q</code> <code>ndarray</code> <p>Vetor Q concatenado.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>Se os vetores I e Q n\u00e3o tiverem o mesmo comprimento em ambos os canais.</p> Source code in <code>src/multiplexer.py</code> <pre><code>def concatenate(self, I1, Q1, I2, Q2):\n    r\"\"\"\n    Concatena os vetores I e Q de dois canais, retornando os vetores concatenados.\n\n    Args:\n        I1 (np.ndarray): Vetor I do primeiro canal.\n        Q1 (np.ndarray): Vetor Q do primeiro canal.\n        I2 (np.ndarray): Vetor I do segundo canal.\n        Q2 (np.ndarray): Vetor Q do segundo canal.\n\n    Returns:\n        I (np.ndarray): Vetor I concatenado.\n        Q (np.ndarray): Vetor Q concatenado.\n\n    Raises:\n        AssertionError: Se os vetores I e Q n\u00e3o tiverem o mesmo comprimento em ambos os canais.\n    \"\"\"\n    assert len(I1) == len(Q1) and len(I2) == len(Q2), \"Os vetores I e Q devem ter o mesmo comprimento em ambos os canais.\"\n\n    I = np.concatenate((I1, I2))\n    Q = np.concatenate((Q1, Q2))\n\n    return I, Q\n</code></pre>"},{"location":"api/noise/","title":"Noise","text":"Source code in <code>src/noise.py</code> <pre><code>class Noise:\n    def __init__(self, snr=10):\n        r\"\"\"\n        Implementa\u00e7\u00e3o de canal para aplica\u00e7\u00e3o de ruido AWGN no sinal transmitido.\n\n        Args:\n            snr (float): Rela\u00e7\u00e3o sinal-ru\u00eddo em decib\u00e9is (dB). Padr\u00e3o \u00e9 10 dB.\n        \"\"\"\n        self.snr = snr\n\n    def add_noise(self, signal):\n        r\"\"\"\n        Adiciona ru\u00eddo AWGN ao sinal fornecido.\n\n        Args:\n            signal (np.ndarray): Sinal ao qual o ru\u00eddo ser\u00e1 adicionado.\n\n        Returns:\n            np.ndarray: Sinal com ru\u00eddo adicionado.\n        \"\"\"\n        signal_power = np.mean(np.abs(signal) ** 2)\n        snr_linear = 10 ** (self.snr / 10)\n        noise_power = signal_power / snr_linear\n        noise = np.random.normal(0, np.sqrt(noise_power), len(signal))\n        return signal + noise\n</code></pre>"},{"location":"api/noise/#noise.Noise.__init__","title":"<code>__init__(snr=10)</code>","text":"<p>Implementa\u00e7\u00e3o de canal para aplica\u00e7\u00e3o de ruido AWGN no sinal transmitido.</p> <p>Parameters:</p> Name Type Description Default <code>snr</code> <code>float</code> <p>Rela\u00e7\u00e3o sinal-ru\u00eddo em decib\u00e9is (dB). Padr\u00e3o \u00e9 10 dB.</p> <code>10</code> Source code in <code>src/noise.py</code> <pre><code>def __init__(self, snr=10):\n    r\"\"\"\n    Implementa\u00e7\u00e3o de canal para aplica\u00e7\u00e3o de ruido AWGN no sinal transmitido.\n\n    Args:\n        snr (float): Rela\u00e7\u00e3o sinal-ru\u00eddo em decib\u00e9is (dB). Padr\u00e3o \u00e9 10 dB.\n    \"\"\"\n    self.snr = snr\n</code></pre>"},{"location":"api/noise/#noise.Noise.add_noise","title":"<code>add_noise(signal)</code>","text":"<p>Adiciona ru\u00eddo AWGN ao sinal fornecido.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>ndarray</code> <p>Sinal ao qual o ru\u00eddo ser\u00e1 adicionado.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Sinal com ru\u00eddo adicionado.</p> Source code in <code>src/noise.py</code> <pre><code>def add_noise(self, signal):\n    r\"\"\"\n    Adiciona ru\u00eddo AWGN ao sinal fornecido.\n\n    Args:\n        signal (np.ndarray): Sinal ao qual o ru\u00eddo ser\u00e1 adicionado.\n\n    Returns:\n        np.ndarray: Sinal com ru\u00eddo adicionado.\n    \"\"\"\n    signal_power = np.mean(np.abs(signal) ** 2)\n    snr_linear = 10 ** (self.snr / 10)\n    noise_power = signal_power / snr_linear\n    noise = np.random.normal(0, np.sqrt(noise_power), len(signal))\n    return signal + noise\n</code></pre>"},{"location":"api/plots/","title":"Plots","text":"<p>Converte a magnitude do sinal para escala logar\u00edtmica (dB), seguindo a express\u00e3o: </p> \\[ Signal_{DB} = 20 \\cdot \\log_{10}(|signal| + 10^{-12}) \\] Nota <p>O termo \\(10^{-12}\\) \u00e9 adicionado para evitar logaritmo de zero, que \u00e9 indefinido.</p> Source code in <code>src/plots.py</code> <pre><code>def mag2db(signal):\n    r\"\"\"\n    Converte a magnitude do sinal para escala logar\u00edtmica (dB), seguindo a express\u00e3o: \n\n    $$\n    Signal_{DB} = 20 \\cdot \\log_{10}(|signal| + 10^{-12})\n    $$\n\n    Nota: \n        O termo $10^{-12}$ \u00e9 adicionado para evitar logaritmo de zero, que \u00e9 indefinido.\n    \"\"\"\n    mag = np.abs(signal)\n    mag /= np.max(mag)\n    return 20 * np.log10(mag + 1e-12)\n</code></pre> Source code in <code>src/plots.py</code> <pre><code>class Plotter:\n    def __init__(self):\n        r\"\"\" \n        Inicializa uma inst\u00e2ncia do plotter de gr\u00e1ficos.        \n        \"\"\"\n        pass\n\n    def plot_time_domain(self, s1, s2, t, label1, label2, title1, title2, save_path=None):\n        r\"\"\"\n        Plota os sinais no dom\u00ednio do tempo.\n\n        ![timed](assets/transmitter_modulator_time.svg)\n\n        Args:\n            s1 (np.ndarray): Primeiro sinal a ser plotado.\n            s2 (np.ndarray): Segundo sinal a ser plotado.\n            t (np.ndarray): Vetor de tempo correspondente aos sinais.\n            label1 (str): R\u00f3tulo do primeiro sinal.\n            label2 (str): R\u00f3tulo do segundo sinal.\n            title1 (str): T\u00edtulo do primeiro gr\u00e1fico.\n            title2 (str): T\u00edtulo do segundo gr\u00e1fico.\n            save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n        \"\"\"\n\n        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(16, 8))\n        ax1.plot(t, s1, label=label1, color='blue')\n        ax1.set_title(title1)\n        ax1.set_xlim(0, 0.1)\n        ax1.set_ylabel('Amplitude')\n        ax1.grid(True)\n        leg1 = ax1.legend(\n                    loc='upper right', frameon=True, edgecolor='black',\n                    facecolor='white', fontsize=12, fancybox=True\n                )\n        leg1.get_frame().set_facecolor('white')\n        leg1.get_frame().set_edgecolor('black')\n        leg1.get_frame().set_alpha(1.0)\n\n        ax2.plot(t, s2, label=label2, color='red')\n        title = f'{title2}'\n        ax2.set_title(title)\n        ax2.set_xlim(0, 0.1)\n        ax2.set_xlabel('Tempo (s)')\n        ax2.set_ylabel('Amplitude')\n        ax2.grid(True)\n        leg2 = ax2.legend(\n                    loc='upper right', frameon=True, edgecolor='black',\n                    facecolor='white', fontsize=12, fancybox=True\n                )\n        leg2.get_frame().set_facecolor('white')\n        leg2.get_frame().set_edgecolor('black')\n        leg2.get_frame().set_alpha(1.0)\n\n        self._save_or_show(fig, save_path)\n\n    def plot_frequency_domain(self, s1, s2, fs, fc, label1, label2, title1, title2, save_path=None):\n        r\"\"\"\n        Plota os sinais no dom\u00ednio da frequ\u00eancia.\n\n        ![freqd](assets/transmitter_modulator_freq.svg)\n\n        Args:\n            s1 (np.ndarray): Primeiro sinal a ser plotado.\n            s2 (np.ndarray): Segundo sinal a ser plotado.\n            fs (float): Frequ\u00eancia de amostragem dos sinais.\n            fc (float): Frequ\u00eancia central para o eixo x.\n            label1 (str): R\u00f3tulo do primeiro sinal.\n            label2 (str): R\u00f3tulo do segundo sinal.\n            title1 (str): T\u00edtulo do primeiro gr\u00e1fico.\n            title2 (str): T\u00edtulo do segundo gr\u00e1fico.\n            save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n        \"\"\"\n\n        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(16, 8))\n        freqs = np.fft.fftshift(np.fft.fftfreq(len(s1), d=1/fs))\n\n        if fc &gt; 1000:\n            freqs = freqs / 1000\n            x_label = \"Frequ\u00eancia (kHz)\"\n            x_limit = (-2.5 * fc / 1000, 2.5 * fc / 1000)\n        else:\n            x_label = \"Frequ\u00eancia (Hz)\"\n            x_limit = (-2.5 * fc, 2.5 * fc)\n\n        fft_clean = np.fft.fftshift(np.fft.fft(s1))\n        fft_clean_db = mag2db(fft_clean)\n        ax1.plot(freqs, fft_clean_db, color='blue', label=label1)\n        ax1.set_title(title1)\n        ax1.set_ylim(-80, 5)\n        ax1.set_xlim(*x_limit)\n        ax1.set_ylabel(\"Magnitude (dB)\")\n        ax1.grid(True)\n        leg1 = ax1.legend(\n                    loc='upper right', frameon=True, edgecolor='black',\n                    facecolor='white', fontsize=12, fancybox=True\n                )\n        leg1.get_frame().set_facecolor('white')\n        leg1.get_frame().set_edgecolor('black')\n        leg1.get_frame().set_alpha(1.0)\n\n        fft_noisy = np.fft.fftshift(np.fft.fft(s2))\n        fft_noisy_db = mag2db(fft_noisy)\n        ax2.plot(freqs, fft_noisy_db, color='red', label=label2)\n        ax2.set_title(title2)\n        ax2.set_ylim(-80, 5)\n        ax2.set_xlim(*x_limit)\n        ax2.set_ylabel(\"Magnitude (dB)\")\n        ax2.set_xlabel(x_label)\n        ax2.grid(True)\n        leg2 = ax2.legend(\n                    loc='upper right', frameon=True, edgecolor='black',\n                    facecolor='white', fontsize=12, fancybox=True\n                )\n        leg2.get_frame().set_facecolor('white')\n        leg2.get_frame().set_edgecolor('black')\n        leg2.get_frame().set_alpha(1.0)\n\n        self._save_or_show(fig, save_path)\n\n    def plot_bits(self, bits_list, sections=None, colors=None, save_path=None):\n        r\"\"\"\n        Plota uma sequ\u00eancia de bits, com a op\u00e7\u00e3o de destacar se\u00e7\u00f5es espec\u00edficas.\n\n        ![bits](assets/transmitter_datagram.svg)\n\n        Args:\n            bits_list (list of np.ndarray): Lista de arrays de bits a serem plotados.\n            sections (list of tuples, optional): Lista de se\u00e7\u00f5es a destacar, cada uma como (nome, comprimento).\n            colors (list of str, optional): Cores para as se\u00e7\u00f5es destacadas.\n            save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n        \"\"\"\n        all_bits = np.concatenate(bits_list)\n        bits_up = np.repeat(all_bits, 2)\n        x = np.arange(len(bits_up))\n\n        fig, ax = plt.subplots(figsize=(16, 4))\n        ax.set_xlim(0, len(bits_up))\n        ax.set_ylim(-0.2, 1.2)\n        ax.grid(False)\n        ax.set_yticks([0, 1])\n        bit_edges = np.arange(0, len(bits_up) + 1, 2)\n        for pos in bit_edges:\n            ax.axvline(x=pos, color='gray', linestyle='--', linewidth=0.5)\n\n        if sections:\n            start_bit = 0\n            for i, (sec_name, sec_len) in enumerate(sections):\n                bit_start = start_bit * 2\n                bit_end = (start_bit + sec_len) * 2\n                color = colors[i] if colors else 'black'\n\n                if i &gt; 0:\n                    bit_start -= 1\n\n                ax.step(\n                    x[bit_start:bit_end],\n                    bits_up[bit_start:bit_end],\n                    where='post',\n                    color=color,\n                    linewidth=1.5,\n                    label=sec_name if i == 0 or sec_name not in sections[:i] else None\n                )\n                start_bit += sec_len\n        else:\n            ax.step(x, bits_up, where='post', color='black', linewidth=1.5, label='Bits')\n\n        ax.set_xlabel('Index')\n        ax.set_ylabel('Valor')\n        leg = ax.legend(\n                    loc='upper right', frameon=True, edgecolor='black',\n                    facecolor='white', fontsize=12, fancybox=True\n                )\n        leg.get_frame().set_facecolor('white')\n        leg.get_frame().set_edgecolor('black')\n        leg.get_frame().set_alpha(1.0)\n\n        self._save_or_show(fig, save_path)\n\n    def plot_encode(self, s1, s2, s3, s4, label1, label2, label3, label4, title1, title2, title3, title4, save_path=None):\n        r\"\"\"\n        Plota os sinais de entrada e sa\u00edda do codificador.\n        ![encode](assets/transmitter_encoder.svg)\n\n        Args:\n            s1 (np.ndarray): Sinal de entrada I.\n            s2 (np.ndarray): Sinal de entrada Q.\n            s3 (np.ndarray): Sinal de sa\u00edda I codificado.\n            s4 (np.ndarray): Sinal de sa\u00edda Q codificado.\n            label1 (str): R\u00f3tulo do sinal I de entrada.\n            label2 (str): R\u00f3tulo do sinal Q de entrada.\n            label3 (str): R\u00f3tulo do sinal I codificado.\n            label4 (str): R\u00f3tulo do sinal Q codificado.\n            title1 (str): T\u00edtulo do sinal I de entrada.\n            title2 (str): T\u00edtulo do sinal Q de entrada.\n            title3 (str): T\u00edtulo do sinal I codificado.\n            title4 (str): T\u00edtulo do sinal Q codificado.\n            save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n        \"\"\"\n        s1_up = np.repeat(s1, 2)\n        s2_up = np.repeat(s2, 2)\n        x = np.arange(len(s1_up))\n        bit_edges = np.arange(0, len(s1_up) + 1, 2)\n\n        fig, axs = plt.subplots(4, 1, sharex=True)\n\n        def setup_grid(ax):\n            ax.set_xlim(0, len(s1_up))\n            ax.set_ylim(-0.2, 1.4)\n            ax.grid(False)\n            for pos in bit_edges:\n                ax.axvline(x=pos, color='gray', linestyle='--', linewidth=0.5)\n\n        axs[0].step(x, s1_up, where='post', label=label1, color='navy', linewidth=3)\n        for i, bit in enumerate(s1):\n            axs[0].text(i * 2 + 1, 1.15, str(bit), ha='center', va='bottom', fontsize=16, fontweight='bold')\n        axs[0].set_ylabel(title1)\n        leg0 = axs[0].legend(\n                    loc='upper right', frameon=True, edgecolor='black',\n                    facecolor='white', fontsize=12, fancybox=True\n                )\n        leg0.get_frame().set_facecolor('white')\n        leg0.get_frame().set_edgecolor('black')\n        leg0.get_frame().set_alpha(1.0)\n        setup_grid(axs[0])\n\n        axs[1].step(x, s3, where='post', label=label3, color='darkred', linewidth=3)\n        for i in range(len(s1)):\n            pair = ''.join(str(b) for b in s3[2 * i:2 * i + 2])\n            axs[1].text(i * 2 + 1, 1.15, pair, ha='center', va='bottom', fontsize=16, fontweight='bold')\n        axs[1].set_ylabel(title3)\n        leg1 = axs[1].legend( \n                    loc='upper right', frameon=True, edgecolor='black',\n                    facecolor='white', fontsize=12, fancybox=True\n                )\n        leg1.get_frame().set_facecolor('white')\n        leg1.get_frame().set_edgecolor('black')\n        leg1.get_frame().set_alpha(1.0)\n        setup_grid(axs[1])\n\n        axs[2].step(x, s2_up, where='post', label=label2, color='navy', linewidth=3)\n        for i, bit in enumerate(s2):\n            axs[2].text(i * 2 + 1, 1.15, str(bit), ha='center', va='bottom', fontsize=16, fontweight='bold')\n        axs[2].set_ylabel(title2)\n        leg2 = axs[2].legend(\n                    loc='upper right', frameon=True, edgecolor='black',\n                    facecolor='white', fontsize=12, fancybox=True\n                )\n        leg2.get_frame().set_facecolor('white')\n        leg2.get_frame().set_edgecolor('black')\n        leg2.get_frame().set_alpha(1.0)\n        setup_grid(axs[2])\n\n        axs[3].step(x, s4, where='post', label=label4, color='darkred', linewidth=3)\n        for i in range(len(s2)):\n            pair = ''.join(str(b) for b in s4[2 * i:2 * i + 2])\n            axs[3].text(i * 2 + 1, 1.15, pair, ha='center', va='bottom', fontsize=16, fontweight='bold')\n        axs[3].set_ylabel(title4)\n        leg3 = axs[3].legend(\n                    loc='upper right', frameon=True, edgecolor='black',\n                    facecolor='white', fontsize=12, fancybox=True\n                )\n        leg3.get_frame().set_facecolor('white')\n        leg3.get_frame().set_edgecolor('black')\n        leg3.get_frame().set_alpha(1.0)\n        setup_grid(axs[3])\n\n        plt.xlabel('Bits')\n        plt.tight_layout()\n        plt.subplots_adjust(top=0.92)\n\n        self._save_or_show(fig, save_path)\n\n    def plot_conv(self, s1, s2, s3, label1, label2, label3, title1, title2, title3, save_path=None):\n        r\"\"\"\n        Plota os sinais de entrada e sa\u00edda do codificador convolucional.\n\n        ![conv](assets/transmitter_convolutional.svg)\n\n        Args:\n            s1 (np.ndarray): Sinal de entrada I.\n            s2 (np.ndarray): Sinal de entrada Q.\n            s3 (np.ndarray): Sinal de sa\u00edda codificado.\n            label1 (str): R\u00f3tulo do sinal I de entrada.\n            label2 (str): R\u00f3tulo do sinal Q de entrada.\n            label3 (str): R\u00f3tulo do sinal codificado.\n            title1 (str): T\u00edtulo do sinal I de entrada.\n            title2 (str): T\u00edtulo do sinal Q de entrada.\n            title3 (str): T\u00edtulo do sinal codificado.\n            save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n        \"\"\"\n\n        s1_up = np.repeat(s1, 2)\n        s2_up = np.repeat(s2, 2)\n        s3_up = np.repeat(s3, 2)\n        x = np.arange(len(s2_up))\n        bit_edges = np.arange(0, len(s2_up) + 1, 2)\n\n        # Configura\u00e7\u00e3o do gr\u00e1fico\n        fig, axs = plt.subplots(3, 1, sharex=True)\n        def setup_grid(ax):\n            ax.set_xlim(0, len(s2_up))\n            ax.set_ylim(-0.2, 1.4)\n            ax.grid(False)\n            for pos in bit_edges:\n                ax.axvline(x=pos, color='gray', linestyle='--', linewidth=0.5)\n\n        # Canal I\n        axs[0].step(x, s1_up, where='post', label=label1, color='darkgreen', linewidth=3)\n        for i, bit in enumerate(s1):\n            axs[0].text(i * 2 + 1, 1.15, str(bit), ha='center', va='bottom', fontsize=16, fontweight='bold')\n        axs[0].set_ylabel(title1)\n        leg0 = axs[0].legend(\n                    loc='upper right', frameon=True, edgecolor='black',\n                    facecolor='white', fontsize=12, fancybox=True\n                )\n        leg0.get_frame().set_facecolor('white')\n        leg0.get_frame().set_edgecolor('black')\n        leg0.get_frame().set_alpha(1.0)\n        axs[0].set_yticks([0, 1])\n        setup_grid(axs[0])\n\n        # Canal I\n        axs[1].step(x, s2_up, where='post', label=label2, color='navy', linewidth=3)\n        for i, bit in enumerate(s2):\n            axs[1].text(i * 2 + 1, 1.15, str(bit), ha='center', va='bottom', fontsize=16, fontweight='bold')\n        axs[1].set_ylabel(title2)\n        leg0 = axs[1].legend(\n                    loc='upper right', frameon=True, edgecolor='black',\n                    facecolor='white', fontsize=12, fancybox=True\n                )\n        leg0.get_frame().set_facecolor('white')\n        leg0.get_frame().set_edgecolor('black')\n        leg0.get_frame().set_alpha(1.0)\n        axs[1].set_yticks([0, 1])\n        setup_grid(axs[1])\n\n        # Canal Q\n        axs[2].step(x, s3_up, where='post', label=label3, color='darkred', linewidth=3)\n        for i, bit in enumerate(s3):\n            axs[2].text(i * 2 + 1, 1.15, str(bit), ha='center', va='bottom', fontsize=16, fontweight='bold')\n        axs[2].set_ylabel(title3)\n        leg1 = axs[2].legend(\n                    loc='upper right', frameon=True, edgecolor='black',\n                    facecolor='white', fontsize=12, fancybox=True\n                )\n        leg1.get_frame().set_facecolor('white')\n        leg1.get_frame().set_edgecolor('black')\n        leg1.get_frame().set_alpha(1.0)\n        axs[2].set_yticks([0, 1])\n        setup_grid(axs[2])\n\n        # Configura\u00e7\u00e3o do layout\n        plt.xlabel('Bits')\n        plt.tight_layout()\n        plt.subplots_adjust(top=0.92)\n\n        # Salvar ou mostrar o gr\u00e1fico\n        self._save_or_show(fig, save_path)\n\n    def plot_trellis(self, trellis, num_steps=5, initial_state=0, save_path=None):\n        r\"\"\"\n        Plota o diagrama de treli\u00e7a de um codificador convolucional.\n\n        ![trellis'](assets/example_trelica.svg)\n\n        Args:\n            trellis (dict): Dicion\u00e1rio representando o treli\u00e7a, onde as chaves s\u00e3o estados e os valores s\u00e3o tuplas (pr\u00f3ximo_estado, sa\u00edda).\n            num_steps (int): N\u00famero de passos no tempo a serem plotados.\n            initial_state (int): Estado inicial do treli\u00e7a.\n            save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n\n        \"\"\"\n        states_per_time = defaultdict(set)\n        states_per_time[0].add(initial_state)\n        branches = []\n        for t in range(num_steps):\n            for state in states_per_time[t]:\n                for bit in [0, 1]:\n                    next_state, out = trellis[state][bit]\n                    module = sum(np.abs(out))\n                    branches.append((t, state, bit, next_state, module, out))\n                    states_per_time[t+1].add(next_state)\n\n        all_states = sorted(set(s for states in states_per_time.values() for s in states))\n        state_to_x = {s: i for i, s in enumerate(all_states)}\n        num_states = len(all_states)\n\n        fig = plt.figure(figsize=(0.50*num_states, 1*num_steps))\n        ax = fig.gca()\n        ax.set_xlabel('Estado')\n        ax.set_ylabel('Intervalo de tempo')\n        ax.set_xticks(range(num_states))\n\n        # Formata os labels do eixo x com dois d\u00edgitos hexadecimais\n        ax.set_xticklabels([f\"{hex(s)[2:].upper():0&gt;2}\" for s in all_states])\n        ax.set_yticks(range(num_steps+1))\n        ax.grid(True, axis='x', linestyle='--', alpha=0.3)\n        ax.grid(True, axis='y', linestyle=':', alpha=0.2)\n        ax.invert_yaxis()\n\n        for t, state, bit, next_state, module, out in branches:\n            x = [state_to_x[state], state_to_x[next_state]]\n            y = [t, t+1]\n            color = 'C0' if bit == 0 else 'C1'\n            ax.plot(x, y, color=color, lw=2, alpha=0.8)\n\n        from matplotlib.lines import Line2D\n        legend_elements = [\n            Line2D([0], [0], color='C0', lw=2, label='Bit de entrada 0'),\n            Line2D([0], [0], color='C1', lw=2, label='Bit de entrada 1')\n        ]\n        ax.legend(handles=legend_elements, loc='upper right', frameon=True, fontsize=20)\n\n        for t in range(num_steps+1):\n            for state in states_per_time[t]:\n                ax.plot(state_to_x[state], t, 'o', color='k', markersize=8)\n\n        self._save_or_show(fig, save_path)\n\n    # TODO: adicionar indexes pra o plot do embaralhador.\n    def plot_scrambler(self, s1, s2, s3, s4, s5, s6, label1, label2, label3, label4, label5, label6, save_path=None):\n        r\"\"\"\n        Plota os sinais de entrada e sa\u00edda do embaralhador.\n\n        ![scrambler](assets/example_scrambling.svg)\n\n        Args:\n            s1 (np.ndarray): Sinal de entrada I.\n            s2 (np.ndarray): Sinal de entrada Q.\n            s3 (np.ndarray): Sinal embaralhado I.\n            s4 (np.ndarray): Sinal embaralhado Q.\n            s5 (np.ndarray): Sinal desembaralhado I.\n            s6 (np.ndarray): Sinal desembaralhado Q.\n            label1 (str): R\u00f3tulo do sinal I de entrada.\n            label2 (str): R\u00f3tulo do sinal Q de entrada.\n            label3 (str): R\u00f3tulo do sinal embaralhado I.\n            label4 (str): R\u00f3tulo do sinal embaralhado Q.\n            label5 (str): R\u00f3tulo do sinal desembaralhado I.\n            label6 (str): R\u00f3tulo do sinal desembaralhado Q.\n            save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n        \"\"\"\n\n        fig, axs = plt.subplots(3, 2, figsize=(16, 9), sharex=True)\n\n        superplot(axs[0, 0], s1, label1, \"navy\")\n        superplot(axs[0, 1], s2, label2, \"darkred\")\n        superplot(axs[1, 0], s3, label3, \"navy\")\n        superplot(axs[1, 1], s4, label4, \"darkred\")\n        superplot(axs[2, 0], s5, label5, \"navy\")\n        superplot(axs[2, 1], s6, label6, \"darkred\")\n\n        axs[2, 0].set_xlabel(\"Bits\")\n        axs[2, 1].set_xlabel(\"Bits\")\n        axs[0, 0].set_ylabel(\"Original\")\n        axs[1, 0].set_ylabel(\"Embaralhado\")\n        axs[2, 0].set_ylabel(\"Desembaralhado\")\n\n\n        plt.tight_layout()\n        plt.subplots_adjust(top=0.9)\n\n        self._save_or_show(fig, save_path)\n\n    def plot_preamble(self, s1, s2, label1, label2, title1, title2, save_path=None):\n        r\"\"\"\n        Plota o pre\u00e2mbulo do transmissor, mostrando os sinais I e Q.\n\n        ![preamble.](assets/transmitter_preamble.svg)\n\n        Args:\n            s1 (np.ndarray): Sinal I do pre\u00e2mbulo.\n            s2 (np.ndarray): Sinal Q do pre\u00e2mbulo.\n            label1 (str): R\u00f3tulo do sinal I.\n            label2 (str): R\u00f3tulo do sinal Q.\n            title1 (str): T\u00edtulo do sinal I.\n            title2 (str): T\u00edtulo do sinal Q.\n            save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n        \"\"\"\n\n        # Superamostragem do sinal para o plot\n        s1_up = np.repeat(s1, 2)\n        s2_up = np.repeat(s2, 2)\n        x = np.arange(len(s1_up))\n        bit_edges = np.arange(0, len(s1_up) + 1, 2)\n\n        # Configura\u00e7\u00e3o do gr\u00e1fico\n        fig, axs = plt.subplots(2, 1, sharex=True)\n        def setup_grid(ax):\n            ax.set_xlim(0, len(s1_up))\n            ax.set_ylim(-0.2, 1.4)\n            ax.grid(False)\n            for pos in bit_edges:\n                ax.axvline(x=pos, color='gray', linestyle='--', linewidth=0.5)\n\n        # Canal I\n        axs[0].step(x, s1_up, where='post', label=label1, color='navy', linewidth=3)\n        for i, bit in enumerate(s1):\n            axs[0].text(i * 2 + 1, 1.15, str(bit), ha='center', va='bottom', fontsize=16, fontweight='bold')\n        axs[0].set_ylabel(title1)\n        leg0 = axs[0].legend(\n                    loc='upper right', frameon=True, edgecolor='black',\n                    facecolor='white', fontsize=12, fancybox=True\n                )\n        leg0.get_frame().set_facecolor('white')\n        leg0.get_frame().set_edgecolor('black')\n        leg0.get_frame().set_alpha(1.0)\n        axs[0].set_yticks([0, 1])\n        setup_grid(axs[0])\n\n        # Canal Q\n        axs[1].step(x, s2_up, where='post', label=label2, color='darkred', linewidth=3)\n        for i, bit in enumerate(s2):\n            axs[1].text(i * 2 + 1, 1.15, str(bit), ha='center', va='bottom', fontsize=16, fontweight='bold')\n        axs[1].set_ylabel(title2)\n        leg1 = axs[1].legend(\n                    loc='upper right', frameon=True, edgecolor='black',\n                    facecolor='white', fontsize=12, fancybox=True\n                )\n        leg1.get_frame().set_facecolor('white')\n        leg1.get_frame().set_edgecolor('black')\n        leg1.get_frame().set_alpha(1.0)\n        axs[1].set_yticks([0, 1])\n        setup_grid(axs[1])\n\n        # Configura\u00e7\u00e3o do layout\n        plt.xlabel('Bits')\n        plt.tight_layout()\n        plt.subplots_adjust(top=0.92)\n\n        # Salvar ou mostrar o gr\u00e1fico\n        self._save_or_show(fig, save_path)\n\n    def plot_mux(self, s1, s2, s3, s4, label1, label2, label3, label4, title1, title2, save_path=None):\n        r\"\"\"\n        Plota o multiplexador do transmissor, mostrando os sinais I e Q.\n\n        ![mux](assets/transmitter_multiplexing.svg)\n\n        Args:\n            s1 (np.ndarray): Sinal I do canal I.\n            s2 (np.ndarray): Sinal Q do canal I.\n            s3 (np.ndarray): Sinal I do canal Q.\n            s4 (np.ndarray): Sinal Q do canal Q.\n            label1 (str): R\u00f3tulo do sinal I do canal I.\n            label2 (str): R\u00f3tulo do sinal Q do canal I.\n            label3 (str): R\u00f3tulo do sinal I do canal Q.\n            label4 (str): R\u00f3tulo do sinal Q do canal Q.\n            title1 (str): T\u00edtulo do sinal I do canal I.\n            title2 (str): T\u00edtulo do sinal Q do canal I.\n            save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n        \"\"\"\n        # Concatena\u00e7\u00e3o\n        s5 = np.concatenate((s1, s3))\n        s6 = np.concatenate((s2, s4))\n\n        # Superamostragem\n        s5_up = np.repeat(s5, 2)\n        s6_up = np.repeat(s6, 2)\n        x = np.arange(len(s5_up))\n        bit_edges = np.arange(0, len(s5_up) + 1, 2)\n\n        fig, axs = plt.subplots(2, 1, sharex=True)\n\n        def setup_grid(ax):\n            ax.set_xlim(0, len(s5_up))\n            ax.set_ylim(-0.2, 1.4)\n            ax.grid(False)\n            for pos in bit_edges:\n                ax.axvline(x=pos, color='gray', linestyle='--', linewidth=0.5)\n\n        # --- Channel I ---\n        sep_I = len(s1) * 2\n        x_I1 = x[:sep_I]\n        x_I2 = x[sep_I - 1:]  # Inclui o \u00faltimo ponto anterior\n\n        y_I1 = s5_up[:sep_I]\n        y_I2 = s5_up[sep_I - 1:]\n\n        axs[0].step(x_I1, y_I1, where='post', color='navy', linewidth=3, label=label1)\n        axs[0].step(x_I2, y_I2, where='post', color='darkred', linewidth=3, label=label2)\n\n        for i, bit in enumerate(s5):\n            axs[0].text(i * 2 + 1, 1.15, str(bit), ha='center', va='bottom', fontsize=16, fontweight='bold')\n\n        axs[0].set_ylabel(title1)\n        leg0 = axs[0].legend(\n                    loc='upper right', frameon=True, edgecolor='black',\n                    facecolor='white', fontsize=12, fancybox=True\n                )\n        leg0.get_frame().set_facecolor('white')\n        leg0.get_frame().set_edgecolor('black')\n        leg0.get_frame().set_alpha(1.0)\n        axs[0].set_yticks([0, 1])\n        axs[0].set_yticks([0, 1])\n        setup_grid(axs[0])\n\n        # --- Channel Q ---\n        sep_Q = len(s2) * 2\n        x_Q1 = x[:sep_Q]\n        x_Q2 = x[sep_Q - 1:]\n\n        y_Q1 = s6_up[:sep_Q]\n        y_Q2 = s6_up[sep_Q - 1:]\n\n        axs[1].step(x_Q1, y_Q1, where='post', color='navy', linewidth=3, label=label3)\n        axs[1].step(x_Q2, y_Q2, where='post', color='darkred', linewidth=3, label=label4)\n\n        for i, bit in enumerate(s6):\n            axs[1].text(i * 2 + 1, 1.15, str(bit), ha='center', va='bottom', fontsize=16, fontweight='bold')\n\n        axs[1].set_ylabel(title2)\n        leg1 = axs[1].legend(\n                    loc='upper right', frameon=True, edgecolor='black',\n                    facecolor='white', fontsize=12, fancybox=True\n                )\n        leg1.get_frame().set_facecolor('white')\n        leg1.get_frame().set_edgecolor('black')\n        leg1.get_frame().set_alpha(1.0)\n        axs[1].set_yticks([0, 1])\n        setup_grid(axs[1])\n\n        # Layout final\n        plt.xlabel('Bits')\n\n        num_bits = len(s5)\n        step = 5\n        axs[1].set_xticks(np.arange(0, num_bits * 2, step * 2))      \n        axs[1].set_xticklabels(np.arange(0, num_bits, step)) \n\n        plt.tight_layout()\n        plt.subplots_adjust(top=0.92)\n\n        self._save_or_show(fig, save_path)\n\n    def plot_filter(self, h, t_rc, tb, span, fs, s1, s2, label_h, label1, label2, title_h, title1, title2, t_xlim, save_path=None):\n\n        r\"\"\"\n        Plota o filtro RRC e os sinais I e Q ap\u00f3s a filtragem.\n\n        ![filter](assets/transmitter_filter.svg)\n\n        Args:\n            h (np.ndarray): Resposta ao impulso do filtro RRC.\n            t_rc (np.ndarray): Tempo correspondente \u00e0 resposta ao impulso.\n            tb (float): Tempo de s\u00edmbolo.\n            span (int): N\u00famero de spans do filtro.\n            fs (float): Frequ\u00eancia de amostragem.\n            s1 (np.ndarray): Sinal I filtrado.\n            s2 (np.ndarray): Sinal Q filtrado.\n            label_h (str): R\u00f3tulo do filtro.\n            label1 (str): R\u00f3tulo do sinal I.\n            label2 (str): R\u00f3tulo do sinal Q.\n            title_h (str): T\u00edtulo do filtro.\n            title1 (str): T\u00edtulo do sinal I.\n            title2 (str): T\u00edtulo do sinal Q.\n            t_xlim (float): Limite do eixo x para os sinais I e Q.\n            save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n        \"\"\"\n\n        t_interp = np.arange(len(s1)) / fs\n\n        fig = plt.figure(figsize=(16, 9))\n        gs = gridspec.GridSpec(2, 2, height_ratios=[1, 1])\n\n        # Pulso RRC\n        ax_rcc = fig.add_subplot(gs[0, :])\n        ax_rcc.plot(t_rc, h, label=label_h, color='red', linewidth=2)\n        ax_rcc.set_title(title_h)\n        ax_rcc.set_ylabel('Amplitude')\n        ax_rcc.grid(True)\n        leg_rcc = ax_rcc.legend(\n            loc='upper right', frameon=True, edgecolor='black',\n            facecolor='white', fontsize=12, fancybox=True\n        )\n        leg_rcc.get_frame().set_facecolor('white')\n        leg_rcc.get_frame().set_edgecolor('black')\n        leg_rcc.get_frame().set_alpha(1.0)\n        ax_rcc.set_xlim(-span*tb, span*tb)\n\n        # Sinal I\n        ax_I = fig.add_subplot(gs[1, 0])\n        ax_I.plot(t_interp, s1, label= label1, color='navy', linewidth=2)\n        ax_I.set_title(title1)\n        ax_I.set_xlabel('Tempo (s)')\n        ax_I.set_ylabel('Amplitude')\n        ax_I.set_xlim(0, t_xlim)\n        ax_I.grid(True)\n        leg_I = ax_I.legend(\n            loc='upper right', frameon=True, edgecolor='black',\n            facecolor='white', fontsize=12, fancybox=True\n        )\n        leg_I.get_frame().set_facecolor('white')\n        leg_I.get_frame().set_edgecolor('black')\n        leg_I.get_frame().set_alpha(1.0)\n\n        # Sinal Q\n        ax_Q = fig.add_subplot(gs[1, 1])\n        ax_Q.plot(t_interp, s2, label=label2, color='darkgreen', linewidth=2)\n        ax_Q.set_title(title2)\n        ax_Q.set_xlabel('Tempo (s)')\n        ax_Q.set_xlim(0, t_xlim)\n        ax_Q.grid(True)\n        leg_Q = ax_Q.legend(\n            loc='upper right', frameon=True, edgecolor='black',\n            facecolor='white', fontsize=12, fancybox=True\n        )\n        leg_Q.get_frame().set_facecolor('white')\n        leg_Q.get_frame().set_edgecolor('black')\n        leg_Q.get_frame().set_alpha(1.0)\n\n        plt.tight_layout()\n        plt.subplots_adjust(top=0.92, hspace=0.4)\n\n        self._save_or_show(fig, save_path)\n\n    def plot_modulation_time(self, s1, s2, s3, label1, label2, label3, title1, title2, fs, t_xlim, save_path=None):\n        r\"\"\"\n        Plota os sinais de modula\u00e7\u00e3o no dom\u00ednio do tempo.\n\n        ![modulation_time](assets/transmitter_modulator_time.svg)\n\n        Args:\n            s1 (np.ndarray): Sinal I modulado.\n            s2 (np.ndarray): Sinal Q modulado.\n            s3 (np.ndarray): Sinal de modula\u00e7\u00e3o resultante.\n            label1 (str): R\u00f3tulo do sinal I.\n            label2 (str): R\u00f3tulo do sinal Q.\n            label3 (str): R\u00f3tulo do sinal de modula\u00e7\u00e3o.\n            title1 (str): T\u00edtulo do sinal I.\n            title2 (str): T\u00edtulo do sinal Q.\n            fs (float): Frequ\u00eancia de amostragem.\n            t_xlim (float): Limite do eixo x para os sinais I e Q.\n            save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n        \"\"\"\n\n        t = np.arange(len(s1)) / fs\n        fig = plt.figure(figsize=(16, 8))\n        gs = gridspec.GridSpec(2, 1, height_ratios=[1, 1])\n\n        ax1 = fig.add_subplot(gs[0, 0])\n        ax1.plot(t, s1, label=label1, color='navy', linewidth=2)\n        ax1.plot(t, s2, label=label2, color='darkgreen', linewidth=2)\n        ax1.set_xlim(0, t_xlim)\n        ax1.set_ylabel('Amplitude')\n        ax1.set_title(title1)\n        ax1.grid(True)\n        leg1 = ax1.legend(loc='upper right', frameon=True, edgecolor='black', facecolor='white', fontsize=14, fancybox=True)\n        leg1.get_frame().set_facecolor('white')\n        leg1.get_frame().set_edgecolor('black')\n        leg1.get_frame().set_alpha(1.0)\n\n        ax2 = fig.add_subplot(gs[1, 0])\n        ax2.plot(t, s3, label=label3, color='darkred', linewidth=1.5)\n        ax2.set_xlim(0, t_xlim)\n        ax2.set_xlabel('Tempo (s)')\n        ax2.set_ylabel('Amplitude')\n        ax2.set_title(title2)\n        ax2.grid(True)\n        leg2 = ax2.legend(loc='upper right', frameon=True, edgecolor='black', facecolor='white', fontsize=14, fancybox=True)\n        leg2.get_frame().set_facecolor('white')\n        leg2.get_frame().set_edgecolor('black')\n        leg2.get_frame().set_alpha(1.0)\n\n        plt.tight_layout()\n        plt.subplots_adjust(hspace=0.3)\n\n        self._save_or_show(fig, save_path)\n\n    def plot_modulation_eye(self, s1, s2, label1, label2, title1, title2, fs, Rb, save_path=None):\n        r\"\"\"\n        Plota o diagrama de olho dos sinais I e Q ap\u00f3s a modula\u00e7\u00e3o.\n\n        ![modulation_eye](assets/example_eye.svg)\n\n        Args:\n            s1 (np.ndarray): Sinal I modulado.\n            s2 (np.ndarray): Sinal Q modulado.\n            label1 (str): R\u00f3tulo do sinal I.\n            label2 (str): R\u00f3tulo do sinal Q.\n            title1 (str): T\u00edtulo do sinal I.\n            title2 (str): T\u00edtulo do sinal Q.\n            fs (float): Frequ\u00eancia de amostragem.\n            Rb (float): Taxa de bits.\n            save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n        \"\"\"\n\n        sps = int(fs / Rb)\n        eye_len = 2 * sps\n        n_traces = (len(s1) - eye_len) // sps\n        fig = plt.figure(figsize=(16, 7))\n        gs = gridspec.GridSpec(1, 2, width_ratios=[1, 1])\n\n        # Diagrama de olho dI\n        ax_eyeI = fig.add_subplot(gs[0, 0])\n        for i in range(n_traces):\n            start = i * sps\n            ax_eyeI.plot(np.arange(eye_len) / fs * 1e3, s1[start:start+eye_len], color='navy', alpha=0.18, linewidth=2, label=label1)\n        ax_eyeI.set_xlabel('Tempo (ms)')\n        ax_eyeI.set_ylabel('Amplitude')\n        ax_eyeI.set_title(title1)\n        ax_eyeI.grid(True)\n        ax_eyeI.set_xlim(0, eye_len / fs * 1e3)\n\n        # Diagrama de olho dQ\n        ax_eyeQ = fig.add_subplot(gs[0, 1])\n        for i in range(n_traces):\n            start = i * sps\n            ax_eyeQ.plot(np.arange(eye_len) / fs * 1e3, s2[start:start+eye_len], color='darkgreen', alpha=0.18, linewidth=2, label=label2)\n        ax_eyeQ.set_xlabel('Tempo (ms)')\n        ax_eyeQ.set_ylabel('Amplitude')\n        ax_eyeQ.set_title(title2)\n        ax_eyeQ.grid(True)\n        ax_eyeQ.set_xlim(0, eye_len / fs * 1e3)\n\n        plt.tight_layout()\n        self._save_or_show(fig, save_path)\n\n    def plot_modulation_iq(self, s1, s2, label1, label2, title1, title2, save_path=None, amplitude=None):\n\n        r\"\"\"\n        Plota o diagrama IQ dos sinais I e Q ap\u00f3s a modula\u00e7\u00e3o.\n\n        ![modulation_iq](assets/transmitter_modulator_iq.svg)\n\n        Args:\n            s1 (np.ndarray): Sinal I modulado.\n            s2 (np.ndarray): Sinal Q modulado.\n            label1 (str): R\u00f3tulo do sinal I.\n            label2 (str): R\u00f3tulo do sinal Q.\n            title1 (str): T\u00edtulo do sinal I.\n            title2 (str): T\u00edtulo do sinal Q.\n            save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n            amplitude (float, optional): Amplitude dos pontos QPSK. Se None, a amplitude \u00e9 calculada automaticamente.\n        \"\"\"\n\n        s1_c = s1 - np.mean(s1)\n        s2_c = s2 - np.mean(s2)\n        fig = plt.figure(figsize=(16, 9))\n        gs = gridspec.GridSpec(1, 2, width_ratios=[1, 1])\n\n        ax_const = fig.add_subplot(gs[0, 0])\n        if amplitude is None:\n            amp = np.mean(np.abs(np.concatenate([s1_c*1.1, s2_c*1.1])))\n        else:\n            amp = amplitude\n\n        ax_iq = fig.add_subplot(gs[0, 1])\n        ax_iq.scatter(s1_c, s2_c, color='darkgreen', alpha=0.5, s=2, label=label1)\n        ax_iq.set_xlabel(r'$I$')\n        ax_iq.set_ylabel(r'$Q$')\n        ax_iq.set_title(title1)\n\n        for v in [-amp, amp]:\n            ax_iq.axhline(v, color='darkred', linestyle='--', linewidth=1, alpha=0.6, zorder=0)\n            ax_iq.axvline(v, color='darkred', linestyle='--', linewidth=1, alpha=0.6, zorder=0)\n        from matplotlib.lines import Line2D\n        custom_legend = [Line2D([0], [0], marker='o', color='w', label='Amostras IQ',\n                                markerfacecolor='darkgreen', markersize=16, alpha=0.7)]\n        leg_iq = ax_iq.legend(handles=custom_legend,\n                loc='upper right', frameon=True, edgecolor='black',\n                facecolor='white', fontsize=12, fancybox=True\n            )\n        leg_iq.get_frame().set_facecolor('white')\n        leg_iq.get_frame().set_edgecolor('black')\n        leg_iq.get_frame().set_alpha(1.0)\n        ax_iq.set_xlim(-0.06, 0.06)\n        ax_iq.set_ylim(-0.06, 0.06)\n        ax_iq.set_aspect('equal')\n\n        qpsk_points = np.array([[amp, amp], [amp, -amp], [-amp, amp], [-amp, -amp]])\n        ax_const.scatter(qpsk_points[:, 0], qpsk_points[:, 1], color='black', s=160, marker='o', label=label2, linewidth=5)\n        ax_const.set_xlabel(r'$I$')\n        ax_const.set_ylabel(r'$Q$')\n        ax_const.set_title(title2)\n\n        for v in [-amp, amp]:\n            ax_const.axhline(v, color='darkred', linestyle='--', linewidth=1, alpha=0.6, zorder=0)\n            ax_const.axvline(v, color='darkred', linestyle='--', linewidth=1, alpha=0.6, zorder=0)\n        leg_const = ax_const.legend(\n                loc='upper right', frameon=True, edgecolor='black',\n                facecolor='white', fontsize=12, fancybox=True\n            )\n        leg_const.get_frame().set_facecolor('white')\n        leg_const.get_frame().set_edgecolor('black')\n        leg_const.get_frame().set_alpha(1.0)\n        ax_const.set_xlim(-0.06, 0.06)\n        ax_const.set_ylim(-0.06, 0.06)\n        ax_const.set_aspect('equal')\n\n        plt.tight_layout()\n        self._save_or_show(fig, save_path)\n\n    def plot_modulation_freq(self, s1, s2, s3, label1, label2, label3, title1, title2, title3, fs, fc, save_path=None):\n        r\"\"\"\n        Plota o espectro dos sinais I, Q e o sinal modulado no dom\u00ednio da frequ\u00eancia.\n\n        ![modulation_freq](assets/transmitter_modulator_freq.svg)\n\n        Args:\n            s1 (np.ndarray): Sinal I modulado.\n            s2 (np.ndarray): Sinal Q modulado.\n            s3 (np.ndarray): Sinal modulado resultante.\n            label1 (str): R\u00f3tulo do sinal I.\n            label2 (str): R\u00f3tulo do sinal Q.\n            label3 (str): R\u00f3tulo do sinal modulado.\n            title1 (str): T\u00edtulo do sinal I.\n            title2 (str): T\u00edtulo do sinal Q.\n            title3 (str): T\u00edtulo do sinal modulado.\n            fs (float): Frequ\u00eancia de amostragem.\n            fc (float): Frequ\u00eancia de portadora.\n            save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n        \"\"\"\n\n        freqs = np.fft.fftshift(np.fft.fftfreq(len(s3), d=1/fs))\n        fft_dI = np.fft.fftshift(np.fft.fft(s1))\n        fft_dQ = np.fft.fftshift(np.fft.fft(s2))\n        fft_s = np.fft.fftshift(np.fft.fft(s3))\n\n        fig = plt.figure(figsize=(16, 10))\n        gs = gridspec.GridSpec(2, 2)\n\n        if fc &gt; 1000:\n            freqs = freqs / 1000\n            x_label = \"Frequ\u00eancia (kHz)\"\n            x_limit = (-2.5 * fc / 1000, 2.5 * fc / 1000)\n            x_limit_comp = (- 0.5 * fc / 1000, 0.5 * fc / 1000)\n        else:\n            x_label = \"Frequ\u00eancia (Hz)\"\n            x_limit = (-2.5 * fc, 2.5 * fc)\n            x_limit_comp = (- 0.5 * fc, 0.5 * fc)\n\n\n        # Linha 1 - espectro de s(t)\n        ax1 = fig.add_subplot(gs[0, :])\n        ax1.plot(freqs, mag2db(fft_s), color='darkred', label=label3)\n        ax1.set_xlim(x_limit)\n        ax1.set_xlabel(x_label)\n        ax1.set_ylim(-80, 5)\n        ax1.set_ylabel('Magnitude (dB)')\n        ax1.set_title(title3)\n        ax1.grid(True)\n        ax1.legend()\n\n        # Linha 2 - espectro de dI(t)\n        ax2 = fig.add_subplot(gs[1, 0])\n        ax2.plot(freqs, mag2db(fft_dI), color='navy', label=label1)\n        ax2.set_xlim(x_limit_comp)\n        ax2.set_xlabel(x_label)\n        ax2.set_ylim(-80, 5)\n        ax2.set_ylabel('Magnitude (dB)')\n        ax2.set_title(title1)\n        ax2.grid(True)\n        ax2.legend()\n\n        # Linha 2 - espectro de dQ(t)\n        ax3 = fig.add_subplot(gs[1, 1])\n        ax3.plot(freqs, mag2db(fft_dQ), color='darkgreen', label=label2)\n        ax3.set_xlim(x_limit_comp)\n        ax3.set_xlabel(x_label)\n        ax3.set_ylim(-80, 5)\n        ax3.set_ylabel('Magnitude (dB)')    \n        ax3.set_title(title2)\n        ax3.grid(True)\n        ax3.legend()\n\n        plt.tight_layout()\n        self._save_or_show(fig, save_path)\n\n    def plot_demodulation_freq(self, s1, s2, label1, label2, title1, title2, fs, fc, save_path=None):\n        fig_fft_prod = plt.figure(figsize=(16, 8))\n        gs_fft = gridspec.GridSpec(2, 1)\n\n        # FFT de y_I_\n        YI_f = np.fft.fftshift(np.fft.fft(s1))\n        freqs = np.fft.fftshift(np.fft.fftfreq(len(YI_f), d=1/fs))\n        YI_db = mag2db(YI_f)\n\n        ax_fft_i = fig_fft_prod.add_subplot(gs_fft[0])\n        ax_fft_i.plot(freqs, YI_db, color='blue', label=r\"$|X_I(f)|$\")\n        ax_fft_i.set_xlim(-2.5 * fc, 2.5 * fc)\n        ax_fft_i.set_ylim(-60, 5)\n        ax_fft_i.set_title(r\"Espectro do canal I - $x_I(t)$\")\n        ax_fft_i.set_xlabel(\"Frequ\u00eancia (Hz)\")\n        ax_fft_i.set_ylabel(\"Magnitude (dB)\")\n        ax_fft_i.grid(True)\n        ax_fft_i.legend()\n        leg_fft_i = ax_fft_i.legend(\n            loc='upper right', frameon=True, edgecolor='black',\n            facecolor='white', fontsize=12, fancybox=True\n        )\n        leg_fft_i.get_frame().set_facecolor('white')\n        leg_fft_i.get_frame().set_edgecolor('black')\n        leg_fft_i.get_frame().set_alpha(1.0)\n\n        # FFT de y_Q_\n        YQ_f = np.fft.fftshift(np.fft.fft(s2))\n        YQ_db = mag2db(YQ_f)\n\n        ax_fft_q = fig_fft_prod.add_subplot(gs_fft[1])\n        ax_fft_q.plot(freqs, YQ_db, color='green', label=r\"$|Y_Q(f)|$\")\n        ax_fft_q.set_xlim(-2.5 * fc, 2.5 * fc)\n        ax_fft_q.set_ylim(-60, 5)\n        ax_fft_q.set_title(r\"Espectro do canal Q - $y_Q(t)$\")\n        ax_fft_q.set_xlabel(\"Frequ\u00eancia (Hz)\")\n        ax_fft_q.set_ylabel(\"Magnitude (dB)\")\n        ax_fft_q.grid(True)\n        ax_fft_q.legend()\n        leg_fft_q = ax_fft_q.legend(\n            loc='upper right', frameon=True, edgecolor='black',\n            facecolor='white', fontsize=12, fancybox=True\n        )\n        leg_fft_q.get_frame().set_facecolor('white')\n        leg_fft_q.get_frame().set_edgecolor('black')\n        leg_fft_q.get_frame().set_alpha(1.0)\n\n        plt.tight_layout()\n        self._save_or_show(fig_fft_prod, save_path)\n\n    def plot_freq_receiver(self, y_I, y_Q, fs, fc, save_path=None):\n        \"\"\"\n        Plota os espectros de frequ\u00eancia dos canais I e Q ap\u00f3s a demodula\u00e7\u00e3o.\n\n        Args:\n            y_I (np.ndarray): Sinal do canal I no dom\u00ednio do tempo\n            y_Q (np.ndarray): Sinal do canal Q no dom\u00ednio do tempo\n            fs (float): Frequ\u00eancia de amostragem (Hz)\n            fc (float): Frequ\u00eancia da portadora (Hz)\n            save_path (str, optional): Caminho para salvar a figura. Se None, mostra a figura.\n        \"\"\"\n        fig = plt.figure(figsize=(16, 8))\n        gs = gridspec.GridSpec(2, 1)\n\n        # FFT do canal I\n        YI_f = np.fft.fftshift(np.fft.fft(y_I))\n        freqs = np.fft.fftshift(np.fft.fftfreq(len(y_I), d=1/fs))\n        YI_db = mag2db(YI_f)  # Normalizado\n\n        ax_i = fig.add_subplot(gs[0])\n        ax_i.plot(freqs, YI_db, color='blue', label=r\"$|Y_I(f)|$\")\n        ax_i.set_xlim(-2.5 * fc, 2.5 * fc)\n        ax_i.set_ylim(-60, 5)\n        ax_i.set_title(r\"Espectro do canal I - $y_I(t)$\")\n        ax_i.set_xlabel(\"Frequ\u00eancia (Hz)\")\n        ax_i.set_ylabel(\"Magnitude (dB)\")\n        ax_i.grid(True)\n        leg_i = ax_i.legend(\n            loc='upper right', frameon=True, edgecolor='black',\n            facecolor='white', fontsize=12, fancybox=True\n        )\n        leg_i.get_frame().set_facecolor('white')\n        leg_i.get_frame().set_edgecolor('black')\n        leg_i.get_frame().set_alpha(1.0)\n\n        # FFT do canal Q\n        YQ_f = np.fft.fftshift(np.fft.fft(y_Q))\n        YQ_db = mag2db(YQ_f)  # Normalizado\n\n        ax_q = fig.add_subplot(gs[1])\n        ax_q.plot(freqs, YQ_db, color='green', label=r\"$|Y_Q(f)|$\")\n        ax_q.set_xlim(-2.5 * fc, 2.5 * fc)\n        ax_q.set_ylim(-60, 5)\n        ax_q.set_title(r\"Espectro do canal Q - $y_Q(t)$\")\n        ax_q.set_xlabel(\"Frequ\u00eancia (Hz)\")\n        ax_q.set_ylabel(\"Magnitude (dB)\")\n        ax_q.grid(True)\n        leg_q = ax_q.legend(\n            loc='upper right', frameon=True, edgecolor='black',\n            facecolor='white', fontsize=12, fancybox=True\n        )\n        leg_q.get_frame().set_facecolor('white')\n        leg_q.get_frame().set_edgecolor('black')\n        leg_q.get_frame().set_alpha(1.0)\n\n        plt.tight_layout()\n        self._save_or_show(fig, save_path)\n\n\n    def plot_impulse_response(self, t_imp, impulse_response, label_imp, t_unit=\"ms\", xlim=None, save_path=None):\n        \"\"\"\n        Plota apenas a resposta ao impulso de um filtro.\n\n        Args:\n            t_imp (np.ndarray): Vetor de tempo da resposta ao impulso.\n            impulse_response (np.ndarray): Amostras da resposta ao impulso.\n            label_imp (str): R\u00f3tulo da resposta ao impulso.\n            title_imp (str): T\u00edtulo do gr\u00e1fico.\n            t_unit (str, optional): Unidade de tempo no eixo X (\"ms\" ou \"s\"). Default \u00e9 \"ms\".\n            save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n        \"\"\"\n        fig = plt.figure(figsize=(12, 6))\n        ax = fig.add_subplot(1, 1, 1)\n\n        if t_unit == \"ms\":\n            t_plot = t_imp * 1000\n            x_label = \"Tempo (ms)\"\n        else:\n            t_plot = t_imp\n            x_label = \"Tempo (s)\"\n\n        ax.plot(t_plot, impulse_response, color='red', label=label_imp, linewidth=2)\n        ax.set_xlabel(x_label)\n        ax.set_ylabel(\"Amplitude\")\n        ax.grid(True)\n\n        if xlim is not None:\n            ax.set_xlim(-xlim, xlim)\n\n        leg = ax.legend(loc='upper right', frameon=True, edgecolor='black',\n                        facecolor='white', fontsize=12, fancybox=True)\n        leg.get_frame().set_facecolor('white')\n        leg.get_frame().set_edgecolor('black')\n        leg.get_frame().set_alpha(1.0)\n\n        plt.tight_layout()\n        self._save_or_show(fig, save_path)\n\n    def plot_filtered_signals(self, t_imp, impulse_response, t_interp, d_I_rec, d_Q_rec,\n                              label_imp, label_I, label_Q,\n                              title_imp, title_I, title_Q, t_xlim, save_path=None):\n        \"\"\"\n        Plota a resposta ao impulso do filtro passa-baixa e os sinais I e Q filtrados.\n\n        Args:\n            t_imp (np.ndarray): Vetor de tempo da resposta ao impulso.\n            impulse_response (np.ndarray): Amostras da resposta ao impulso.\n            t_interp (np.ndarray): Vetor de tempo dos sinais filtrados.\n            d_I_rec (np.ndarray): Sinal I filtrado.\n            d_Q_rec (np.ndarray): Sinal Q filtrado.\n            label_imp (str): R\u00f3tulo da resposta ao impulso.\n            label_I (str): R\u00f3tulo do canal I filtrado.\n            label_Q (str): R\u00f3tulo do canal Q filtrado.\n            title_imp (str): T\u00edtulo do gr\u00e1fico da resposta ao impulso.\n            title_I (str): T\u00edtulo do gr\u00e1fico do canal I.\n            title_Q (str): T\u00edtulo do gr\u00e1fico do canal Q.\n            t_xlim (float): Limite do eixo X para os canais I e Q.\n            save_path (str, optional): Caminho para salvar o gr\u00e1fico.\n        \"\"\"\n\n        fig_filt = plt.figure(figsize=(16, 10))\n        gs_filt = gridspec.GridSpec(3, 1)\n\n        # Resposta ao impulso\n        ax_imp = fig_filt.add_subplot(gs_filt[0])\n        ax_imp.plot(t_imp * 1000, impulse_response, color='red', label=label_imp, linewidth=2)\n        ax_imp.set_title(title_imp)\n        ax_imp.set_xlabel(\"Tempo (ms)\")\n        ax_imp.set_ylabel(\"Amplitude\")\n        ax_imp.grid(True)\n        leg_imp = ax_imp.legend(loc='upper right', frameon=True, edgecolor='black',\n                                facecolor='white', fontsize=12, fancybox=True)\n        leg_imp.get_frame().set_facecolor('white')\n        leg_imp.get_frame().set_edgecolor('black')\n        leg_imp.get_frame().set_alpha(1.0)\n\n        # I filtrado\n        ax_fi = fig_filt.add_subplot(gs_filt[1])\n        ax_fi.plot(t_interp, d_I_rec, color='blue', label=label_I)\n        ax_fi.set_title(title_I)\n        ax_fi.set_xlim(0, t_xlim)\n        ax_fi.set_xlabel(\"Tempo (s)\")\n        ax_fi.set_ylabel(\"Amplitude\")\n        ax_fi.grid(True)\n        leg_fi = ax_fi.legend(loc='upper right', frameon=True, edgecolor='black',\n                              facecolor='white', fontsize=12, fancybox=True)\n        leg_fi.get_frame().set_facecolor('white')\n        leg_fi.get_frame().set_edgecolor('black')\n        leg_fi.get_frame().set_alpha(1.0)\n\n        # Q filtrado\n        ax_fq = fig_filt.add_subplot(gs_filt[2])\n        ax_fq.plot(t_interp, d_Q_rec, color='green', label=label_Q)\n        ax_fq.set_title(title_Q)\n        ax_fq.set_xlim(0, t_xlim)\n        ax_fq.set_xlabel(\"Tempo (s)\")\n        ax_fq.set_ylabel(\"Amplitude\")\n        ax_fq.grid(True)\n        leg_fq = ax_fq.legend(loc='upper right', frameon=True, edgecolor='black',\n                              facecolor='white', fontsize=12, fancybox=True)\n        leg_fq.get_frame().set_facecolor('white')\n        leg_fq.get_frame().set_edgecolor('black')\n        leg_fq.get_frame().set_alpha(1.0)\n\n        plt.tight_layout()\n        self._save_or_show(fig_filt, save_path)\n\n    def plot_lowpass_filter(self, t_imp, impulse_response, t_interp, d_I_rec, d_Q_rec, t_xlim=0.1, save_path=None):\n        \"\"\"\n        Plota a resposta ao impulso de um filtro passa-baixa e os sinais I e Q ap\u00f3s filtragem.\n\n        Args:\n            t_imp (np.ndarray): Vetor de tempo da resposta ao impulso (em segundos).\n            impulse_response (np.ndarray): Amostras da resposta ao impulso.\n            t_interp (np.ndarray): Vetor de tempo dos sinais filtrados (em segundos).\n            d_I_rec (np.ndarray): Sinal I filtrado.\n            d_Q_rec (np.ndarray): Sinal Q filtrado.\n            t_xlim (float): Limite do eixo X (em segundos) para os sinais filtrados.\n            save_path (str, optional): Caminho para salvar a figura. Se None, exibe na tela.\n        \"\"\"\n        fig_filt = plt.figure(figsize=(16, 10))\n        gs_filt = gridspec.GridSpec(3, 1)\n\n        # Resposta ao impulso\n        ax_imp = fig_filt.add_subplot(gs_filt[0])\n        ax_imp.plot(t_imp * 1000, impulse_response, color='red', label='Resposta ao Impulso - FPB', linewidth=2)\n        ax_imp.set_title(\"Resposta ao Impulso do Filtro Passa-Baixa\")\n        ax_imp.set_xlim(0, 2)\n        ax_imp.set_xlabel(\"Tempo (ms)\")\n        ax_imp.set_ylabel(\"Amplitude\")\n        ax_imp.grid(True)\n        leg_imp = ax_imp.legend(\n            loc='upper right', frameon=True, edgecolor='black',\n            facecolor='white', fontsize=12, fancybox=True\n        )\n        leg_imp.get_frame().set_facecolor('white')\n        leg_imp.get_frame().set_edgecolor('black')\n        leg_imp.get_frame().set_alpha(1.0)\n\n        # I filtrado\n        ax_fi = fig_filt.add_subplot(gs_filt[1])\n        ax_fi.plot(t_interp, d_I_rec, color='blue', label=r\"$d_I(t)$ filtrado\")\n        ax_fi.set_title(\"Canal I ap\u00f3s filtragem passa-baixa\")\n        ax_fi.set_xlim(0, t_xlim)\n        ax_fi.set_xlabel(\"Tempo (s)\")\n        ax_fi.set_ylabel(\"Amplitude\")\n        ax_fi.grid(True)\n        leg_fi = ax_fi.legend(\n            loc='upper right', frameon=True, edgecolor='black',\n            facecolor='white', fontsize=12, fancybox=True\n        )\n        leg_fi.get_frame().set_facecolor('white')\n        leg_fi.get_frame().set_edgecolor('black')\n        leg_fi.get_frame().set_alpha(1.0)\n\n        # Q filtrado\n        ax_fq = fig_filt.add_subplot(gs_filt[2])\n        ax_fq.plot(t_interp, d_Q_rec, color='green', label=r\"$d_Q(t)$ filtrado\")\n        ax_fq.set_title(\"Canal Q ap\u00f3s filtragem passa-baixa\")\n        ax_fq.set_xlim(0, t_xlim)\n        ax_fq.set_xlabel(\"Tempo (s)\")\n        ax_fq.set_ylabel(\"Amplitude\")\n        ax_fq.grid(True)\n        leg_fq = ax_fq.legend(\n            loc='upper right', frameon=True, edgecolor='black',\n            facecolor='white', fontsize=12, fancybox=True\n        )\n        leg_fq.get_frame().set_facecolor('white')\n        leg_fq.get_frame().set_edgecolor('black')\n        leg_fq.get_frame().set_alpha(1.0)\n\n        plt.tight_layout()\n        self._save_or_show(fig_filt, save_path)\n\n    def plot_lowpass_freq(self, t_imp, impulse_response,\n                                       y_I_, y_Q_, d_I_rec, d_Q_rec,\n                                       fs, fc, save_path=None):\n        \"\"\"\n        Plota a resposta ao impulso de um filtro passa-baixa e os espectros\n        antes e depois da filtragem para os canais I e Q.\n\n        Args:\n            t_imp (np.ndarray): Vetor de tempo da resposta ao impulso (em segundos).\n            impulse_response (np.ndarray): Resposta ao impulso do filtro.\n            y_I_ (np.ndarray): Sinal I antes da filtragem.\n            y_Q_ (np.ndarray): Sinal Q antes da filtragem.\n            d_I_rec (np.ndarray): Sinal I ap\u00f3s filtragem.\n            d_Q_rec (np.ndarray): Sinal Q ap\u00f3s filtragem.\n            fs (float): Frequ\u00eancia de amostragem (Hz).\n            fc (float): Frequ\u00eancia central para o plot (Hz).\n            save_path (str, optional): Caminho para salvar a figura. Se None, exibe na tela.\n        \"\"\"\n        fig_spec = plt.figure(figsize=(16, 10))\n        gs_spec = gridspec.GridSpec(3, 2, height_ratios=[1, 1, 1])\n\n        # Linha 1 (0, :) - Resposta ao impulso\n        ax_impulse = fig_spec.add_subplot(gs_spec[0, :])\n        ax_impulse.plot(t_imp * 1000, impulse_response, color='red', linewidth=2, label='Resposta ao Impulso - FPB')\n        ax_impulse.set_title(\"Resposta ao Impulso do Filtro Passa-Baixa\")\n        ax_impulse.set_xlabel(\"Tempo (ms)\")\n        ax_impulse.set_xlim(0, 2)\n        ax_impulse.set_ylabel(\"Amplitude\")\n        ax_impulse.grid(True)\n        leg_impulse = ax_impulse.legend(\n            loc='upper right', frameon=True, edgecolor='black',\n            facecolor='white', fontsize=12, fancybox=True\n        )\n        leg_impulse.get_frame().set_facecolor('white')\n        leg_impulse.get_frame().set_edgecolor('black')\n        leg_impulse.get_frame().set_alpha(1.0)\n\n        # Frequ\u00eancias\n        freqs = np.fft.fftshift(np.fft.fftfreq(len(y_I_), d=1/fs))\n\n        # FFT antes da filtragem (y'_I)\n        YI_db = mag2db(np.fft.fftshift(np.fft.fft(y_I_)))\n        ax_yi = fig_spec.add_subplot(gs_spec[1, 0])\n        ax_yi.plot(freqs, YI_db, color='blue', label=r\"$|X'_I(f)|$\")\n        ax_yi.set_xlim(-2.5 * fc, 2.5 * fc)\n        ax_yi.set_ylim(-80, 5)\n        ax_yi.set_title(r\"Espectro de $x'_I(t)$ (Antes do FPB)\")\n        ax_yi.set_xlabel(\"Frequ\u00eancia (Hz)\")\n        ax_yi.set_ylabel(\"Magnitude (dB)\")\n        ax_yi.grid(True)\n        leg_yi = ax_yi.legend(\n            loc='upper right', frameon=True, edgecolor='black',\n            facecolor='white', fontsize=12, fancybox=True\n        )\n        leg_yi.get_frame().set_facecolor('white')\n        leg_yi.get_frame().set_edgecolor('black')\n        leg_yi.get_frame().set_alpha(1.0)\n\n        # FFT depois da filtragem (d_I)\n        DI_db = mag2db(np.fft.fftshift(np.fft.fft(d_I_rec)))\n        ax_di = fig_spec.add_subplot(gs_spec[1, 1])\n        ax_di.plot(freqs, DI_db, color='darkblue', label=r\"$|d'_I(f)|$\")\n        ax_di.set_xlim(-2.5 * fc, 2.5 * fc)\n        ax_di.set_ylim(-80, 5)\n        ax_di.set_title(r\"Espectro de $d'_I(t)$ (Ap\u00f3s FPB)\")\n        ax_di.set_xlabel(\"Frequ\u00eancia (Hz)\")\n        ax_di.set_ylabel(\"Magnitude (dB)\")\n        ax_di.grid(True)\n        leg_di = ax_di.legend(\n            loc='upper right', frameon=True, edgecolor='black',\n            facecolor='white', fontsize=12, fancybox=True\n        )\n        leg_di.get_frame().set_facecolor('white')\n        leg_di.get_frame().set_edgecolor('black')\n        leg_di.get_frame().set_alpha(1.0)\n\n        # FFT antes da filtragem (y'_Q)\n        YQ_db = mag2db(np.fft.fftshift(np.fft.fft(y_Q_)))\n        ax_yq = fig_spec.add_subplot(gs_spec[2, 0])\n        ax_yq.plot(freqs, YQ_db, color='green', label=r\"$|Y'_Q(f)|$\")\n        ax_yq.set_xlim(-2.5 * fc, 2.5 * fc)\n        ax_yq.set_ylim(-90, 5)\n        ax_yq.set_title(r\"Espectro de $y'_Q(t)$ (Antes do FPB)\")\n        ax_yq.set_xlabel(\"Frequ\u00eancia (Hz)\")\n        ax_yq.set_ylabel(\"Magnitude (dB)\")\n        ax_yq.grid(True)\n        leg_yq = ax_yq.legend(\n            loc='upper right', frameon=True, edgecolor='black',\n            facecolor='white', fontsize=12, fancybox=True\n        )\n        leg_yq.get_frame().set_facecolor('white')\n        leg_yq.get_frame().set_edgecolor('black')\n        leg_yq.get_frame().set_alpha(1.0)\n\n        # FFT depois da filtragem (d_Q)\n        DQ_db = mag2db(np.fft.fftshift(np.fft.fft(d_Q_rec)))\n        ax_dq = fig_spec.add_subplot(gs_spec[2, 1])\n        ax_dq.plot(freqs, DQ_db, color='darkgreen', label=r\"$|d_Q(f)|$\")\n        ax_dq.set_xlim(-2.5 * fc, 2.5 * fc)\n        ax_dq.set_ylim(-90, 5)\n        ax_dq.set_title(r\"Espectro de $d'_Q(t)$ (Ap\u00f3s FPB)\")\n        ax_dq.set_xlabel(\"Frequ\u00eancia (Hz)\")\n        ax_dq.set_ylabel(\"Magnitude (dB)\")\n        ax_dq.grid(True)\n        leg_dq = ax_dq.legend(\n            loc='upper right', frameon=True, edgecolor='black',\n            facecolor='white', fontsize=12, fancybox=True\n        )\n        leg_dq.get_frame().set_facecolor('white')\n        leg_dq.get_frame().set_edgecolor('black')\n        leg_dq.get_frame().set_alpha(1.0)\n\n        plt.tight_layout()\n        plt.subplots_adjust(top=0.92, hspace=0.4)\n        self._save_or_show(fig_spec, save_path)\n\n    def plot_matched_filter(self, t_rc, g_matched, t_matched, d_I_matched, d_Q_matched,\n                            label_imp, label_I, label_Q,\n                            title_imp, title_I, title_Q,\n                            t_xlim=0.1, save_path=None):\n        \"\"\"\n        Plota a resposta ao impulso do filtro casado e os sinais I e Q ap\u00f3s a filtragem.\n\n        Args:\n            t_rc (np.ndarray): Vetor de tempo da resposta ao impulso do filtro casado.\n            g_matched (np.ndarray): Amostras da resposta ao impulso.\n            t_matched (np.ndarray): Vetor de tempo dos sinais filtrados.\n            d_I_matched (np.ndarray): Sinal I filtrado.\n            d_Q_matched (np.ndarray): Sinal Q filtrado.\n            label_imp (str): R\u00f3tulo da resposta ao impulso.\n            label_I (str): R\u00f3tulo do canal I filtrado.\n            label_Q (str): R\u00f3tulo do canal Q filtrado.\n            title_imp (str): T\u00edtulo do gr\u00e1fico da resposta ao impulso.\n            title_I (str): T\u00edtulo do gr\u00e1fico do canal I.\n            title_Q (str): T\u00edtulo do gr\u00e1fico do canal Q.\n            t_xlim (float, optional): Limite do eixo X para os canais I e Q.\n            save_path (str, optional): Caminho para salvar o gr\u00e1fico.\n        \"\"\"\n        fig_match = plt.figure(figsize=(16, 10))\n        gs_match = gridspec.GridSpec(3, 1)\n\n        # Resposta ao impulso do filtro casado\n        ax_mh = fig_match.add_subplot(gs_match[0])\n        ax_mh.plot(t_rc * 1000, g_matched, color='red', label=label_imp)\n        ax_mh.set_title(title_imp)\n        ax_mh.set_xlim(-15, 15)\n        ax_mh.set_xlabel(\"Tempo (ms)\")\n        ax_mh.set_ylabel(\"Amplitude\")\n        ax_mh.grid(True)\n        leg_mh = ax_mh.legend(\n            loc='upper right', frameon=True, edgecolor='black',\n            facecolor='white', fontsize=12, fancybox=True\n        )\n        leg_mh.get_frame().set_facecolor('white')\n        leg_mh.get_frame().set_edgecolor('black')\n        leg_mh.get_frame().set_alpha(1.0)\n\n        # Canal I ap\u00f3s filtro casado\n        ax_i_m = fig_match.add_subplot(gs_match[1])\n        ax_i_m.plot(t_matched, d_I_matched, color='blue', label=label_I)\n        ax_i_m.set_title(title_I)\n        ax_i_m.set_xlim(0, t_xlim)\n        ax_i_m.set_xlabel(\"Tempo (s)\")\n        ax_i_m.set_ylabel(\"Amplitude\")\n        ax_i_m.grid(True)\n        leg_i_m = ax_i_m.legend(\n            loc='upper right', frameon=True, edgecolor='black',\n            facecolor='white', fontsize=12, fancybox=True\n        )\n        leg_i_m.get_frame().set_facecolor('white')\n        leg_i_m.get_frame().set_edgecolor('black')\n        leg_i_m.get_frame().set_alpha(1.0)\n\n        # Canal Q ap\u00f3s filtro casado\n        ax_q_m = fig_match.add_subplot(gs_match[2])\n        ax_q_m.plot(t_matched, d_Q_matched, color='green', label=label_Q)\n        ax_q_m.set_title(title_Q)\n        ax_q_m.set_xlim(0, t_xlim)\n        ax_q_m.set_xlabel(\"Tempo (s)\")\n        ax_q_m.set_ylabel(\"Amplitude\")\n        ax_q_m.grid(True)\n        leg_q_m = ax_q_m.legend(\n            loc='upper right', frameon=True, edgecolor='black',\n            facecolor='white', fontsize=12, fancybox=True\n        )\n        leg_q_m.get_frame().set_facecolor('white')\n        leg_q_m.get_frame().set_edgecolor('black')\n        leg_q_m.get_frame().set_alpha(1.0)\n\n        plt.tight_layout()\n        plt.subplots_adjust(top=0.92, hspace=0.4)\n\n        self._save_or_show(fig_match, save_path)\n\n    def plot_matched_filter_freq(self, t_rc, g_matched,\n                                     d_I_rec, d_Q_rec,\n                                     d_I_matched, d_Q_matched,\n                                     fs, fc,\n                                     label_imp, label_I_before, label_I_after,\n                                     label_Q_before, label_Q_after,\n                                     title_imp, title_I_before, title_I_after,\n                                     title_Q_before, title_Q_after,\n                                     save_path=None):\n        \"\"\"\n        Plota o espectro dos sinais I e Q antes e depois da filtragem casada,\n        junto com a resposta ao impulso do filtro casado.\n\n        Args:\n            t_rc (np.ndarray): Vetor de tempo da resposta ao impulso do filtro casado.\n            g_matched (np.ndarray): Resposta ao impulso do filtro casado.\n            d_I_rec (np.ndarray): Sinal I antes do filtro casado.\n            d_Q_rec (np.ndarray): Sinal Q antes do filtro casado.\n            d_I_matched (np.ndarray): Sinal I ap\u00f3s o filtro casado.\n            d_Q_matched (np.ndarray): Sinal Q ap\u00f3s o filtro casado.\n            fs (float): Frequ\u00eancia de amostragem (Hz).\n            fc (float): Frequ\u00eancia central para o plot (Hz).\n            label_imp (str): R\u00f3tulo da resposta ao impulso.\n            label_I_before (str): R\u00f3tulo do canal I antes do filtro casado.\n            label_I_after (str): R\u00f3tulo do canal I ap\u00f3s o filtro casado.\n            label_Q_before (str): R\u00f3tulo do canal Q antes do filtro casado.\n            label_Q_after (str): R\u00f3tulo do canal Q ap\u00f3s o filtro casado.\n            title_imp (str): T\u00edtulo do gr\u00e1fico da resposta ao impulso.\n            title_I_before (str): T\u00edtulo do espectro do canal I antes do filtro casado.\n            title_I_after (str): T\u00edtulo do espectro do canal I ap\u00f3s o filtro casado.\n            title_Q_before (str): T\u00edtulo do espectro do canal Q antes do filtro casado.\n            title_Q_after (str): T\u00edtulo do espectro do canal Q ap\u00f3s o filtro casado.\n            save_path (str, optional): Caminho para salvar a figura.\n        \"\"\"\n        # FFT antes do filtro casado\n        DI_f = np.fft.fftshift(np.fft.fft(d_I_rec))\n        DQ_f = np.fft.fftshift(np.fft.fft(d_Q_rec))\n\n        # FFT ap\u00f3s o filtro casado\n        DIM_f = np.fft.fftshift(np.fft.fft(d_I_matched))\n        DQM_f = np.fft.fftshift(np.fft.fft(d_Q_matched))\n\n        freqs = np.fft.fftshift(np.fft.fftfreq(len(d_I_rec), d=1/fs))\n\n        DI_db = mag2db(DI_f)\n        DQ_db = mag2db(DQ_f)\n        DIM_db = mag2db(DIM_f)\n        DQM_db = mag2db(DQM_f)\n\n        fig_match_spec = plt.figure(figsize=(16, 10))\n        gs_match_spec = gridspec.GridSpec(3, 2, height_ratios=[1, 1, 1])\n\n        # Resposta ao impulso\n        ax_imp_m = fig_match_spec.add_subplot(gs_match_spec[0, :])\n        ax_imp_m.plot(t_rc * 1000, g_matched, color='red', linewidth=2, label=label_imp)\n        ax_imp_m.set_title(title_imp)\n        ax_imp_m.set_xlim(-15, 15)\n        ax_imp_m.set_xlabel(\"Tempo (ms)\")\n        ax_imp_m.set_ylabel(\"Amplitude\")\n        ax_imp_m.grid(True)\n        leg_imp = ax_imp_m.legend(loc='upper right', frameon=True, edgecolor='black',\n                                  facecolor='white', fontsize=12, fancybox=True)\n        leg_imp.get_frame().set_facecolor('white')\n        leg_imp.get_frame().set_edgecolor('black')\n        leg_imp.get_frame().set_alpha(1.0)\n\n        # Canal I antes\n        ax_i_before = fig_match_spec.add_subplot(gs_match_spec[1, 0])\n        ax_i_before.plot(freqs, DI_db, color='navy', label=label_I_before)\n        ax_i_before.set_title(title_I_before)\n        ax_i_before.set_xlabel(\"Frequ\u00eancia (Hz)\")\n        ax_i_before.set_ylabel(\"Magnitude (dB)\")\n        ax_i_before.set_xlim(-fc, fc)\n        ax_i_before.set_ylim(-90, 5)\n        ax_i_before.grid(True)\n        leg_ib = ax_i_before.legend(loc='upper right', frameon=True, edgecolor='black',\n                                    facecolor='white', fontsize=12, fancybox=True)\n        leg_ib.get_frame().set_facecolor('white')\n        leg_ib.get_frame().set_edgecolor('black')\n        leg_ib.get_frame().set_alpha(1.0)\n\n        # Canal I ap\u00f3s\n        ax_i_after = fig_match_spec.add_subplot(gs_match_spec[1, 1])\n        ax_i_after.plot(freqs, DIM_db, color='navy', label=label_I_after)\n        ax_i_after.set_title(title_I_after)\n        ax_i_after.set_xlabel(\"Frequ\u00eancia (Hz)\")\n        ax_i_after.set_ylabel(\"Magnitude (dB)\")\n        ax_i_after.set_xlim(-fc, fc)\n        ax_i_after.set_ylim(-90, 5)\n        ax_i_after.grid(True)\n        leg_ia = ax_i_after.legend(loc='upper right', frameon=True, edgecolor='black',\n                                   facecolor='white', fontsize=12, fancybox=True)\n        leg_ia.get_frame().set_facecolor('white')\n        leg_ia.get_frame().set_edgecolor('black')\n        leg_ia.get_frame().set_alpha(1.0)\n\n        # Canal Q antes\n        ax_q_before = fig_match_spec.add_subplot(gs_match_spec[2, 0])\n        ax_q_before.plot(freqs, DQ_db, color='darkgreen', label=label_Q_before)\n        ax_q_before.set_title(title_Q_before)\n        ax_q_before.set_xlabel(\"Frequ\u00eancia (Hz)\")\n        ax_q_before.set_ylabel(\"Magnitude (dB)\")\n        ax_q_before.set_xlim(-fc, fc)\n        ax_q_before.set_ylim(-90, 5)\n        ax_q_before.grid(True)\n        leg_qb = ax_q_before.legend(loc='upper right', frameon=True, edgecolor='black',\n                                    facecolor='white', fontsize=12, fancybox=True)\n        leg_qb.get_frame().set_facecolor('white')\n        leg_qb.get_frame().set_edgecolor('black')\n        leg_qb.get_frame().set_alpha(1.0)\n\n        # Canal Q ap\u00f3s\n        ax_q_after = fig_match_spec.add_subplot(gs_match_spec[2, 1])\n        ax_q_after.plot(freqs, DQM_db, color='green', label=label_Q_after)\n        ax_q_after.set_title(title_Q_after)\n        ax_q_after.set_xlabel(\"Frequ\u00eancia (Hz)\")\n        ax_q_after.set_ylabel(\"Magnitude (dB)\")\n        ax_q_after.set_xlim(-fc, fc)\n        ax_q_after.set_ylim(-90, 5)\n        ax_q_after.grid(True)\n        leg_qa = ax_q_after.legend(loc='upper right', frameon=True, edgecolor='black',\n                                   facecolor='white', fontsize=12, fancybox=True)\n        leg_qa.get_frame().set_facecolor('white')\n        leg_qa.get_frame().set_edgecolor('black')\n        leg_qa.get_frame().set_alpha(1.0)\n\n        plt.tight_layout()\n        plt.subplots_adjust(top=0.93, hspace=0.4)\n\n        self._save_or_show(fig_match_spec, save_path)\n\n    def plot_sampled_signals(self, t_matched, d_I_matched, d_Q_matched,\n                             t_samples, I_samples, Q_samples,\n                             label_I, label_I_samples,\n                             label_Q, label_Q_samples,\n                             title_I, title_Q,\n                             t_xlim=0.1, save_path=None):\n        \"\"\"\n        Plota os sinais I e Q ap\u00f3s o filtro casado com os pontos de amostragem.\n\n        Args:\n            t_matched (np.ndarray): Vetor de tempo dos sinais filtrados.\n            d_I_matched (np.ndarray): Sinal I ap\u00f3s o filtro casado.\n            d_Q_matched (np.ndarray): Sinal Q ap\u00f3s o filtro casado.\n            t_samples (np.ndarray): Instantes de amostragem.\n            I_samples (np.ndarray): Amostras do canal I.\n            Q_samples (np.ndarray): Amostras do canal Q.\n            label_I (str): R\u00f3tulo do sinal I filtrado.\n            label_I_samples (str): R\u00f3tulo das amostras I.\n            label_Q (str): R\u00f3tulo do sinal Q filtrado.\n            label_Q_samples (str): R\u00f3tulo das amostras Q.\n            title_I (str): T\u00edtulo do gr\u00e1fico do canal I.\n            title_Q (str): T\u00edtulo do gr\u00e1fico do canal Q.\n            t_xlim (float, optional): Limite do eixo X para ambos os gr\u00e1ficos.\n            save_path (str, optional): Caminho para salvar o gr\u00e1fico.\n        \"\"\"\n        fig_sample = plt.figure(figsize=(16, 8))\n        gs_sample = gridspec.GridSpec(2, 1)\n\n        # Canal I\n        ax_si = fig_sample.add_subplot(gs_sample[0])\n        ax_si.plot(t_matched, d_I_matched, color='blue', label=label_I)\n        ax_si.stem(t_samples, I_samples, linefmt='k-', markerfmt='ko', basefmt=\" \", label=label_I_samples)\n        ax_si.set_title(title_I)\n        ax_si.set_xlabel(\"Tempo (s)\")\n        ax_si.set_ylabel(\"Amplitude\")\n        ax_si.set_xlim(0, t_xlim)\n        ax_si.grid(True)\n        leg_si = ax_si.legend(loc='upper right', frameon=True, edgecolor='black',\n                              facecolor='white', fontsize=12, fancybox=True)\n        leg_si.get_frame().set_facecolor('white')\n        leg_si.get_frame().set_edgecolor('black')\n        leg_si.get_frame().set_alpha(1.0)\n\n        # Canal Q\n        ax_sq = fig_sample.add_subplot(gs_sample[1])\n        ax_sq.plot(t_matched, d_Q_matched, color='green', label=label_Q)\n        ax_sq.stem(t_samples, Q_samples, linefmt='k-', markerfmt='ko', basefmt=\" \", label=label_Q_samples)\n        ax_sq.set_title(title_Q)\n        ax_sq.set_xlabel(\"Tempo (s)\")\n        ax_sq.set_ylabel(\"Amplitude\")\n        ax_sq.set_xlim(0, t_xlim)\n        ax_sq.grid(True)\n        leg_sq = ax_sq.legend(loc='upper right', frameon=True, edgecolor='black',\n                              facecolor='white', fontsize=12, fancybox=True)\n        leg_sq.get_frame().set_facecolor('white')\n        leg_sq.get_frame().set_edgecolor('black')\n        leg_sq.get_frame().set_alpha(1.0)\n\n        plt.tight_layout()\n        self._save_or_show(fig_sample, save_path)\n\n    def _save_or_show(self, fig, path):\n        if path:\n            base_dir = os.path.dirname(os.path.abspath(__main__.__file__))\n            full_path = os.path.join(base_dir, path)\n\n            os.makedirs(os.path.dirname(full_path), exist_ok=True)\n            fig.savefig(full_path)\n        else:\n            plt.show()\n</code></pre>"},{"location":"api/plots/#plots.Plotter.__init__","title":"<code>__init__()</code>","text":"<p>Inicializa uma inst\u00e2ncia do plotter de gr\u00e1ficos.</p> Source code in <code>src/plots.py</code> <pre><code>def __init__(self):\n    r\"\"\" \n    Inicializa uma inst\u00e2ncia do plotter de gr\u00e1ficos.        \n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/plots/#plots.Plotter.plot_time_domain","title":"<code>plot_time_domain(s1, s2, t, label1, label2, title1, title2, save_path=None)</code>","text":"<p>Plota os sinais no dom\u00ednio do tempo.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>s1</code> <code>ndarray</code> <p>Primeiro sinal a ser plotado.</p> required <code>s2</code> <code>ndarray</code> <p>Segundo sinal a ser plotado.</p> required <code>t</code> <code>ndarray</code> <p>Vetor de tempo correspondente aos sinais.</p> required <code>label1</code> <code>str</code> <p>R\u00f3tulo do primeiro sinal.</p> required <code>label2</code> <code>str</code> <p>R\u00f3tulo do segundo sinal.</p> required <code>title1</code> <code>str</code> <p>T\u00edtulo do primeiro gr\u00e1fico.</p> required <code>title2</code> <code>str</code> <p>T\u00edtulo do segundo gr\u00e1fico.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code> Source code in <code>src/plots.py</code> <pre><code>def plot_time_domain(self, s1, s2, t, label1, label2, title1, title2, save_path=None):\n    r\"\"\"\n    Plota os sinais no dom\u00ednio do tempo.\n\n    ![timed](assets/transmitter_modulator_time.svg)\n\n    Args:\n        s1 (np.ndarray): Primeiro sinal a ser plotado.\n        s2 (np.ndarray): Segundo sinal a ser plotado.\n        t (np.ndarray): Vetor de tempo correspondente aos sinais.\n        label1 (str): R\u00f3tulo do primeiro sinal.\n        label2 (str): R\u00f3tulo do segundo sinal.\n        title1 (str): T\u00edtulo do primeiro gr\u00e1fico.\n        title2 (str): T\u00edtulo do segundo gr\u00e1fico.\n        save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n    \"\"\"\n\n    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(16, 8))\n    ax1.plot(t, s1, label=label1, color='blue')\n    ax1.set_title(title1)\n    ax1.set_xlim(0, 0.1)\n    ax1.set_ylabel('Amplitude')\n    ax1.grid(True)\n    leg1 = ax1.legend(\n                loc='upper right', frameon=True, edgecolor='black',\n                facecolor='white', fontsize=12, fancybox=True\n            )\n    leg1.get_frame().set_facecolor('white')\n    leg1.get_frame().set_edgecolor('black')\n    leg1.get_frame().set_alpha(1.0)\n\n    ax2.plot(t, s2, label=label2, color='red')\n    title = f'{title2}'\n    ax2.set_title(title)\n    ax2.set_xlim(0, 0.1)\n    ax2.set_xlabel('Tempo (s)')\n    ax2.set_ylabel('Amplitude')\n    ax2.grid(True)\n    leg2 = ax2.legend(\n                loc='upper right', frameon=True, edgecolor='black',\n                facecolor='white', fontsize=12, fancybox=True\n            )\n    leg2.get_frame().set_facecolor('white')\n    leg2.get_frame().set_edgecolor('black')\n    leg2.get_frame().set_alpha(1.0)\n\n    self._save_or_show(fig, save_path)\n</code></pre>"},{"location":"api/plots/#plots.Plotter.plot_frequency_domain","title":"<code>plot_frequency_domain(s1, s2, fs, fc, label1, label2, title1, title2, save_path=None)</code>","text":"<p>Plota os sinais no dom\u00ednio da frequ\u00eancia.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>s1</code> <code>ndarray</code> <p>Primeiro sinal a ser plotado.</p> required <code>s2</code> <code>ndarray</code> <p>Segundo sinal a ser plotado.</p> required <code>fs</code> <code>float</code> <p>Frequ\u00eancia de amostragem dos sinais.</p> required <code>fc</code> <code>float</code> <p>Frequ\u00eancia central para o eixo x.</p> required <code>label1</code> <code>str</code> <p>R\u00f3tulo do primeiro sinal.</p> required <code>label2</code> <code>str</code> <p>R\u00f3tulo do segundo sinal.</p> required <code>title1</code> <code>str</code> <p>T\u00edtulo do primeiro gr\u00e1fico.</p> required <code>title2</code> <code>str</code> <p>T\u00edtulo do segundo gr\u00e1fico.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code> Source code in <code>src/plots.py</code> <pre><code>def plot_frequency_domain(self, s1, s2, fs, fc, label1, label2, title1, title2, save_path=None):\n    r\"\"\"\n    Plota os sinais no dom\u00ednio da frequ\u00eancia.\n\n    ![freqd](assets/transmitter_modulator_freq.svg)\n\n    Args:\n        s1 (np.ndarray): Primeiro sinal a ser plotado.\n        s2 (np.ndarray): Segundo sinal a ser plotado.\n        fs (float): Frequ\u00eancia de amostragem dos sinais.\n        fc (float): Frequ\u00eancia central para o eixo x.\n        label1 (str): R\u00f3tulo do primeiro sinal.\n        label2 (str): R\u00f3tulo do segundo sinal.\n        title1 (str): T\u00edtulo do primeiro gr\u00e1fico.\n        title2 (str): T\u00edtulo do segundo gr\u00e1fico.\n        save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n    \"\"\"\n\n    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(16, 8))\n    freqs = np.fft.fftshift(np.fft.fftfreq(len(s1), d=1/fs))\n\n    if fc &gt; 1000:\n        freqs = freqs / 1000\n        x_label = \"Frequ\u00eancia (kHz)\"\n        x_limit = (-2.5 * fc / 1000, 2.5 * fc / 1000)\n    else:\n        x_label = \"Frequ\u00eancia (Hz)\"\n        x_limit = (-2.5 * fc, 2.5 * fc)\n\n    fft_clean = np.fft.fftshift(np.fft.fft(s1))\n    fft_clean_db = mag2db(fft_clean)\n    ax1.plot(freqs, fft_clean_db, color='blue', label=label1)\n    ax1.set_title(title1)\n    ax1.set_ylim(-80, 5)\n    ax1.set_xlim(*x_limit)\n    ax1.set_ylabel(\"Magnitude (dB)\")\n    ax1.grid(True)\n    leg1 = ax1.legend(\n                loc='upper right', frameon=True, edgecolor='black',\n                facecolor='white', fontsize=12, fancybox=True\n            )\n    leg1.get_frame().set_facecolor('white')\n    leg1.get_frame().set_edgecolor('black')\n    leg1.get_frame().set_alpha(1.0)\n\n    fft_noisy = np.fft.fftshift(np.fft.fft(s2))\n    fft_noisy_db = mag2db(fft_noisy)\n    ax2.plot(freqs, fft_noisy_db, color='red', label=label2)\n    ax2.set_title(title2)\n    ax2.set_ylim(-80, 5)\n    ax2.set_xlim(*x_limit)\n    ax2.set_ylabel(\"Magnitude (dB)\")\n    ax2.set_xlabel(x_label)\n    ax2.grid(True)\n    leg2 = ax2.legend(\n                loc='upper right', frameon=True, edgecolor='black',\n                facecolor='white', fontsize=12, fancybox=True\n            )\n    leg2.get_frame().set_facecolor('white')\n    leg2.get_frame().set_edgecolor('black')\n    leg2.get_frame().set_alpha(1.0)\n\n    self._save_or_show(fig, save_path)\n</code></pre>"},{"location":"api/plots/#plots.Plotter.plot_bits","title":"<code>plot_bits(bits_list, sections=None, colors=None, save_path=None)</code>","text":"<p>Plota uma sequ\u00eancia de bits, com a op\u00e7\u00e3o de destacar se\u00e7\u00f5es espec\u00edficas.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>bits_list</code> <code>list of np.ndarray</code> <p>Lista de arrays de bits a serem plotados.</p> required <code>sections</code> <code>list of tuples</code> <p>Lista de se\u00e7\u00f5es a destacar, cada uma como (nome, comprimento).</p> <code>None</code> <code>colors</code> <code>list of str</code> <p>Cores para as se\u00e7\u00f5es destacadas.</p> <code>None</code> <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code> Source code in <code>src/plots.py</code> <pre><code>def plot_bits(self, bits_list, sections=None, colors=None, save_path=None):\n    r\"\"\"\n    Plota uma sequ\u00eancia de bits, com a op\u00e7\u00e3o de destacar se\u00e7\u00f5es espec\u00edficas.\n\n    ![bits](assets/transmitter_datagram.svg)\n\n    Args:\n        bits_list (list of np.ndarray): Lista de arrays de bits a serem plotados.\n        sections (list of tuples, optional): Lista de se\u00e7\u00f5es a destacar, cada uma como (nome, comprimento).\n        colors (list of str, optional): Cores para as se\u00e7\u00f5es destacadas.\n        save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n    \"\"\"\n    all_bits = np.concatenate(bits_list)\n    bits_up = np.repeat(all_bits, 2)\n    x = np.arange(len(bits_up))\n\n    fig, ax = plt.subplots(figsize=(16, 4))\n    ax.set_xlim(0, len(bits_up))\n    ax.set_ylim(-0.2, 1.2)\n    ax.grid(False)\n    ax.set_yticks([0, 1])\n    bit_edges = np.arange(0, len(bits_up) + 1, 2)\n    for pos in bit_edges:\n        ax.axvline(x=pos, color='gray', linestyle='--', linewidth=0.5)\n\n    if sections:\n        start_bit = 0\n        for i, (sec_name, sec_len) in enumerate(sections):\n            bit_start = start_bit * 2\n            bit_end = (start_bit + sec_len) * 2\n            color = colors[i] if colors else 'black'\n\n            if i &gt; 0:\n                bit_start -= 1\n\n            ax.step(\n                x[bit_start:bit_end],\n                bits_up[bit_start:bit_end],\n                where='post',\n                color=color,\n                linewidth=1.5,\n                label=sec_name if i == 0 or sec_name not in sections[:i] else None\n            )\n            start_bit += sec_len\n    else:\n        ax.step(x, bits_up, where='post', color='black', linewidth=1.5, label='Bits')\n\n    ax.set_xlabel('Index')\n    ax.set_ylabel('Valor')\n    leg = ax.legend(\n                loc='upper right', frameon=True, edgecolor='black',\n                facecolor='white', fontsize=12, fancybox=True\n            )\n    leg.get_frame().set_facecolor('white')\n    leg.get_frame().set_edgecolor('black')\n    leg.get_frame().set_alpha(1.0)\n\n    self._save_or_show(fig, save_path)\n</code></pre>"},{"location":"api/plots/#plots.Plotter.plot_encode","title":"<code>plot_encode(s1, s2, s3, s4, label1, label2, label3, label4, title1, title2, title3, title4, save_path=None)</code>","text":"<p>Plota os sinais de entrada e sa\u00edda do codificador. </p> <p>Parameters:</p> Name Type Description Default <code>s1</code> <code>ndarray</code> <p>Sinal de entrada I.</p> required <code>s2</code> <code>ndarray</code> <p>Sinal de entrada Q.</p> required <code>s3</code> <code>ndarray</code> <p>Sinal de sa\u00edda I codificado.</p> required <code>s4</code> <code>ndarray</code> <p>Sinal de sa\u00edda Q codificado.</p> required <code>label1</code> <code>str</code> <p>R\u00f3tulo do sinal I de entrada.</p> required <code>label2</code> <code>str</code> <p>R\u00f3tulo do sinal Q de entrada.</p> required <code>label3</code> <code>str</code> <p>R\u00f3tulo do sinal I codificado.</p> required <code>label4</code> <code>str</code> <p>R\u00f3tulo do sinal Q codificado.</p> required <code>title1</code> <code>str</code> <p>T\u00edtulo do sinal I de entrada.</p> required <code>title2</code> <code>str</code> <p>T\u00edtulo do sinal Q de entrada.</p> required <code>title3</code> <code>str</code> <p>T\u00edtulo do sinal I codificado.</p> required <code>title4</code> <code>str</code> <p>T\u00edtulo do sinal Q codificado.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code> Source code in <code>src/plots.py</code> <pre><code>def plot_encode(self, s1, s2, s3, s4, label1, label2, label3, label4, title1, title2, title3, title4, save_path=None):\n    r\"\"\"\n    Plota os sinais de entrada e sa\u00edda do codificador.\n    ![encode](assets/transmitter_encoder.svg)\n\n    Args:\n        s1 (np.ndarray): Sinal de entrada I.\n        s2 (np.ndarray): Sinal de entrada Q.\n        s3 (np.ndarray): Sinal de sa\u00edda I codificado.\n        s4 (np.ndarray): Sinal de sa\u00edda Q codificado.\n        label1 (str): R\u00f3tulo do sinal I de entrada.\n        label2 (str): R\u00f3tulo do sinal Q de entrada.\n        label3 (str): R\u00f3tulo do sinal I codificado.\n        label4 (str): R\u00f3tulo do sinal Q codificado.\n        title1 (str): T\u00edtulo do sinal I de entrada.\n        title2 (str): T\u00edtulo do sinal Q de entrada.\n        title3 (str): T\u00edtulo do sinal I codificado.\n        title4 (str): T\u00edtulo do sinal Q codificado.\n        save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n    \"\"\"\n    s1_up = np.repeat(s1, 2)\n    s2_up = np.repeat(s2, 2)\n    x = np.arange(len(s1_up))\n    bit_edges = np.arange(0, len(s1_up) + 1, 2)\n\n    fig, axs = plt.subplots(4, 1, sharex=True)\n\n    def setup_grid(ax):\n        ax.set_xlim(0, len(s1_up))\n        ax.set_ylim(-0.2, 1.4)\n        ax.grid(False)\n        for pos in bit_edges:\n            ax.axvline(x=pos, color='gray', linestyle='--', linewidth=0.5)\n\n    axs[0].step(x, s1_up, where='post', label=label1, color='navy', linewidth=3)\n    for i, bit in enumerate(s1):\n        axs[0].text(i * 2 + 1, 1.15, str(bit), ha='center', va='bottom', fontsize=16, fontweight='bold')\n    axs[0].set_ylabel(title1)\n    leg0 = axs[0].legend(\n                loc='upper right', frameon=True, edgecolor='black',\n                facecolor='white', fontsize=12, fancybox=True\n            )\n    leg0.get_frame().set_facecolor('white')\n    leg0.get_frame().set_edgecolor('black')\n    leg0.get_frame().set_alpha(1.0)\n    setup_grid(axs[0])\n\n    axs[1].step(x, s3, where='post', label=label3, color='darkred', linewidth=3)\n    for i in range(len(s1)):\n        pair = ''.join(str(b) for b in s3[2 * i:2 * i + 2])\n        axs[1].text(i * 2 + 1, 1.15, pair, ha='center', va='bottom', fontsize=16, fontweight='bold')\n    axs[1].set_ylabel(title3)\n    leg1 = axs[1].legend( \n                loc='upper right', frameon=True, edgecolor='black',\n                facecolor='white', fontsize=12, fancybox=True\n            )\n    leg1.get_frame().set_facecolor('white')\n    leg1.get_frame().set_edgecolor('black')\n    leg1.get_frame().set_alpha(1.0)\n    setup_grid(axs[1])\n\n    axs[2].step(x, s2_up, where='post', label=label2, color='navy', linewidth=3)\n    for i, bit in enumerate(s2):\n        axs[2].text(i * 2 + 1, 1.15, str(bit), ha='center', va='bottom', fontsize=16, fontweight='bold')\n    axs[2].set_ylabel(title2)\n    leg2 = axs[2].legend(\n                loc='upper right', frameon=True, edgecolor='black',\n                facecolor='white', fontsize=12, fancybox=True\n            )\n    leg2.get_frame().set_facecolor('white')\n    leg2.get_frame().set_edgecolor('black')\n    leg2.get_frame().set_alpha(1.0)\n    setup_grid(axs[2])\n\n    axs[3].step(x, s4, where='post', label=label4, color='darkred', linewidth=3)\n    for i in range(len(s2)):\n        pair = ''.join(str(b) for b in s4[2 * i:2 * i + 2])\n        axs[3].text(i * 2 + 1, 1.15, pair, ha='center', va='bottom', fontsize=16, fontweight='bold')\n    axs[3].set_ylabel(title4)\n    leg3 = axs[3].legend(\n                loc='upper right', frameon=True, edgecolor='black',\n                facecolor='white', fontsize=12, fancybox=True\n            )\n    leg3.get_frame().set_facecolor('white')\n    leg3.get_frame().set_edgecolor('black')\n    leg3.get_frame().set_alpha(1.0)\n    setup_grid(axs[3])\n\n    plt.xlabel('Bits')\n    plt.tight_layout()\n    plt.subplots_adjust(top=0.92)\n\n    self._save_or_show(fig, save_path)\n</code></pre>"},{"location":"api/plots/#plots.Plotter.plot_conv","title":"<code>plot_conv(s1, s2, s3, label1, label2, label3, title1, title2, title3, save_path=None)</code>","text":"<p>Plota os sinais de entrada e sa\u00edda do codificador convolucional.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>s1</code> <code>ndarray</code> <p>Sinal de entrada I.</p> required <code>s2</code> <code>ndarray</code> <p>Sinal de entrada Q.</p> required <code>s3</code> <code>ndarray</code> <p>Sinal de sa\u00edda codificado.</p> required <code>label1</code> <code>str</code> <p>R\u00f3tulo do sinal I de entrada.</p> required <code>label2</code> <code>str</code> <p>R\u00f3tulo do sinal Q de entrada.</p> required <code>label3</code> <code>str</code> <p>R\u00f3tulo do sinal codificado.</p> required <code>title1</code> <code>str</code> <p>T\u00edtulo do sinal I de entrada.</p> required <code>title2</code> <code>str</code> <p>T\u00edtulo do sinal Q de entrada.</p> required <code>title3</code> <code>str</code> <p>T\u00edtulo do sinal codificado.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code> Source code in <code>src/plots.py</code> <pre><code>def plot_conv(self, s1, s2, s3, label1, label2, label3, title1, title2, title3, save_path=None):\n    r\"\"\"\n    Plota os sinais de entrada e sa\u00edda do codificador convolucional.\n\n    ![conv](assets/transmitter_convolutional.svg)\n\n    Args:\n        s1 (np.ndarray): Sinal de entrada I.\n        s2 (np.ndarray): Sinal de entrada Q.\n        s3 (np.ndarray): Sinal de sa\u00edda codificado.\n        label1 (str): R\u00f3tulo do sinal I de entrada.\n        label2 (str): R\u00f3tulo do sinal Q de entrada.\n        label3 (str): R\u00f3tulo do sinal codificado.\n        title1 (str): T\u00edtulo do sinal I de entrada.\n        title2 (str): T\u00edtulo do sinal Q de entrada.\n        title3 (str): T\u00edtulo do sinal codificado.\n        save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n    \"\"\"\n\n    s1_up = np.repeat(s1, 2)\n    s2_up = np.repeat(s2, 2)\n    s3_up = np.repeat(s3, 2)\n    x = np.arange(len(s2_up))\n    bit_edges = np.arange(0, len(s2_up) + 1, 2)\n\n    # Configura\u00e7\u00e3o do gr\u00e1fico\n    fig, axs = plt.subplots(3, 1, sharex=True)\n    def setup_grid(ax):\n        ax.set_xlim(0, len(s2_up))\n        ax.set_ylim(-0.2, 1.4)\n        ax.grid(False)\n        for pos in bit_edges:\n            ax.axvline(x=pos, color='gray', linestyle='--', linewidth=0.5)\n\n    # Canal I\n    axs[0].step(x, s1_up, where='post', label=label1, color='darkgreen', linewidth=3)\n    for i, bit in enumerate(s1):\n        axs[0].text(i * 2 + 1, 1.15, str(bit), ha='center', va='bottom', fontsize=16, fontweight='bold')\n    axs[0].set_ylabel(title1)\n    leg0 = axs[0].legend(\n                loc='upper right', frameon=True, edgecolor='black',\n                facecolor='white', fontsize=12, fancybox=True\n            )\n    leg0.get_frame().set_facecolor('white')\n    leg0.get_frame().set_edgecolor('black')\n    leg0.get_frame().set_alpha(1.0)\n    axs[0].set_yticks([0, 1])\n    setup_grid(axs[0])\n\n    # Canal I\n    axs[1].step(x, s2_up, where='post', label=label2, color='navy', linewidth=3)\n    for i, bit in enumerate(s2):\n        axs[1].text(i * 2 + 1, 1.15, str(bit), ha='center', va='bottom', fontsize=16, fontweight='bold')\n    axs[1].set_ylabel(title2)\n    leg0 = axs[1].legend(\n                loc='upper right', frameon=True, edgecolor='black',\n                facecolor='white', fontsize=12, fancybox=True\n            )\n    leg0.get_frame().set_facecolor('white')\n    leg0.get_frame().set_edgecolor('black')\n    leg0.get_frame().set_alpha(1.0)\n    axs[1].set_yticks([0, 1])\n    setup_grid(axs[1])\n\n    # Canal Q\n    axs[2].step(x, s3_up, where='post', label=label3, color='darkred', linewidth=3)\n    for i, bit in enumerate(s3):\n        axs[2].text(i * 2 + 1, 1.15, str(bit), ha='center', va='bottom', fontsize=16, fontweight='bold')\n    axs[2].set_ylabel(title3)\n    leg1 = axs[2].legend(\n                loc='upper right', frameon=True, edgecolor='black',\n                facecolor='white', fontsize=12, fancybox=True\n            )\n    leg1.get_frame().set_facecolor('white')\n    leg1.get_frame().set_edgecolor('black')\n    leg1.get_frame().set_alpha(1.0)\n    axs[2].set_yticks([0, 1])\n    setup_grid(axs[2])\n\n    # Configura\u00e7\u00e3o do layout\n    plt.xlabel('Bits')\n    plt.tight_layout()\n    plt.subplots_adjust(top=0.92)\n\n    # Salvar ou mostrar o gr\u00e1fico\n    self._save_or_show(fig, save_path)\n</code></pre>"},{"location":"api/plots/#plots.Plotter.plot_trellis","title":"<code>plot_trellis(trellis, num_steps=5, initial_state=0, save_path=None)</code>","text":"<p>Plota o diagrama de treli\u00e7a de um codificador convolucional.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>trellis</code> <code>dict</code> <p>Dicion\u00e1rio representando o treli\u00e7a, onde as chaves s\u00e3o estados e os valores s\u00e3o tuplas (pr\u00f3ximo_estado, sa\u00edda).</p> required <code>num_steps</code> <code>int</code> <p>N\u00famero de passos no tempo a serem plotados.</p> <code>5</code> <code>initial_state</code> <code>int</code> <p>Estado inicial do treli\u00e7a.</p> <code>0</code> <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code> Source code in <code>src/plots.py</code> <pre><code>def plot_trellis(self, trellis, num_steps=5, initial_state=0, save_path=None):\n    r\"\"\"\n    Plota o diagrama de treli\u00e7a de um codificador convolucional.\n\n    ![trellis'](assets/example_trelica.svg)\n\n    Args:\n        trellis (dict): Dicion\u00e1rio representando o treli\u00e7a, onde as chaves s\u00e3o estados e os valores s\u00e3o tuplas (pr\u00f3ximo_estado, sa\u00edda).\n        num_steps (int): N\u00famero de passos no tempo a serem plotados.\n        initial_state (int): Estado inicial do treli\u00e7a.\n        save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n\n    \"\"\"\n    states_per_time = defaultdict(set)\n    states_per_time[0].add(initial_state)\n    branches = []\n    for t in range(num_steps):\n        for state in states_per_time[t]:\n            for bit in [0, 1]:\n                next_state, out = trellis[state][bit]\n                module = sum(np.abs(out))\n                branches.append((t, state, bit, next_state, module, out))\n                states_per_time[t+1].add(next_state)\n\n    all_states = sorted(set(s for states in states_per_time.values() for s in states))\n    state_to_x = {s: i for i, s in enumerate(all_states)}\n    num_states = len(all_states)\n\n    fig = plt.figure(figsize=(0.50*num_states, 1*num_steps))\n    ax = fig.gca()\n    ax.set_xlabel('Estado')\n    ax.set_ylabel('Intervalo de tempo')\n    ax.set_xticks(range(num_states))\n\n    # Formata os labels do eixo x com dois d\u00edgitos hexadecimais\n    ax.set_xticklabels([f\"{hex(s)[2:].upper():0&gt;2}\" for s in all_states])\n    ax.set_yticks(range(num_steps+1))\n    ax.grid(True, axis='x', linestyle='--', alpha=0.3)\n    ax.grid(True, axis='y', linestyle=':', alpha=0.2)\n    ax.invert_yaxis()\n\n    for t, state, bit, next_state, module, out in branches:\n        x = [state_to_x[state], state_to_x[next_state]]\n        y = [t, t+1]\n        color = 'C0' if bit == 0 else 'C1'\n        ax.plot(x, y, color=color, lw=2, alpha=0.8)\n\n    from matplotlib.lines import Line2D\n    legend_elements = [\n        Line2D([0], [0], color='C0', lw=2, label='Bit de entrada 0'),\n        Line2D([0], [0], color='C1', lw=2, label='Bit de entrada 1')\n    ]\n    ax.legend(handles=legend_elements, loc='upper right', frameon=True, fontsize=20)\n\n    for t in range(num_steps+1):\n        for state in states_per_time[t]:\n            ax.plot(state_to_x[state], t, 'o', color='k', markersize=8)\n\n    self._save_or_show(fig, save_path)\n</code></pre>"},{"location":"api/plots/#plots.Plotter.plot_scrambler","title":"<code>plot_scrambler(s1, s2, s3, s4, s5, s6, label1, label2, label3, label4, label5, label6, save_path=None)</code>","text":"<p>Plota os sinais de entrada e sa\u00edda do embaralhador.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>s1</code> <code>ndarray</code> <p>Sinal de entrada I.</p> required <code>s2</code> <code>ndarray</code> <p>Sinal de entrada Q.</p> required <code>s3</code> <code>ndarray</code> <p>Sinal embaralhado I.</p> required <code>s4</code> <code>ndarray</code> <p>Sinal embaralhado Q.</p> required <code>s5</code> <code>ndarray</code> <p>Sinal desembaralhado I.</p> required <code>s6</code> <code>ndarray</code> <p>Sinal desembaralhado Q.</p> required <code>label1</code> <code>str</code> <p>R\u00f3tulo do sinal I de entrada.</p> required <code>label2</code> <code>str</code> <p>R\u00f3tulo do sinal Q de entrada.</p> required <code>label3</code> <code>str</code> <p>R\u00f3tulo do sinal embaralhado I.</p> required <code>label4</code> <code>str</code> <p>R\u00f3tulo do sinal embaralhado Q.</p> required <code>label5</code> <code>str</code> <p>R\u00f3tulo do sinal desembaralhado I.</p> required <code>label6</code> <code>str</code> <p>R\u00f3tulo do sinal desembaralhado Q.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code> Source code in <code>src/plots.py</code> <pre><code>def plot_scrambler(self, s1, s2, s3, s4, s5, s6, label1, label2, label3, label4, label5, label6, save_path=None):\n    r\"\"\"\n    Plota os sinais de entrada e sa\u00edda do embaralhador.\n\n    ![scrambler](assets/example_scrambling.svg)\n\n    Args:\n        s1 (np.ndarray): Sinal de entrada I.\n        s2 (np.ndarray): Sinal de entrada Q.\n        s3 (np.ndarray): Sinal embaralhado I.\n        s4 (np.ndarray): Sinal embaralhado Q.\n        s5 (np.ndarray): Sinal desembaralhado I.\n        s6 (np.ndarray): Sinal desembaralhado Q.\n        label1 (str): R\u00f3tulo do sinal I de entrada.\n        label2 (str): R\u00f3tulo do sinal Q de entrada.\n        label3 (str): R\u00f3tulo do sinal embaralhado I.\n        label4 (str): R\u00f3tulo do sinal embaralhado Q.\n        label5 (str): R\u00f3tulo do sinal desembaralhado I.\n        label6 (str): R\u00f3tulo do sinal desembaralhado Q.\n        save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n    \"\"\"\n\n    fig, axs = plt.subplots(3, 2, figsize=(16, 9), sharex=True)\n\n    superplot(axs[0, 0], s1, label1, \"navy\")\n    superplot(axs[0, 1], s2, label2, \"darkred\")\n    superplot(axs[1, 0], s3, label3, \"navy\")\n    superplot(axs[1, 1], s4, label4, \"darkred\")\n    superplot(axs[2, 0], s5, label5, \"navy\")\n    superplot(axs[2, 1], s6, label6, \"darkred\")\n\n    axs[2, 0].set_xlabel(\"Bits\")\n    axs[2, 1].set_xlabel(\"Bits\")\n    axs[0, 0].set_ylabel(\"Original\")\n    axs[1, 0].set_ylabel(\"Embaralhado\")\n    axs[2, 0].set_ylabel(\"Desembaralhado\")\n\n\n    plt.tight_layout()\n    plt.subplots_adjust(top=0.9)\n\n    self._save_or_show(fig, save_path)\n</code></pre>"},{"location":"api/plots/#plots.Plotter.plot_preamble","title":"<code>plot_preamble(s1, s2, label1, label2, title1, title2, save_path=None)</code>","text":"<p>Plota o pre\u00e2mbulo do transmissor, mostrando os sinais I e Q.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>s1</code> <code>ndarray</code> <p>Sinal I do pre\u00e2mbulo.</p> required <code>s2</code> <code>ndarray</code> <p>Sinal Q do pre\u00e2mbulo.</p> required <code>label1</code> <code>str</code> <p>R\u00f3tulo do sinal I.</p> required <code>label2</code> <code>str</code> <p>R\u00f3tulo do sinal Q.</p> required <code>title1</code> <code>str</code> <p>T\u00edtulo do sinal I.</p> required <code>title2</code> <code>str</code> <p>T\u00edtulo do sinal Q.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code> Source code in <code>src/plots.py</code> <pre><code>def plot_preamble(self, s1, s2, label1, label2, title1, title2, save_path=None):\n    r\"\"\"\n    Plota o pre\u00e2mbulo do transmissor, mostrando os sinais I e Q.\n\n    ![preamble.](assets/transmitter_preamble.svg)\n\n    Args:\n        s1 (np.ndarray): Sinal I do pre\u00e2mbulo.\n        s2 (np.ndarray): Sinal Q do pre\u00e2mbulo.\n        label1 (str): R\u00f3tulo do sinal I.\n        label2 (str): R\u00f3tulo do sinal Q.\n        title1 (str): T\u00edtulo do sinal I.\n        title2 (str): T\u00edtulo do sinal Q.\n        save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n    \"\"\"\n\n    # Superamostragem do sinal para o plot\n    s1_up = np.repeat(s1, 2)\n    s2_up = np.repeat(s2, 2)\n    x = np.arange(len(s1_up))\n    bit_edges = np.arange(0, len(s1_up) + 1, 2)\n\n    # Configura\u00e7\u00e3o do gr\u00e1fico\n    fig, axs = plt.subplots(2, 1, sharex=True)\n    def setup_grid(ax):\n        ax.set_xlim(0, len(s1_up))\n        ax.set_ylim(-0.2, 1.4)\n        ax.grid(False)\n        for pos in bit_edges:\n            ax.axvline(x=pos, color='gray', linestyle='--', linewidth=0.5)\n\n    # Canal I\n    axs[0].step(x, s1_up, where='post', label=label1, color='navy', linewidth=3)\n    for i, bit in enumerate(s1):\n        axs[0].text(i * 2 + 1, 1.15, str(bit), ha='center', va='bottom', fontsize=16, fontweight='bold')\n    axs[0].set_ylabel(title1)\n    leg0 = axs[0].legend(\n                loc='upper right', frameon=True, edgecolor='black',\n                facecolor='white', fontsize=12, fancybox=True\n            )\n    leg0.get_frame().set_facecolor('white')\n    leg0.get_frame().set_edgecolor('black')\n    leg0.get_frame().set_alpha(1.0)\n    axs[0].set_yticks([0, 1])\n    setup_grid(axs[0])\n\n    # Canal Q\n    axs[1].step(x, s2_up, where='post', label=label2, color='darkred', linewidth=3)\n    for i, bit in enumerate(s2):\n        axs[1].text(i * 2 + 1, 1.15, str(bit), ha='center', va='bottom', fontsize=16, fontweight='bold')\n    axs[1].set_ylabel(title2)\n    leg1 = axs[1].legend(\n                loc='upper right', frameon=True, edgecolor='black',\n                facecolor='white', fontsize=12, fancybox=True\n            )\n    leg1.get_frame().set_facecolor('white')\n    leg1.get_frame().set_edgecolor('black')\n    leg1.get_frame().set_alpha(1.0)\n    axs[1].set_yticks([0, 1])\n    setup_grid(axs[1])\n\n    # Configura\u00e7\u00e3o do layout\n    plt.xlabel('Bits')\n    plt.tight_layout()\n    plt.subplots_adjust(top=0.92)\n\n    # Salvar ou mostrar o gr\u00e1fico\n    self._save_or_show(fig, save_path)\n</code></pre>"},{"location":"api/plots/#plots.Plotter.plot_mux","title":"<code>plot_mux(s1, s2, s3, s4, label1, label2, label3, label4, title1, title2, save_path=None)</code>","text":"<p>Plota o multiplexador do transmissor, mostrando os sinais I e Q.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>s1</code> <code>ndarray</code> <p>Sinal I do canal I.</p> required <code>s2</code> <code>ndarray</code> <p>Sinal Q do canal I.</p> required <code>s3</code> <code>ndarray</code> <p>Sinal I do canal Q.</p> required <code>s4</code> <code>ndarray</code> <p>Sinal Q do canal Q.</p> required <code>label1</code> <code>str</code> <p>R\u00f3tulo do sinal I do canal I.</p> required <code>label2</code> <code>str</code> <p>R\u00f3tulo do sinal Q do canal I.</p> required <code>label3</code> <code>str</code> <p>R\u00f3tulo do sinal I do canal Q.</p> required <code>label4</code> <code>str</code> <p>R\u00f3tulo do sinal Q do canal Q.</p> required <code>title1</code> <code>str</code> <p>T\u00edtulo do sinal I do canal I.</p> required <code>title2</code> <code>str</code> <p>T\u00edtulo do sinal Q do canal I.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code> Source code in <code>src/plots.py</code> <pre><code>def plot_mux(self, s1, s2, s3, s4, label1, label2, label3, label4, title1, title2, save_path=None):\n    r\"\"\"\n    Plota o multiplexador do transmissor, mostrando os sinais I e Q.\n\n    ![mux](assets/transmitter_multiplexing.svg)\n\n    Args:\n        s1 (np.ndarray): Sinal I do canal I.\n        s2 (np.ndarray): Sinal Q do canal I.\n        s3 (np.ndarray): Sinal I do canal Q.\n        s4 (np.ndarray): Sinal Q do canal Q.\n        label1 (str): R\u00f3tulo do sinal I do canal I.\n        label2 (str): R\u00f3tulo do sinal Q do canal I.\n        label3 (str): R\u00f3tulo do sinal I do canal Q.\n        label4 (str): R\u00f3tulo do sinal Q do canal Q.\n        title1 (str): T\u00edtulo do sinal I do canal I.\n        title2 (str): T\u00edtulo do sinal Q do canal I.\n        save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n    \"\"\"\n    # Concatena\u00e7\u00e3o\n    s5 = np.concatenate((s1, s3))\n    s6 = np.concatenate((s2, s4))\n\n    # Superamostragem\n    s5_up = np.repeat(s5, 2)\n    s6_up = np.repeat(s6, 2)\n    x = np.arange(len(s5_up))\n    bit_edges = np.arange(0, len(s5_up) + 1, 2)\n\n    fig, axs = plt.subplots(2, 1, sharex=True)\n\n    def setup_grid(ax):\n        ax.set_xlim(0, len(s5_up))\n        ax.set_ylim(-0.2, 1.4)\n        ax.grid(False)\n        for pos in bit_edges:\n            ax.axvline(x=pos, color='gray', linestyle='--', linewidth=0.5)\n\n    # --- Channel I ---\n    sep_I = len(s1) * 2\n    x_I1 = x[:sep_I]\n    x_I2 = x[sep_I - 1:]  # Inclui o \u00faltimo ponto anterior\n\n    y_I1 = s5_up[:sep_I]\n    y_I2 = s5_up[sep_I - 1:]\n\n    axs[0].step(x_I1, y_I1, where='post', color='navy', linewidth=3, label=label1)\n    axs[0].step(x_I2, y_I2, where='post', color='darkred', linewidth=3, label=label2)\n\n    for i, bit in enumerate(s5):\n        axs[0].text(i * 2 + 1, 1.15, str(bit), ha='center', va='bottom', fontsize=16, fontweight='bold')\n\n    axs[0].set_ylabel(title1)\n    leg0 = axs[0].legend(\n                loc='upper right', frameon=True, edgecolor='black',\n                facecolor='white', fontsize=12, fancybox=True\n            )\n    leg0.get_frame().set_facecolor('white')\n    leg0.get_frame().set_edgecolor('black')\n    leg0.get_frame().set_alpha(1.0)\n    axs[0].set_yticks([0, 1])\n    axs[0].set_yticks([0, 1])\n    setup_grid(axs[0])\n\n    # --- Channel Q ---\n    sep_Q = len(s2) * 2\n    x_Q1 = x[:sep_Q]\n    x_Q2 = x[sep_Q - 1:]\n\n    y_Q1 = s6_up[:sep_Q]\n    y_Q2 = s6_up[sep_Q - 1:]\n\n    axs[1].step(x_Q1, y_Q1, where='post', color='navy', linewidth=3, label=label3)\n    axs[1].step(x_Q2, y_Q2, where='post', color='darkred', linewidth=3, label=label4)\n\n    for i, bit in enumerate(s6):\n        axs[1].text(i * 2 + 1, 1.15, str(bit), ha='center', va='bottom', fontsize=16, fontweight='bold')\n\n    axs[1].set_ylabel(title2)\n    leg1 = axs[1].legend(\n                loc='upper right', frameon=True, edgecolor='black',\n                facecolor='white', fontsize=12, fancybox=True\n            )\n    leg1.get_frame().set_facecolor('white')\n    leg1.get_frame().set_edgecolor('black')\n    leg1.get_frame().set_alpha(1.0)\n    axs[1].set_yticks([0, 1])\n    setup_grid(axs[1])\n\n    # Layout final\n    plt.xlabel('Bits')\n\n    num_bits = len(s5)\n    step = 5\n    axs[1].set_xticks(np.arange(0, num_bits * 2, step * 2))      \n    axs[1].set_xticklabels(np.arange(0, num_bits, step)) \n\n    plt.tight_layout()\n    plt.subplots_adjust(top=0.92)\n\n    self._save_or_show(fig, save_path)\n</code></pre>"},{"location":"api/plots/#plots.Plotter.plot_filter","title":"<code>plot_filter(h, t_rc, tb, span, fs, s1, s2, label_h, label1, label2, title_h, title1, title2, t_xlim, save_path=None)</code>","text":"<p>Plota o filtro RRC e os sinais I e Q ap\u00f3s a filtragem.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>ndarray</code> <p>Resposta ao impulso do filtro RRC.</p> required <code>t_rc</code> <code>ndarray</code> <p>Tempo correspondente \u00e0 resposta ao impulso.</p> required <code>tb</code> <code>float</code> <p>Tempo de s\u00edmbolo.</p> required <code>span</code> <code>int</code> <p>N\u00famero de spans do filtro.</p> required <code>fs</code> <code>float</code> <p>Frequ\u00eancia de amostragem.</p> required <code>s1</code> <code>ndarray</code> <p>Sinal I filtrado.</p> required <code>s2</code> <code>ndarray</code> <p>Sinal Q filtrado.</p> required <code>label_h</code> <code>str</code> <p>R\u00f3tulo do filtro.</p> required <code>label1</code> <code>str</code> <p>R\u00f3tulo do sinal I.</p> required <code>label2</code> <code>str</code> <p>R\u00f3tulo do sinal Q.</p> required <code>title_h</code> <code>str</code> <p>T\u00edtulo do filtro.</p> required <code>title1</code> <code>str</code> <p>T\u00edtulo do sinal I.</p> required <code>title2</code> <code>str</code> <p>T\u00edtulo do sinal Q.</p> required <code>t_xlim</code> <code>float</code> <p>Limite do eixo x para os sinais I e Q.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code> Source code in <code>src/plots.py</code> <pre><code>def plot_filter(self, h, t_rc, tb, span, fs, s1, s2, label_h, label1, label2, title_h, title1, title2, t_xlim, save_path=None):\n\n    r\"\"\"\n    Plota o filtro RRC e os sinais I e Q ap\u00f3s a filtragem.\n\n    ![filter](assets/transmitter_filter.svg)\n\n    Args:\n        h (np.ndarray): Resposta ao impulso do filtro RRC.\n        t_rc (np.ndarray): Tempo correspondente \u00e0 resposta ao impulso.\n        tb (float): Tempo de s\u00edmbolo.\n        span (int): N\u00famero de spans do filtro.\n        fs (float): Frequ\u00eancia de amostragem.\n        s1 (np.ndarray): Sinal I filtrado.\n        s2 (np.ndarray): Sinal Q filtrado.\n        label_h (str): R\u00f3tulo do filtro.\n        label1 (str): R\u00f3tulo do sinal I.\n        label2 (str): R\u00f3tulo do sinal Q.\n        title_h (str): T\u00edtulo do filtro.\n        title1 (str): T\u00edtulo do sinal I.\n        title2 (str): T\u00edtulo do sinal Q.\n        t_xlim (float): Limite do eixo x para os sinais I e Q.\n        save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n    \"\"\"\n\n    t_interp = np.arange(len(s1)) / fs\n\n    fig = plt.figure(figsize=(16, 9))\n    gs = gridspec.GridSpec(2, 2, height_ratios=[1, 1])\n\n    # Pulso RRC\n    ax_rcc = fig.add_subplot(gs[0, :])\n    ax_rcc.plot(t_rc, h, label=label_h, color='red', linewidth=2)\n    ax_rcc.set_title(title_h)\n    ax_rcc.set_ylabel('Amplitude')\n    ax_rcc.grid(True)\n    leg_rcc = ax_rcc.legend(\n        loc='upper right', frameon=True, edgecolor='black',\n        facecolor='white', fontsize=12, fancybox=True\n    )\n    leg_rcc.get_frame().set_facecolor('white')\n    leg_rcc.get_frame().set_edgecolor('black')\n    leg_rcc.get_frame().set_alpha(1.0)\n    ax_rcc.set_xlim(-span*tb, span*tb)\n\n    # Sinal I\n    ax_I = fig.add_subplot(gs[1, 0])\n    ax_I.plot(t_interp, s1, label= label1, color='navy', linewidth=2)\n    ax_I.set_title(title1)\n    ax_I.set_xlabel('Tempo (s)')\n    ax_I.set_ylabel('Amplitude')\n    ax_I.set_xlim(0, t_xlim)\n    ax_I.grid(True)\n    leg_I = ax_I.legend(\n        loc='upper right', frameon=True, edgecolor='black',\n        facecolor='white', fontsize=12, fancybox=True\n    )\n    leg_I.get_frame().set_facecolor('white')\n    leg_I.get_frame().set_edgecolor('black')\n    leg_I.get_frame().set_alpha(1.0)\n\n    # Sinal Q\n    ax_Q = fig.add_subplot(gs[1, 1])\n    ax_Q.plot(t_interp, s2, label=label2, color='darkgreen', linewidth=2)\n    ax_Q.set_title(title2)\n    ax_Q.set_xlabel('Tempo (s)')\n    ax_Q.set_xlim(0, t_xlim)\n    ax_Q.grid(True)\n    leg_Q = ax_Q.legend(\n        loc='upper right', frameon=True, edgecolor='black',\n        facecolor='white', fontsize=12, fancybox=True\n    )\n    leg_Q.get_frame().set_facecolor('white')\n    leg_Q.get_frame().set_edgecolor('black')\n    leg_Q.get_frame().set_alpha(1.0)\n\n    plt.tight_layout()\n    plt.subplots_adjust(top=0.92, hspace=0.4)\n\n    self._save_or_show(fig, save_path)\n</code></pre>"},{"location":"api/plots/#plots.Plotter.plot_modulation_time","title":"<code>plot_modulation_time(s1, s2, s3, label1, label2, label3, title1, title2, fs, t_xlim, save_path=None)</code>","text":"<p>Plota os sinais de modula\u00e7\u00e3o no dom\u00ednio do tempo.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>s1</code> <code>ndarray</code> <p>Sinal I modulado.</p> required <code>s2</code> <code>ndarray</code> <p>Sinal Q modulado.</p> required <code>s3</code> <code>ndarray</code> <p>Sinal de modula\u00e7\u00e3o resultante.</p> required <code>label1</code> <code>str</code> <p>R\u00f3tulo do sinal I.</p> required <code>label2</code> <code>str</code> <p>R\u00f3tulo do sinal Q.</p> required <code>label3</code> <code>str</code> <p>R\u00f3tulo do sinal de modula\u00e7\u00e3o.</p> required <code>title1</code> <code>str</code> <p>T\u00edtulo do sinal I.</p> required <code>title2</code> <code>str</code> <p>T\u00edtulo do sinal Q.</p> required <code>fs</code> <code>float</code> <p>Frequ\u00eancia de amostragem.</p> required <code>t_xlim</code> <code>float</code> <p>Limite do eixo x para os sinais I e Q.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code> Source code in <code>src/plots.py</code> <pre><code>def plot_modulation_time(self, s1, s2, s3, label1, label2, label3, title1, title2, fs, t_xlim, save_path=None):\n    r\"\"\"\n    Plota os sinais de modula\u00e7\u00e3o no dom\u00ednio do tempo.\n\n    ![modulation_time](assets/transmitter_modulator_time.svg)\n\n    Args:\n        s1 (np.ndarray): Sinal I modulado.\n        s2 (np.ndarray): Sinal Q modulado.\n        s3 (np.ndarray): Sinal de modula\u00e7\u00e3o resultante.\n        label1 (str): R\u00f3tulo do sinal I.\n        label2 (str): R\u00f3tulo do sinal Q.\n        label3 (str): R\u00f3tulo do sinal de modula\u00e7\u00e3o.\n        title1 (str): T\u00edtulo do sinal I.\n        title2 (str): T\u00edtulo do sinal Q.\n        fs (float): Frequ\u00eancia de amostragem.\n        t_xlim (float): Limite do eixo x para os sinais I e Q.\n        save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n    \"\"\"\n\n    t = np.arange(len(s1)) / fs\n    fig = plt.figure(figsize=(16, 8))\n    gs = gridspec.GridSpec(2, 1, height_ratios=[1, 1])\n\n    ax1 = fig.add_subplot(gs[0, 0])\n    ax1.plot(t, s1, label=label1, color='navy', linewidth=2)\n    ax1.plot(t, s2, label=label2, color='darkgreen', linewidth=2)\n    ax1.set_xlim(0, t_xlim)\n    ax1.set_ylabel('Amplitude')\n    ax1.set_title(title1)\n    ax1.grid(True)\n    leg1 = ax1.legend(loc='upper right', frameon=True, edgecolor='black', facecolor='white', fontsize=14, fancybox=True)\n    leg1.get_frame().set_facecolor('white')\n    leg1.get_frame().set_edgecolor('black')\n    leg1.get_frame().set_alpha(1.0)\n\n    ax2 = fig.add_subplot(gs[1, 0])\n    ax2.plot(t, s3, label=label3, color='darkred', linewidth=1.5)\n    ax2.set_xlim(0, t_xlim)\n    ax2.set_xlabel('Tempo (s)')\n    ax2.set_ylabel('Amplitude')\n    ax2.set_title(title2)\n    ax2.grid(True)\n    leg2 = ax2.legend(loc='upper right', frameon=True, edgecolor='black', facecolor='white', fontsize=14, fancybox=True)\n    leg2.get_frame().set_facecolor('white')\n    leg2.get_frame().set_edgecolor('black')\n    leg2.get_frame().set_alpha(1.0)\n\n    plt.tight_layout()\n    plt.subplots_adjust(hspace=0.3)\n\n    self._save_or_show(fig, save_path)\n</code></pre>"},{"location":"api/plots/#plots.Plotter.plot_modulation_eye","title":"<code>plot_modulation_eye(s1, s2, label1, label2, title1, title2, fs, Rb, save_path=None)</code>","text":"<p>Plota o diagrama de olho dos sinais I e Q ap\u00f3s a modula\u00e7\u00e3o.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>s1</code> <code>ndarray</code> <p>Sinal I modulado.</p> required <code>s2</code> <code>ndarray</code> <p>Sinal Q modulado.</p> required <code>label1</code> <code>str</code> <p>R\u00f3tulo do sinal I.</p> required <code>label2</code> <code>str</code> <p>R\u00f3tulo do sinal Q.</p> required <code>title1</code> <code>str</code> <p>T\u00edtulo do sinal I.</p> required <code>title2</code> <code>str</code> <p>T\u00edtulo do sinal Q.</p> required <code>fs</code> <code>float</code> <p>Frequ\u00eancia de amostragem.</p> required <code>Rb</code> <code>float</code> <p>Taxa de bits.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code> Source code in <code>src/plots.py</code> <pre><code>def plot_modulation_eye(self, s1, s2, label1, label2, title1, title2, fs, Rb, save_path=None):\n    r\"\"\"\n    Plota o diagrama de olho dos sinais I e Q ap\u00f3s a modula\u00e7\u00e3o.\n\n    ![modulation_eye](assets/example_eye.svg)\n\n    Args:\n        s1 (np.ndarray): Sinal I modulado.\n        s2 (np.ndarray): Sinal Q modulado.\n        label1 (str): R\u00f3tulo do sinal I.\n        label2 (str): R\u00f3tulo do sinal Q.\n        title1 (str): T\u00edtulo do sinal I.\n        title2 (str): T\u00edtulo do sinal Q.\n        fs (float): Frequ\u00eancia de amostragem.\n        Rb (float): Taxa de bits.\n        save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n    \"\"\"\n\n    sps = int(fs / Rb)\n    eye_len = 2 * sps\n    n_traces = (len(s1) - eye_len) // sps\n    fig = plt.figure(figsize=(16, 7))\n    gs = gridspec.GridSpec(1, 2, width_ratios=[1, 1])\n\n    # Diagrama de olho dI\n    ax_eyeI = fig.add_subplot(gs[0, 0])\n    for i in range(n_traces):\n        start = i * sps\n        ax_eyeI.plot(np.arange(eye_len) / fs * 1e3, s1[start:start+eye_len], color='navy', alpha=0.18, linewidth=2, label=label1)\n    ax_eyeI.set_xlabel('Tempo (ms)')\n    ax_eyeI.set_ylabel('Amplitude')\n    ax_eyeI.set_title(title1)\n    ax_eyeI.grid(True)\n    ax_eyeI.set_xlim(0, eye_len / fs * 1e3)\n\n    # Diagrama de olho dQ\n    ax_eyeQ = fig.add_subplot(gs[0, 1])\n    for i in range(n_traces):\n        start = i * sps\n        ax_eyeQ.plot(np.arange(eye_len) / fs * 1e3, s2[start:start+eye_len], color='darkgreen', alpha=0.18, linewidth=2, label=label2)\n    ax_eyeQ.set_xlabel('Tempo (ms)')\n    ax_eyeQ.set_ylabel('Amplitude')\n    ax_eyeQ.set_title(title2)\n    ax_eyeQ.grid(True)\n    ax_eyeQ.set_xlim(0, eye_len / fs * 1e3)\n\n    plt.tight_layout()\n    self._save_or_show(fig, save_path)\n</code></pre>"},{"location":"api/plots/#plots.Plotter.plot_modulation_iq","title":"<code>plot_modulation_iq(s1, s2, label1, label2, title1, title2, save_path=None, amplitude=None)</code>","text":"<p>Plota o diagrama IQ dos sinais I e Q ap\u00f3s a modula\u00e7\u00e3o.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>s1</code> <code>ndarray</code> <p>Sinal I modulado.</p> required <code>s2</code> <code>ndarray</code> <p>Sinal Q modulado.</p> required <code>label1</code> <code>str</code> <p>R\u00f3tulo do sinal I.</p> required <code>label2</code> <code>str</code> <p>R\u00f3tulo do sinal Q.</p> required <code>title1</code> <code>str</code> <p>T\u00edtulo do sinal I.</p> required <code>title2</code> <code>str</code> <p>T\u00edtulo do sinal Q.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code> <code>amplitude</code> <code>float</code> <p>Amplitude dos pontos QPSK. Se None, a amplitude \u00e9 calculada automaticamente.</p> <code>None</code> Source code in <code>src/plots.py</code> <pre><code>def plot_modulation_iq(self, s1, s2, label1, label2, title1, title2, save_path=None, amplitude=None):\n\n    r\"\"\"\n    Plota o diagrama IQ dos sinais I e Q ap\u00f3s a modula\u00e7\u00e3o.\n\n    ![modulation_iq](assets/transmitter_modulator_iq.svg)\n\n    Args:\n        s1 (np.ndarray): Sinal I modulado.\n        s2 (np.ndarray): Sinal Q modulado.\n        label1 (str): R\u00f3tulo do sinal I.\n        label2 (str): R\u00f3tulo do sinal Q.\n        title1 (str): T\u00edtulo do sinal I.\n        title2 (str): T\u00edtulo do sinal Q.\n        save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n        amplitude (float, optional): Amplitude dos pontos QPSK. Se None, a amplitude \u00e9 calculada automaticamente.\n    \"\"\"\n\n    s1_c = s1 - np.mean(s1)\n    s2_c = s2 - np.mean(s2)\n    fig = plt.figure(figsize=(16, 9))\n    gs = gridspec.GridSpec(1, 2, width_ratios=[1, 1])\n\n    ax_const = fig.add_subplot(gs[0, 0])\n    if amplitude is None:\n        amp = np.mean(np.abs(np.concatenate([s1_c*1.1, s2_c*1.1])))\n    else:\n        amp = amplitude\n\n    ax_iq = fig.add_subplot(gs[0, 1])\n    ax_iq.scatter(s1_c, s2_c, color='darkgreen', alpha=0.5, s=2, label=label1)\n    ax_iq.set_xlabel(r'$I$')\n    ax_iq.set_ylabel(r'$Q$')\n    ax_iq.set_title(title1)\n\n    for v in [-amp, amp]:\n        ax_iq.axhline(v, color='darkred', linestyle='--', linewidth=1, alpha=0.6, zorder=0)\n        ax_iq.axvline(v, color='darkred', linestyle='--', linewidth=1, alpha=0.6, zorder=0)\n    from matplotlib.lines import Line2D\n    custom_legend = [Line2D([0], [0], marker='o', color='w', label='Amostras IQ',\n                            markerfacecolor='darkgreen', markersize=16, alpha=0.7)]\n    leg_iq = ax_iq.legend(handles=custom_legend,\n            loc='upper right', frameon=True, edgecolor='black',\n            facecolor='white', fontsize=12, fancybox=True\n        )\n    leg_iq.get_frame().set_facecolor('white')\n    leg_iq.get_frame().set_edgecolor('black')\n    leg_iq.get_frame().set_alpha(1.0)\n    ax_iq.set_xlim(-0.06, 0.06)\n    ax_iq.set_ylim(-0.06, 0.06)\n    ax_iq.set_aspect('equal')\n\n    qpsk_points = np.array([[amp, amp], [amp, -amp], [-amp, amp], [-amp, -amp]])\n    ax_const.scatter(qpsk_points[:, 0], qpsk_points[:, 1], color='black', s=160, marker='o', label=label2, linewidth=5)\n    ax_const.set_xlabel(r'$I$')\n    ax_const.set_ylabel(r'$Q$')\n    ax_const.set_title(title2)\n\n    for v in [-amp, amp]:\n        ax_const.axhline(v, color='darkred', linestyle='--', linewidth=1, alpha=0.6, zorder=0)\n        ax_const.axvline(v, color='darkred', linestyle='--', linewidth=1, alpha=0.6, zorder=0)\n    leg_const = ax_const.legend(\n            loc='upper right', frameon=True, edgecolor='black',\n            facecolor='white', fontsize=12, fancybox=True\n        )\n    leg_const.get_frame().set_facecolor('white')\n    leg_const.get_frame().set_edgecolor('black')\n    leg_const.get_frame().set_alpha(1.0)\n    ax_const.set_xlim(-0.06, 0.06)\n    ax_const.set_ylim(-0.06, 0.06)\n    ax_const.set_aspect('equal')\n\n    plt.tight_layout()\n    self._save_or_show(fig, save_path)\n</code></pre>"},{"location":"api/plots/#plots.Plotter.plot_modulation_freq","title":"<code>plot_modulation_freq(s1, s2, s3, label1, label2, label3, title1, title2, title3, fs, fc, save_path=None)</code>","text":"<p>Plota o espectro dos sinais I, Q e o sinal modulado no dom\u00ednio da frequ\u00eancia.</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>s1</code> <code>ndarray</code> <p>Sinal I modulado.</p> required <code>s2</code> <code>ndarray</code> <p>Sinal Q modulado.</p> required <code>s3</code> <code>ndarray</code> <p>Sinal modulado resultante.</p> required <code>label1</code> <code>str</code> <p>R\u00f3tulo do sinal I.</p> required <code>label2</code> <code>str</code> <p>R\u00f3tulo do sinal Q.</p> required <code>label3</code> <code>str</code> <p>R\u00f3tulo do sinal modulado.</p> required <code>title1</code> <code>str</code> <p>T\u00edtulo do sinal I.</p> required <code>title2</code> <code>str</code> <p>T\u00edtulo do sinal Q.</p> required <code>title3</code> <code>str</code> <p>T\u00edtulo do sinal modulado.</p> required <code>fs</code> <code>float</code> <p>Frequ\u00eancia de amostragem.</p> required <code>fc</code> <code>float</code> <p>Frequ\u00eancia de portadora.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code> Source code in <code>src/plots.py</code> <pre><code>def plot_modulation_freq(self, s1, s2, s3, label1, label2, label3, title1, title2, title3, fs, fc, save_path=None):\n    r\"\"\"\n    Plota o espectro dos sinais I, Q e o sinal modulado no dom\u00ednio da frequ\u00eancia.\n\n    ![modulation_freq](assets/transmitter_modulator_freq.svg)\n\n    Args:\n        s1 (np.ndarray): Sinal I modulado.\n        s2 (np.ndarray): Sinal Q modulado.\n        s3 (np.ndarray): Sinal modulado resultante.\n        label1 (str): R\u00f3tulo do sinal I.\n        label2 (str): R\u00f3tulo do sinal Q.\n        label3 (str): R\u00f3tulo do sinal modulado.\n        title1 (str): T\u00edtulo do sinal I.\n        title2 (str): T\u00edtulo do sinal Q.\n        title3 (str): T\u00edtulo do sinal modulado.\n        fs (float): Frequ\u00eancia de amostragem.\n        fc (float): Frequ\u00eancia de portadora.\n        save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n    \"\"\"\n\n    freqs = np.fft.fftshift(np.fft.fftfreq(len(s3), d=1/fs))\n    fft_dI = np.fft.fftshift(np.fft.fft(s1))\n    fft_dQ = np.fft.fftshift(np.fft.fft(s2))\n    fft_s = np.fft.fftshift(np.fft.fft(s3))\n\n    fig = plt.figure(figsize=(16, 10))\n    gs = gridspec.GridSpec(2, 2)\n\n    if fc &gt; 1000:\n        freqs = freqs / 1000\n        x_label = \"Frequ\u00eancia (kHz)\"\n        x_limit = (-2.5 * fc / 1000, 2.5 * fc / 1000)\n        x_limit_comp = (- 0.5 * fc / 1000, 0.5 * fc / 1000)\n    else:\n        x_label = \"Frequ\u00eancia (Hz)\"\n        x_limit = (-2.5 * fc, 2.5 * fc)\n        x_limit_comp = (- 0.5 * fc, 0.5 * fc)\n\n\n    # Linha 1 - espectro de s(t)\n    ax1 = fig.add_subplot(gs[0, :])\n    ax1.plot(freqs, mag2db(fft_s), color='darkred', label=label3)\n    ax1.set_xlim(x_limit)\n    ax1.set_xlabel(x_label)\n    ax1.set_ylim(-80, 5)\n    ax1.set_ylabel('Magnitude (dB)')\n    ax1.set_title(title3)\n    ax1.grid(True)\n    ax1.legend()\n\n    # Linha 2 - espectro de dI(t)\n    ax2 = fig.add_subplot(gs[1, 0])\n    ax2.plot(freqs, mag2db(fft_dI), color='navy', label=label1)\n    ax2.set_xlim(x_limit_comp)\n    ax2.set_xlabel(x_label)\n    ax2.set_ylim(-80, 5)\n    ax2.set_ylabel('Magnitude (dB)')\n    ax2.set_title(title1)\n    ax2.grid(True)\n    ax2.legend()\n\n    # Linha 2 - espectro de dQ(t)\n    ax3 = fig.add_subplot(gs[1, 1])\n    ax3.plot(freqs, mag2db(fft_dQ), color='darkgreen', label=label2)\n    ax3.set_xlim(x_limit_comp)\n    ax3.set_xlabel(x_label)\n    ax3.set_ylim(-80, 5)\n    ax3.set_ylabel('Magnitude (dB)')    \n    ax3.set_title(title2)\n    ax3.grid(True)\n    ax3.legend()\n\n    plt.tight_layout()\n    self._save_or_show(fig, save_path)\n</code></pre>"},{"location":"api/plots/#plots.Plotter.plot_freq_receiver","title":"<code>plot_freq_receiver(y_I, y_Q, fs, fc, save_path=None)</code>","text":"<p>Plota os espectros de frequ\u00eancia dos canais I e Q ap\u00f3s a demodula\u00e7\u00e3o.</p> <p>Parameters:</p> Name Type Description Default <code>y_I</code> <code>ndarray</code> <p>Sinal do canal I no dom\u00ednio do tempo</p> required <code>y_Q</code> <code>ndarray</code> <p>Sinal do canal Q no dom\u00ednio do tempo</p> required <code>fs</code> <code>float</code> <p>Frequ\u00eancia de amostragem (Hz)</p> required <code>fc</code> <code>float</code> <p>Frequ\u00eancia da portadora (Hz)</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar a figura. Se None, mostra a figura.</p> <code>None</code> Source code in <code>src/plots.py</code> <pre><code>def plot_freq_receiver(self, y_I, y_Q, fs, fc, save_path=None):\n    \"\"\"\n    Plota os espectros de frequ\u00eancia dos canais I e Q ap\u00f3s a demodula\u00e7\u00e3o.\n\n    Args:\n        y_I (np.ndarray): Sinal do canal I no dom\u00ednio do tempo\n        y_Q (np.ndarray): Sinal do canal Q no dom\u00ednio do tempo\n        fs (float): Frequ\u00eancia de amostragem (Hz)\n        fc (float): Frequ\u00eancia da portadora (Hz)\n        save_path (str, optional): Caminho para salvar a figura. Se None, mostra a figura.\n    \"\"\"\n    fig = plt.figure(figsize=(16, 8))\n    gs = gridspec.GridSpec(2, 1)\n\n    # FFT do canal I\n    YI_f = np.fft.fftshift(np.fft.fft(y_I))\n    freqs = np.fft.fftshift(np.fft.fftfreq(len(y_I), d=1/fs))\n    YI_db = mag2db(YI_f)  # Normalizado\n\n    ax_i = fig.add_subplot(gs[0])\n    ax_i.plot(freqs, YI_db, color='blue', label=r\"$|Y_I(f)|$\")\n    ax_i.set_xlim(-2.5 * fc, 2.5 * fc)\n    ax_i.set_ylim(-60, 5)\n    ax_i.set_title(r\"Espectro do canal I - $y_I(t)$\")\n    ax_i.set_xlabel(\"Frequ\u00eancia (Hz)\")\n    ax_i.set_ylabel(\"Magnitude (dB)\")\n    ax_i.grid(True)\n    leg_i = ax_i.legend(\n        loc='upper right', frameon=True, edgecolor='black',\n        facecolor='white', fontsize=12, fancybox=True\n    )\n    leg_i.get_frame().set_facecolor('white')\n    leg_i.get_frame().set_edgecolor('black')\n    leg_i.get_frame().set_alpha(1.0)\n\n    # FFT do canal Q\n    YQ_f = np.fft.fftshift(np.fft.fft(y_Q))\n    YQ_db = mag2db(YQ_f)  # Normalizado\n\n    ax_q = fig.add_subplot(gs[1])\n    ax_q.plot(freqs, YQ_db, color='green', label=r\"$|Y_Q(f)|$\")\n    ax_q.set_xlim(-2.5 * fc, 2.5 * fc)\n    ax_q.set_ylim(-60, 5)\n    ax_q.set_title(r\"Espectro do canal Q - $y_Q(t)$\")\n    ax_q.set_xlabel(\"Frequ\u00eancia (Hz)\")\n    ax_q.set_ylabel(\"Magnitude (dB)\")\n    ax_q.grid(True)\n    leg_q = ax_q.legend(\n        loc='upper right', frameon=True, edgecolor='black',\n        facecolor='white', fontsize=12, fancybox=True\n    )\n    leg_q.get_frame().set_facecolor('white')\n    leg_q.get_frame().set_edgecolor('black')\n    leg_q.get_frame().set_alpha(1.0)\n\n    plt.tight_layout()\n    self._save_or_show(fig, save_path)\n</code></pre>"},{"location":"api/plots/#plots.Plotter.plot_impulse_response","title":"<code>plot_impulse_response(t_imp, impulse_response, label_imp, t_unit='ms', xlim=None, save_path=None)</code>","text":"<p>Plota apenas a resposta ao impulso de um filtro.</p> <p>Parameters:</p> Name Type Description Default <code>t_imp</code> <code>ndarray</code> <p>Vetor de tempo da resposta ao impulso.</p> required <code>impulse_response</code> <code>ndarray</code> <p>Amostras da resposta ao impulso.</p> required <code>label_imp</code> <code>str</code> <p>R\u00f3tulo da resposta ao impulso.</p> required <code>title_imp</code> <code>str</code> <p>T\u00edtulo do gr\u00e1fico.</p> required <code>t_unit</code> <code>str</code> <p>Unidade de tempo no eixo X (\"ms\" ou \"s\"). Default \u00e9 \"ms\".</p> <code>'ms'</code> <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.</p> <code>None</code> Source code in <code>src/plots.py</code> <pre><code>def plot_impulse_response(self, t_imp, impulse_response, label_imp, t_unit=\"ms\", xlim=None, save_path=None):\n    \"\"\"\n    Plota apenas a resposta ao impulso de um filtro.\n\n    Args:\n        t_imp (np.ndarray): Vetor de tempo da resposta ao impulso.\n        impulse_response (np.ndarray): Amostras da resposta ao impulso.\n        label_imp (str): R\u00f3tulo da resposta ao impulso.\n        title_imp (str): T\u00edtulo do gr\u00e1fico.\n        t_unit (str, optional): Unidade de tempo no eixo X (\"ms\" ou \"s\"). Default \u00e9 \"ms\".\n        save_path (str, optional): Caminho para salvar o gr\u00e1fico. Se None, o gr\u00e1fico ser\u00e1 exibido na tela.\n    \"\"\"\n    fig = plt.figure(figsize=(12, 6))\n    ax = fig.add_subplot(1, 1, 1)\n\n    if t_unit == \"ms\":\n        t_plot = t_imp * 1000\n        x_label = \"Tempo (ms)\"\n    else:\n        t_plot = t_imp\n        x_label = \"Tempo (s)\"\n\n    ax.plot(t_plot, impulse_response, color='red', label=label_imp, linewidth=2)\n    ax.set_xlabel(x_label)\n    ax.set_ylabel(\"Amplitude\")\n    ax.grid(True)\n\n    if xlim is not None:\n        ax.set_xlim(-xlim, xlim)\n\n    leg = ax.legend(loc='upper right', frameon=True, edgecolor='black',\n                    facecolor='white', fontsize=12, fancybox=True)\n    leg.get_frame().set_facecolor('white')\n    leg.get_frame().set_edgecolor('black')\n    leg.get_frame().set_alpha(1.0)\n\n    plt.tight_layout()\n    self._save_or_show(fig, save_path)\n</code></pre>"},{"location":"api/plots/#plots.Plotter.plot_filtered_signals","title":"<code>plot_filtered_signals(t_imp, impulse_response, t_interp, d_I_rec, d_Q_rec, label_imp, label_I, label_Q, title_imp, title_I, title_Q, t_xlim, save_path=None)</code>","text":"<p>Plota a resposta ao impulso do filtro passa-baixa e os sinais I e Q filtrados.</p> <p>Parameters:</p> Name Type Description Default <code>t_imp</code> <code>ndarray</code> <p>Vetor de tempo da resposta ao impulso.</p> required <code>impulse_response</code> <code>ndarray</code> <p>Amostras da resposta ao impulso.</p> required <code>t_interp</code> <code>ndarray</code> <p>Vetor de tempo dos sinais filtrados.</p> required <code>d_I_rec</code> <code>ndarray</code> <p>Sinal I filtrado.</p> required <code>d_Q_rec</code> <code>ndarray</code> <p>Sinal Q filtrado.</p> required <code>label_imp</code> <code>str</code> <p>R\u00f3tulo da resposta ao impulso.</p> required <code>label_I</code> <code>str</code> <p>R\u00f3tulo do canal I filtrado.</p> required <code>label_Q</code> <code>str</code> <p>R\u00f3tulo do canal Q filtrado.</p> required <code>title_imp</code> <code>str</code> <p>T\u00edtulo do gr\u00e1fico da resposta ao impulso.</p> required <code>title_I</code> <code>str</code> <p>T\u00edtulo do gr\u00e1fico do canal I.</p> required <code>title_Q</code> <code>str</code> <p>T\u00edtulo do gr\u00e1fico do canal Q.</p> required <code>t_xlim</code> <code>float</code> <p>Limite do eixo X para os canais I e Q.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico.</p> <code>None</code> Source code in <code>src/plots.py</code> <pre><code>def plot_filtered_signals(self, t_imp, impulse_response, t_interp, d_I_rec, d_Q_rec,\n                          label_imp, label_I, label_Q,\n                          title_imp, title_I, title_Q, t_xlim, save_path=None):\n    \"\"\"\n    Plota a resposta ao impulso do filtro passa-baixa e os sinais I e Q filtrados.\n\n    Args:\n        t_imp (np.ndarray): Vetor de tempo da resposta ao impulso.\n        impulse_response (np.ndarray): Amostras da resposta ao impulso.\n        t_interp (np.ndarray): Vetor de tempo dos sinais filtrados.\n        d_I_rec (np.ndarray): Sinal I filtrado.\n        d_Q_rec (np.ndarray): Sinal Q filtrado.\n        label_imp (str): R\u00f3tulo da resposta ao impulso.\n        label_I (str): R\u00f3tulo do canal I filtrado.\n        label_Q (str): R\u00f3tulo do canal Q filtrado.\n        title_imp (str): T\u00edtulo do gr\u00e1fico da resposta ao impulso.\n        title_I (str): T\u00edtulo do gr\u00e1fico do canal I.\n        title_Q (str): T\u00edtulo do gr\u00e1fico do canal Q.\n        t_xlim (float): Limite do eixo X para os canais I e Q.\n        save_path (str, optional): Caminho para salvar o gr\u00e1fico.\n    \"\"\"\n\n    fig_filt = plt.figure(figsize=(16, 10))\n    gs_filt = gridspec.GridSpec(3, 1)\n\n    # Resposta ao impulso\n    ax_imp = fig_filt.add_subplot(gs_filt[0])\n    ax_imp.plot(t_imp * 1000, impulse_response, color='red', label=label_imp, linewidth=2)\n    ax_imp.set_title(title_imp)\n    ax_imp.set_xlabel(\"Tempo (ms)\")\n    ax_imp.set_ylabel(\"Amplitude\")\n    ax_imp.grid(True)\n    leg_imp = ax_imp.legend(loc='upper right', frameon=True, edgecolor='black',\n                            facecolor='white', fontsize=12, fancybox=True)\n    leg_imp.get_frame().set_facecolor('white')\n    leg_imp.get_frame().set_edgecolor('black')\n    leg_imp.get_frame().set_alpha(1.0)\n\n    # I filtrado\n    ax_fi = fig_filt.add_subplot(gs_filt[1])\n    ax_fi.plot(t_interp, d_I_rec, color='blue', label=label_I)\n    ax_fi.set_title(title_I)\n    ax_fi.set_xlim(0, t_xlim)\n    ax_fi.set_xlabel(\"Tempo (s)\")\n    ax_fi.set_ylabel(\"Amplitude\")\n    ax_fi.grid(True)\n    leg_fi = ax_fi.legend(loc='upper right', frameon=True, edgecolor='black',\n                          facecolor='white', fontsize=12, fancybox=True)\n    leg_fi.get_frame().set_facecolor('white')\n    leg_fi.get_frame().set_edgecolor('black')\n    leg_fi.get_frame().set_alpha(1.0)\n\n    # Q filtrado\n    ax_fq = fig_filt.add_subplot(gs_filt[2])\n    ax_fq.plot(t_interp, d_Q_rec, color='green', label=label_Q)\n    ax_fq.set_title(title_Q)\n    ax_fq.set_xlim(0, t_xlim)\n    ax_fq.set_xlabel(\"Tempo (s)\")\n    ax_fq.set_ylabel(\"Amplitude\")\n    ax_fq.grid(True)\n    leg_fq = ax_fq.legend(loc='upper right', frameon=True, edgecolor='black',\n                          facecolor='white', fontsize=12, fancybox=True)\n    leg_fq.get_frame().set_facecolor('white')\n    leg_fq.get_frame().set_edgecolor('black')\n    leg_fq.get_frame().set_alpha(1.0)\n\n    plt.tight_layout()\n    self._save_or_show(fig_filt, save_path)\n</code></pre>"},{"location":"api/plots/#plots.Plotter.plot_lowpass_filter","title":"<code>plot_lowpass_filter(t_imp, impulse_response, t_interp, d_I_rec, d_Q_rec, t_xlim=0.1, save_path=None)</code>","text":"<p>Plota a resposta ao impulso de um filtro passa-baixa e os sinais I e Q ap\u00f3s filtragem.</p> <p>Parameters:</p> Name Type Description Default <code>t_imp</code> <code>ndarray</code> <p>Vetor de tempo da resposta ao impulso (em segundos).</p> required <code>impulse_response</code> <code>ndarray</code> <p>Amostras da resposta ao impulso.</p> required <code>t_interp</code> <code>ndarray</code> <p>Vetor de tempo dos sinais filtrados (em segundos).</p> required <code>d_I_rec</code> <code>ndarray</code> <p>Sinal I filtrado.</p> required <code>d_Q_rec</code> <code>ndarray</code> <p>Sinal Q filtrado.</p> required <code>t_xlim</code> <code>float</code> <p>Limite do eixo X (em segundos) para os sinais filtrados.</p> <code>0.1</code> <code>save_path</code> <code>str</code> <p>Caminho para salvar a figura. Se None, exibe na tela.</p> <code>None</code> Source code in <code>src/plots.py</code> <pre><code>def plot_lowpass_filter(self, t_imp, impulse_response, t_interp, d_I_rec, d_Q_rec, t_xlim=0.1, save_path=None):\n    \"\"\"\n    Plota a resposta ao impulso de um filtro passa-baixa e os sinais I e Q ap\u00f3s filtragem.\n\n    Args:\n        t_imp (np.ndarray): Vetor de tempo da resposta ao impulso (em segundos).\n        impulse_response (np.ndarray): Amostras da resposta ao impulso.\n        t_interp (np.ndarray): Vetor de tempo dos sinais filtrados (em segundos).\n        d_I_rec (np.ndarray): Sinal I filtrado.\n        d_Q_rec (np.ndarray): Sinal Q filtrado.\n        t_xlim (float): Limite do eixo X (em segundos) para os sinais filtrados.\n        save_path (str, optional): Caminho para salvar a figura. Se None, exibe na tela.\n    \"\"\"\n    fig_filt = plt.figure(figsize=(16, 10))\n    gs_filt = gridspec.GridSpec(3, 1)\n\n    # Resposta ao impulso\n    ax_imp = fig_filt.add_subplot(gs_filt[0])\n    ax_imp.plot(t_imp * 1000, impulse_response, color='red', label='Resposta ao Impulso - FPB', linewidth=2)\n    ax_imp.set_title(\"Resposta ao Impulso do Filtro Passa-Baixa\")\n    ax_imp.set_xlim(0, 2)\n    ax_imp.set_xlabel(\"Tempo (ms)\")\n    ax_imp.set_ylabel(\"Amplitude\")\n    ax_imp.grid(True)\n    leg_imp = ax_imp.legend(\n        loc='upper right', frameon=True, edgecolor='black',\n        facecolor='white', fontsize=12, fancybox=True\n    )\n    leg_imp.get_frame().set_facecolor('white')\n    leg_imp.get_frame().set_edgecolor('black')\n    leg_imp.get_frame().set_alpha(1.0)\n\n    # I filtrado\n    ax_fi = fig_filt.add_subplot(gs_filt[1])\n    ax_fi.plot(t_interp, d_I_rec, color='blue', label=r\"$d_I(t)$ filtrado\")\n    ax_fi.set_title(\"Canal I ap\u00f3s filtragem passa-baixa\")\n    ax_fi.set_xlim(0, t_xlim)\n    ax_fi.set_xlabel(\"Tempo (s)\")\n    ax_fi.set_ylabel(\"Amplitude\")\n    ax_fi.grid(True)\n    leg_fi = ax_fi.legend(\n        loc='upper right', frameon=True, edgecolor='black',\n        facecolor='white', fontsize=12, fancybox=True\n    )\n    leg_fi.get_frame().set_facecolor('white')\n    leg_fi.get_frame().set_edgecolor('black')\n    leg_fi.get_frame().set_alpha(1.0)\n\n    # Q filtrado\n    ax_fq = fig_filt.add_subplot(gs_filt[2])\n    ax_fq.plot(t_interp, d_Q_rec, color='green', label=r\"$d_Q(t)$ filtrado\")\n    ax_fq.set_title(\"Canal Q ap\u00f3s filtragem passa-baixa\")\n    ax_fq.set_xlim(0, t_xlim)\n    ax_fq.set_xlabel(\"Tempo (s)\")\n    ax_fq.set_ylabel(\"Amplitude\")\n    ax_fq.grid(True)\n    leg_fq = ax_fq.legend(\n        loc='upper right', frameon=True, edgecolor='black',\n        facecolor='white', fontsize=12, fancybox=True\n    )\n    leg_fq.get_frame().set_facecolor('white')\n    leg_fq.get_frame().set_edgecolor('black')\n    leg_fq.get_frame().set_alpha(1.0)\n\n    plt.tight_layout()\n    self._save_or_show(fig_filt, save_path)\n</code></pre>"},{"location":"api/plots/#plots.Plotter.plot_lowpass_freq","title":"<code>plot_lowpass_freq(t_imp, impulse_response, y_I_, y_Q_, d_I_rec, d_Q_rec, fs, fc, save_path=None)</code>","text":"<p>Plota a resposta ao impulso de um filtro passa-baixa e os espectros antes e depois da filtragem para os canais I e Q.</p> <p>Parameters:</p> Name Type Description Default <code>t_imp</code> <code>ndarray</code> <p>Vetor de tempo da resposta ao impulso (em segundos).</p> required <code>impulse_response</code> <code>ndarray</code> <p>Resposta ao impulso do filtro.</p> required <code>y_I_</code> <code>ndarray</code> <p>Sinal I antes da filtragem.</p> required <code>y_Q_</code> <code>ndarray</code> <p>Sinal Q antes da filtragem.</p> required <code>d_I_rec</code> <code>ndarray</code> <p>Sinal I ap\u00f3s filtragem.</p> required <code>d_Q_rec</code> <code>ndarray</code> <p>Sinal Q ap\u00f3s filtragem.</p> required <code>fs</code> <code>float</code> <p>Frequ\u00eancia de amostragem (Hz).</p> required <code>fc</code> <code>float</code> <p>Frequ\u00eancia central para o plot (Hz).</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar a figura. Se None, exibe na tela.</p> <code>None</code> Source code in <code>src/plots.py</code> <pre><code>def plot_lowpass_freq(self, t_imp, impulse_response,\n                                   y_I_, y_Q_, d_I_rec, d_Q_rec,\n                                   fs, fc, save_path=None):\n    \"\"\"\n    Plota a resposta ao impulso de um filtro passa-baixa e os espectros\n    antes e depois da filtragem para os canais I e Q.\n\n    Args:\n        t_imp (np.ndarray): Vetor de tempo da resposta ao impulso (em segundos).\n        impulse_response (np.ndarray): Resposta ao impulso do filtro.\n        y_I_ (np.ndarray): Sinal I antes da filtragem.\n        y_Q_ (np.ndarray): Sinal Q antes da filtragem.\n        d_I_rec (np.ndarray): Sinal I ap\u00f3s filtragem.\n        d_Q_rec (np.ndarray): Sinal Q ap\u00f3s filtragem.\n        fs (float): Frequ\u00eancia de amostragem (Hz).\n        fc (float): Frequ\u00eancia central para o plot (Hz).\n        save_path (str, optional): Caminho para salvar a figura. Se None, exibe na tela.\n    \"\"\"\n    fig_spec = plt.figure(figsize=(16, 10))\n    gs_spec = gridspec.GridSpec(3, 2, height_ratios=[1, 1, 1])\n\n    # Linha 1 (0, :) - Resposta ao impulso\n    ax_impulse = fig_spec.add_subplot(gs_spec[0, :])\n    ax_impulse.plot(t_imp * 1000, impulse_response, color='red', linewidth=2, label='Resposta ao Impulso - FPB')\n    ax_impulse.set_title(\"Resposta ao Impulso do Filtro Passa-Baixa\")\n    ax_impulse.set_xlabel(\"Tempo (ms)\")\n    ax_impulse.set_xlim(0, 2)\n    ax_impulse.set_ylabel(\"Amplitude\")\n    ax_impulse.grid(True)\n    leg_impulse = ax_impulse.legend(\n        loc='upper right', frameon=True, edgecolor='black',\n        facecolor='white', fontsize=12, fancybox=True\n    )\n    leg_impulse.get_frame().set_facecolor('white')\n    leg_impulse.get_frame().set_edgecolor('black')\n    leg_impulse.get_frame().set_alpha(1.0)\n\n    # Frequ\u00eancias\n    freqs = np.fft.fftshift(np.fft.fftfreq(len(y_I_), d=1/fs))\n\n    # FFT antes da filtragem (y'_I)\n    YI_db = mag2db(np.fft.fftshift(np.fft.fft(y_I_)))\n    ax_yi = fig_spec.add_subplot(gs_spec[1, 0])\n    ax_yi.plot(freqs, YI_db, color='blue', label=r\"$|X'_I(f)|$\")\n    ax_yi.set_xlim(-2.5 * fc, 2.5 * fc)\n    ax_yi.set_ylim(-80, 5)\n    ax_yi.set_title(r\"Espectro de $x'_I(t)$ (Antes do FPB)\")\n    ax_yi.set_xlabel(\"Frequ\u00eancia (Hz)\")\n    ax_yi.set_ylabel(\"Magnitude (dB)\")\n    ax_yi.grid(True)\n    leg_yi = ax_yi.legend(\n        loc='upper right', frameon=True, edgecolor='black',\n        facecolor='white', fontsize=12, fancybox=True\n    )\n    leg_yi.get_frame().set_facecolor('white')\n    leg_yi.get_frame().set_edgecolor('black')\n    leg_yi.get_frame().set_alpha(1.0)\n\n    # FFT depois da filtragem (d_I)\n    DI_db = mag2db(np.fft.fftshift(np.fft.fft(d_I_rec)))\n    ax_di = fig_spec.add_subplot(gs_spec[1, 1])\n    ax_di.plot(freqs, DI_db, color='darkblue', label=r\"$|d'_I(f)|$\")\n    ax_di.set_xlim(-2.5 * fc, 2.5 * fc)\n    ax_di.set_ylim(-80, 5)\n    ax_di.set_title(r\"Espectro de $d'_I(t)$ (Ap\u00f3s FPB)\")\n    ax_di.set_xlabel(\"Frequ\u00eancia (Hz)\")\n    ax_di.set_ylabel(\"Magnitude (dB)\")\n    ax_di.grid(True)\n    leg_di = ax_di.legend(\n        loc='upper right', frameon=True, edgecolor='black',\n        facecolor='white', fontsize=12, fancybox=True\n    )\n    leg_di.get_frame().set_facecolor('white')\n    leg_di.get_frame().set_edgecolor('black')\n    leg_di.get_frame().set_alpha(1.0)\n\n    # FFT antes da filtragem (y'_Q)\n    YQ_db = mag2db(np.fft.fftshift(np.fft.fft(y_Q_)))\n    ax_yq = fig_spec.add_subplot(gs_spec[2, 0])\n    ax_yq.plot(freqs, YQ_db, color='green', label=r\"$|Y'_Q(f)|$\")\n    ax_yq.set_xlim(-2.5 * fc, 2.5 * fc)\n    ax_yq.set_ylim(-90, 5)\n    ax_yq.set_title(r\"Espectro de $y'_Q(t)$ (Antes do FPB)\")\n    ax_yq.set_xlabel(\"Frequ\u00eancia (Hz)\")\n    ax_yq.set_ylabel(\"Magnitude (dB)\")\n    ax_yq.grid(True)\n    leg_yq = ax_yq.legend(\n        loc='upper right', frameon=True, edgecolor='black',\n        facecolor='white', fontsize=12, fancybox=True\n    )\n    leg_yq.get_frame().set_facecolor('white')\n    leg_yq.get_frame().set_edgecolor('black')\n    leg_yq.get_frame().set_alpha(1.0)\n\n    # FFT depois da filtragem (d_Q)\n    DQ_db = mag2db(np.fft.fftshift(np.fft.fft(d_Q_rec)))\n    ax_dq = fig_spec.add_subplot(gs_spec[2, 1])\n    ax_dq.plot(freqs, DQ_db, color='darkgreen', label=r\"$|d_Q(f)|$\")\n    ax_dq.set_xlim(-2.5 * fc, 2.5 * fc)\n    ax_dq.set_ylim(-90, 5)\n    ax_dq.set_title(r\"Espectro de $d'_Q(t)$ (Ap\u00f3s FPB)\")\n    ax_dq.set_xlabel(\"Frequ\u00eancia (Hz)\")\n    ax_dq.set_ylabel(\"Magnitude (dB)\")\n    ax_dq.grid(True)\n    leg_dq = ax_dq.legend(\n        loc='upper right', frameon=True, edgecolor='black',\n        facecolor='white', fontsize=12, fancybox=True\n    )\n    leg_dq.get_frame().set_facecolor('white')\n    leg_dq.get_frame().set_edgecolor('black')\n    leg_dq.get_frame().set_alpha(1.0)\n\n    plt.tight_layout()\n    plt.subplots_adjust(top=0.92, hspace=0.4)\n    self._save_or_show(fig_spec, save_path)\n</code></pre>"},{"location":"api/plots/#plots.Plotter.plot_matched_filter","title":"<code>plot_matched_filter(t_rc, g_matched, t_matched, d_I_matched, d_Q_matched, label_imp, label_I, label_Q, title_imp, title_I, title_Q, t_xlim=0.1, save_path=None)</code>","text":"<p>Plota a resposta ao impulso do filtro casado e os sinais I e Q ap\u00f3s a filtragem.</p> <p>Parameters:</p> Name Type Description Default <code>t_rc</code> <code>ndarray</code> <p>Vetor de tempo da resposta ao impulso do filtro casado.</p> required <code>g_matched</code> <code>ndarray</code> <p>Amostras da resposta ao impulso.</p> required <code>t_matched</code> <code>ndarray</code> <p>Vetor de tempo dos sinais filtrados.</p> required <code>d_I_matched</code> <code>ndarray</code> <p>Sinal I filtrado.</p> required <code>d_Q_matched</code> <code>ndarray</code> <p>Sinal Q filtrado.</p> required <code>label_imp</code> <code>str</code> <p>R\u00f3tulo da resposta ao impulso.</p> required <code>label_I</code> <code>str</code> <p>R\u00f3tulo do canal I filtrado.</p> required <code>label_Q</code> <code>str</code> <p>R\u00f3tulo do canal Q filtrado.</p> required <code>title_imp</code> <code>str</code> <p>T\u00edtulo do gr\u00e1fico da resposta ao impulso.</p> required <code>title_I</code> <code>str</code> <p>T\u00edtulo do gr\u00e1fico do canal I.</p> required <code>title_Q</code> <code>str</code> <p>T\u00edtulo do gr\u00e1fico do canal Q.</p> required <code>t_xlim</code> <code>float</code> <p>Limite do eixo X para os canais I e Q.</p> <code>0.1</code> <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico.</p> <code>None</code> Source code in <code>src/plots.py</code> <pre><code>def plot_matched_filter(self, t_rc, g_matched, t_matched, d_I_matched, d_Q_matched,\n                        label_imp, label_I, label_Q,\n                        title_imp, title_I, title_Q,\n                        t_xlim=0.1, save_path=None):\n    \"\"\"\n    Plota a resposta ao impulso do filtro casado e os sinais I e Q ap\u00f3s a filtragem.\n\n    Args:\n        t_rc (np.ndarray): Vetor de tempo da resposta ao impulso do filtro casado.\n        g_matched (np.ndarray): Amostras da resposta ao impulso.\n        t_matched (np.ndarray): Vetor de tempo dos sinais filtrados.\n        d_I_matched (np.ndarray): Sinal I filtrado.\n        d_Q_matched (np.ndarray): Sinal Q filtrado.\n        label_imp (str): R\u00f3tulo da resposta ao impulso.\n        label_I (str): R\u00f3tulo do canal I filtrado.\n        label_Q (str): R\u00f3tulo do canal Q filtrado.\n        title_imp (str): T\u00edtulo do gr\u00e1fico da resposta ao impulso.\n        title_I (str): T\u00edtulo do gr\u00e1fico do canal I.\n        title_Q (str): T\u00edtulo do gr\u00e1fico do canal Q.\n        t_xlim (float, optional): Limite do eixo X para os canais I e Q.\n        save_path (str, optional): Caminho para salvar o gr\u00e1fico.\n    \"\"\"\n    fig_match = plt.figure(figsize=(16, 10))\n    gs_match = gridspec.GridSpec(3, 1)\n\n    # Resposta ao impulso do filtro casado\n    ax_mh = fig_match.add_subplot(gs_match[0])\n    ax_mh.plot(t_rc * 1000, g_matched, color='red', label=label_imp)\n    ax_mh.set_title(title_imp)\n    ax_mh.set_xlim(-15, 15)\n    ax_mh.set_xlabel(\"Tempo (ms)\")\n    ax_mh.set_ylabel(\"Amplitude\")\n    ax_mh.grid(True)\n    leg_mh = ax_mh.legend(\n        loc='upper right', frameon=True, edgecolor='black',\n        facecolor='white', fontsize=12, fancybox=True\n    )\n    leg_mh.get_frame().set_facecolor('white')\n    leg_mh.get_frame().set_edgecolor('black')\n    leg_mh.get_frame().set_alpha(1.0)\n\n    # Canal I ap\u00f3s filtro casado\n    ax_i_m = fig_match.add_subplot(gs_match[1])\n    ax_i_m.plot(t_matched, d_I_matched, color='blue', label=label_I)\n    ax_i_m.set_title(title_I)\n    ax_i_m.set_xlim(0, t_xlim)\n    ax_i_m.set_xlabel(\"Tempo (s)\")\n    ax_i_m.set_ylabel(\"Amplitude\")\n    ax_i_m.grid(True)\n    leg_i_m = ax_i_m.legend(\n        loc='upper right', frameon=True, edgecolor='black',\n        facecolor='white', fontsize=12, fancybox=True\n    )\n    leg_i_m.get_frame().set_facecolor('white')\n    leg_i_m.get_frame().set_edgecolor('black')\n    leg_i_m.get_frame().set_alpha(1.0)\n\n    # Canal Q ap\u00f3s filtro casado\n    ax_q_m = fig_match.add_subplot(gs_match[2])\n    ax_q_m.plot(t_matched, d_Q_matched, color='green', label=label_Q)\n    ax_q_m.set_title(title_Q)\n    ax_q_m.set_xlim(0, t_xlim)\n    ax_q_m.set_xlabel(\"Tempo (s)\")\n    ax_q_m.set_ylabel(\"Amplitude\")\n    ax_q_m.grid(True)\n    leg_q_m = ax_q_m.legend(\n        loc='upper right', frameon=True, edgecolor='black',\n        facecolor='white', fontsize=12, fancybox=True\n    )\n    leg_q_m.get_frame().set_facecolor('white')\n    leg_q_m.get_frame().set_edgecolor('black')\n    leg_q_m.get_frame().set_alpha(1.0)\n\n    plt.tight_layout()\n    plt.subplots_adjust(top=0.92, hspace=0.4)\n\n    self._save_or_show(fig_match, save_path)\n</code></pre>"},{"location":"api/plots/#plots.Plotter.plot_matched_filter_freq","title":"<code>plot_matched_filter_freq(t_rc, g_matched, d_I_rec, d_Q_rec, d_I_matched, d_Q_matched, fs, fc, label_imp, label_I_before, label_I_after, label_Q_before, label_Q_after, title_imp, title_I_before, title_I_after, title_Q_before, title_Q_after, save_path=None)</code>","text":"<p>Plota o espectro dos sinais I e Q antes e depois da filtragem casada, junto com a resposta ao impulso do filtro casado.</p> <p>Parameters:</p> Name Type Description Default <code>t_rc</code> <code>ndarray</code> <p>Vetor de tempo da resposta ao impulso do filtro casado.</p> required <code>g_matched</code> <code>ndarray</code> <p>Resposta ao impulso do filtro casado.</p> required <code>d_I_rec</code> <code>ndarray</code> <p>Sinal I antes do filtro casado.</p> required <code>d_Q_rec</code> <code>ndarray</code> <p>Sinal Q antes do filtro casado.</p> required <code>d_I_matched</code> <code>ndarray</code> <p>Sinal I ap\u00f3s o filtro casado.</p> required <code>d_Q_matched</code> <code>ndarray</code> <p>Sinal Q ap\u00f3s o filtro casado.</p> required <code>fs</code> <code>float</code> <p>Frequ\u00eancia de amostragem (Hz).</p> required <code>fc</code> <code>float</code> <p>Frequ\u00eancia central para o plot (Hz).</p> required <code>label_imp</code> <code>str</code> <p>R\u00f3tulo da resposta ao impulso.</p> required <code>label_I_before</code> <code>str</code> <p>R\u00f3tulo do canal I antes do filtro casado.</p> required <code>label_I_after</code> <code>str</code> <p>R\u00f3tulo do canal I ap\u00f3s o filtro casado.</p> required <code>label_Q_before</code> <code>str</code> <p>R\u00f3tulo do canal Q antes do filtro casado.</p> required <code>label_Q_after</code> <code>str</code> <p>R\u00f3tulo do canal Q ap\u00f3s o filtro casado.</p> required <code>title_imp</code> <code>str</code> <p>T\u00edtulo do gr\u00e1fico da resposta ao impulso.</p> required <code>title_I_before</code> <code>str</code> <p>T\u00edtulo do espectro do canal I antes do filtro casado.</p> required <code>title_I_after</code> <code>str</code> <p>T\u00edtulo do espectro do canal I ap\u00f3s o filtro casado.</p> required <code>title_Q_before</code> <code>str</code> <p>T\u00edtulo do espectro do canal Q antes do filtro casado.</p> required <code>title_Q_after</code> <code>str</code> <p>T\u00edtulo do espectro do canal Q ap\u00f3s o filtro casado.</p> required <code>save_path</code> <code>str</code> <p>Caminho para salvar a figura.</p> <code>None</code> Source code in <code>src/plots.py</code> <pre><code>def plot_matched_filter_freq(self, t_rc, g_matched,\n                                 d_I_rec, d_Q_rec,\n                                 d_I_matched, d_Q_matched,\n                                 fs, fc,\n                                 label_imp, label_I_before, label_I_after,\n                                 label_Q_before, label_Q_after,\n                                 title_imp, title_I_before, title_I_after,\n                                 title_Q_before, title_Q_after,\n                                 save_path=None):\n    \"\"\"\n    Plota o espectro dos sinais I e Q antes e depois da filtragem casada,\n    junto com a resposta ao impulso do filtro casado.\n\n    Args:\n        t_rc (np.ndarray): Vetor de tempo da resposta ao impulso do filtro casado.\n        g_matched (np.ndarray): Resposta ao impulso do filtro casado.\n        d_I_rec (np.ndarray): Sinal I antes do filtro casado.\n        d_Q_rec (np.ndarray): Sinal Q antes do filtro casado.\n        d_I_matched (np.ndarray): Sinal I ap\u00f3s o filtro casado.\n        d_Q_matched (np.ndarray): Sinal Q ap\u00f3s o filtro casado.\n        fs (float): Frequ\u00eancia de amostragem (Hz).\n        fc (float): Frequ\u00eancia central para o plot (Hz).\n        label_imp (str): R\u00f3tulo da resposta ao impulso.\n        label_I_before (str): R\u00f3tulo do canal I antes do filtro casado.\n        label_I_after (str): R\u00f3tulo do canal I ap\u00f3s o filtro casado.\n        label_Q_before (str): R\u00f3tulo do canal Q antes do filtro casado.\n        label_Q_after (str): R\u00f3tulo do canal Q ap\u00f3s o filtro casado.\n        title_imp (str): T\u00edtulo do gr\u00e1fico da resposta ao impulso.\n        title_I_before (str): T\u00edtulo do espectro do canal I antes do filtro casado.\n        title_I_after (str): T\u00edtulo do espectro do canal I ap\u00f3s o filtro casado.\n        title_Q_before (str): T\u00edtulo do espectro do canal Q antes do filtro casado.\n        title_Q_after (str): T\u00edtulo do espectro do canal Q ap\u00f3s o filtro casado.\n        save_path (str, optional): Caminho para salvar a figura.\n    \"\"\"\n    # FFT antes do filtro casado\n    DI_f = np.fft.fftshift(np.fft.fft(d_I_rec))\n    DQ_f = np.fft.fftshift(np.fft.fft(d_Q_rec))\n\n    # FFT ap\u00f3s o filtro casado\n    DIM_f = np.fft.fftshift(np.fft.fft(d_I_matched))\n    DQM_f = np.fft.fftshift(np.fft.fft(d_Q_matched))\n\n    freqs = np.fft.fftshift(np.fft.fftfreq(len(d_I_rec), d=1/fs))\n\n    DI_db = mag2db(DI_f)\n    DQ_db = mag2db(DQ_f)\n    DIM_db = mag2db(DIM_f)\n    DQM_db = mag2db(DQM_f)\n\n    fig_match_spec = plt.figure(figsize=(16, 10))\n    gs_match_spec = gridspec.GridSpec(3, 2, height_ratios=[1, 1, 1])\n\n    # Resposta ao impulso\n    ax_imp_m = fig_match_spec.add_subplot(gs_match_spec[0, :])\n    ax_imp_m.plot(t_rc * 1000, g_matched, color='red', linewidth=2, label=label_imp)\n    ax_imp_m.set_title(title_imp)\n    ax_imp_m.set_xlim(-15, 15)\n    ax_imp_m.set_xlabel(\"Tempo (ms)\")\n    ax_imp_m.set_ylabel(\"Amplitude\")\n    ax_imp_m.grid(True)\n    leg_imp = ax_imp_m.legend(loc='upper right', frameon=True, edgecolor='black',\n                              facecolor='white', fontsize=12, fancybox=True)\n    leg_imp.get_frame().set_facecolor('white')\n    leg_imp.get_frame().set_edgecolor('black')\n    leg_imp.get_frame().set_alpha(1.0)\n\n    # Canal I antes\n    ax_i_before = fig_match_spec.add_subplot(gs_match_spec[1, 0])\n    ax_i_before.plot(freqs, DI_db, color='navy', label=label_I_before)\n    ax_i_before.set_title(title_I_before)\n    ax_i_before.set_xlabel(\"Frequ\u00eancia (Hz)\")\n    ax_i_before.set_ylabel(\"Magnitude (dB)\")\n    ax_i_before.set_xlim(-fc, fc)\n    ax_i_before.set_ylim(-90, 5)\n    ax_i_before.grid(True)\n    leg_ib = ax_i_before.legend(loc='upper right', frameon=True, edgecolor='black',\n                                facecolor='white', fontsize=12, fancybox=True)\n    leg_ib.get_frame().set_facecolor('white')\n    leg_ib.get_frame().set_edgecolor('black')\n    leg_ib.get_frame().set_alpha(1.0)\n\n    # Canal I ap\u00f3s\n    ax_i_after = fig_match_spec.add_subplot(gs_match_spec[1, 1])\n    ax_i_after.plot(freqs, DIM_db, color='navy', label=label_I_after)\n    ax_i_after.set_title(title_I_after)\n    ax_i_after.set_xlabel(\"Frequ\u00eancia (Hz)\")\n    ax_i_after.set_ylabel(\"Magnitude (dB)\")\n    ax_i_after.set_xlim(-fc, fc)\n    ax_i_after.set_ylim(-90, 5)\n    ax_i_after.grid(True)\n    leg_ia = ax_i_after.legend(loc='upper right', frameon=True, edgecolor='black',\n                               facecolor='white', fontsize=12, fancybox=True)\n    leg_ia.get_frame().set_facecolor('white')\n    leg_ia.get_frame().set_edgecolor('black')\n    leg_ia.get_frame().set_alpha(1.0)\n\n    # Canal Q antes\n    ax_q_before = fig_match_spec.add_subplot(gs_match_spec[2, 0])\n    ax_q_before.plot(freqs, DQ_db, color='darkgreen', label=label_Q_before)\n    ax_q_before.set_title(title_Q_before)\n    ax_q_before.set_xlabel(\"Frequ\u00eancia (Hz)\")\n    ax_q_before.set_ylabel(\"Magnitude (dB)\")\n    ax_q_before.set_xlim(-fc, fc)\n    ax_q_before.set_ylim(-90, 5)\n    ax_q_before.grid(True)\n    leg_qb = ax_q_before.legend(loc='upper right', frameon=True, edgecolor='black',\n                                facecolor='white', fontsize=12, fancybox=True)\n    leg_qb.get_frame().set_facecolor('white')\n    leg_qb.get_frame().set_edgecolor('black')\n    leg_qb.get_frame().set_alpha(1.0)\n\n    # Canal Q ap\u00f3s\n    ax_q_after = fig_match_spec.add_subplot(gs_match_spec[2, 1])\n    ax_q_after.plot(freqs, DQM_db, color='green', label=label_Q_after)\n    ax_q_after.set_title(title_Q_after)\n    ax_q_after.set_xlabel(\"Frequ\u00eancia (Hz)\")\n    ax_q_after.set_ylabel(\"Magnitude (dB)\")\n    ax_q_after.set_xlim(-fc, fc)\n    ax_q_after.set_ylim(-90, 5)\n    ax_q_after.grid(True)\n    leg_qa = ax_q_after.legend(loc='upper right', frameon=True, edgecolor='black',\n                               facecolor='white', fontsize=12, fancybox=True)\n    leg_qa.get_frame().set_facecolor('white')\n    leg_qa.get_frame().set_edgecolor('black')\n    leg_qa.get_frame().set_alpha(1.0)\n\n    plt.tight_layout()\n    plt.subplots_adjust(top=0.93, hspace=0.4)\n\n    self._save_or_show(fig_match_spec, save_path)\n</code></pre>"},{"location":"api/plots/#plots.Plotter.plot_sampled_signals","title":"<code>plot_sampled_signals(t_matched, d_I_matched, d_Q_matched, t_samples, I_samples, Q_samples, label_I, label_I_samples, label_Q, label_Q_samples, title_I, title_Q, t_xlim=0.1, save_path=None)</code>","text":"<p>Plota os sinais I e Q ap\u00f3s o filtro casado com os pontos de amostragem.</p> <p>Parameters:</p> Name Type Description Default <code>t_matched</code> <code>ndarray</code> <p>Vetor de tempo dos sinais filtrados.</p> required <code>d_I_matched</code> <code>ndarray</code> <p>Sinal I ap\u00f3s o filtro casado.</p> required <code>d_Q_matched</code> <code>ndarray</code> <p>Sinal Q ap\u00f3s o filtro casado.</p> required <code>t_samples</code> <code>ndarray</code> <p>Instantes de amostragem.</p> required <code>I_samples</code> <code>ndarray</code> <p>Amostras do canal I.</p> required <code>Q_samples</code> <code>ndarray</code> <p>Amostras do canal Q.</p> required <code>label_I</code> <code>str</code> <p>R\u00f3tulo do sinal I filtrado.</p> required <code>label_I_samples</code> <code>str</code> <p>R\u00f3tulo das amostras I.</p> required <code>label_Q</code> <code>str</code> <p>R\u00f3tulo do sinal Q filtrado.</p> required <code>label_Q_samples</code> <code>str</code> <p>R\u00f3tulo das amostras Q.</p> required <code>title_I</code> <code>str</code> <p>T\u00edtulo do gr\u00e1fico do canal I.</p> required <code>title_Q</code> <code>str</code> <p>T\u00edtulo do gr\u00e1fico do canal Q.</p> required <code>t_xlim</code> <code>float</code> <p>Limite do eixo X para ambos os gr\u00e1ficos.</p> <code>0.1</code> <code>save_path</code> <code>str</code> <p>Caminho para salvar o gr\u00e1fico.</p> <code>None</code> Source code in <code>src/plots.py</code> <pre><code>def plot_sampled_signals(self, t_matched, d_I_matched, d_Q_matched,\n                         t_samples, I_samples, Q_samples,\n                         label_I, label_I_samples,\n                         label_Q, label_Q_samples,\n                         title_I, title_Q,\n                         t_xlim=0.1, save_path=None):\n    \"\"\"\n    Plota os sinais I e Q ap\u00f3s o filtro casado com os pontos de amostragem.\n\n    Args:\n        t_matched (np.ndarray): Vetor de tempo dos sinais filtrados.\n        d_I_matched (np.ndarray): Sinal I ap\u00f3s o filtro casado.\n        d_Q_matched (np.ndarray): Sinal Q ap\u00f3s o filtro casado.\n        t_samples (np.ndarray): Instantes de amostragem.\n        I_samples (np.ndarray): Amostras do canal I.\n        Q_samples (np.ndarray): Amostras do canal Q.\n        label_I (str): R\u00f3tulo do sinal I filtrado.\n        label_I_samples (str): R\u00f3tulo das amostras I.\n        label_Q (str): R\u00f3tulo do sinal Q filtrado.\n        label_Q_samples (str): R\u00f3tulo das amostras Q.\n        title_I (str): T\u00edtulo do gr\u00e1fico do canal I.\n        title_Q (str): T\u00edtulo do gr\u00e1fico do canal Q.\n        t_xlim (float, optional): Limite do eixo X para ambos os gr\u00e1ficos.\n        save_path (str, optional): Caminho para salvar o gr\u00e1fico.\n    \"\"\"\n    fig_sample = plt.figure(figsize=(16, 8))\n    gs_sample = gridspec.GridSpec(2, 1)\n\n    # Canal I\n    ax_si = fig_sample.add_subplot(gs_sample[0])\n    ax_si.plot(t_matched, d_I_matched, color='blue', label=label_I)\n    ax_si.stem(t_samples, I_samples, linefmt='k-', markerfmt='ko', basefmt=\" \", label=label_I_samples)\n    ax_si.set_title(title_I)\n    ax_si.set_xlabel(\"Tempo (s)\")\n    ax_si.set_ylabel(\"Amplitude\")\n    ax_si.set_xlim(0, t_xlim)\n    ax_si.grid(True)\n    leg_si = ax_si.legend(loc='upper right', frameon=True, edgecolor='black',\n                          facecolor='white', fontsize=12, fancybox=True)\n    leg_si.get_frame().set_facecolor('white')\n    leg_si.get_frame().set_edgecolor('black')\n    leg_si.get_frame().set_alpha(1.0)\n\n    # Canal Q\n    ax_sq = fig_sample.add_subplot(gs_sample[1])\n    ax_sq.plot(t_matched, d_Q_matched, color='green', label=label_Q)\n    ax_sq.stem(t_samples, Q_samples, linefmt='k-', markerfmt='ko', basefmt=\" \", label=label_Q_samples)\n    ax_sq.set_title(title_Q)\n    ax_sq.set_xlabel(\"Tempo (s)\")\n    ax_sq.set_ylabel(\"Amplitude\")\n    ax_sq.set_xlim(0, t_xlim)\n    ax_sq.grid(True)\n    leg_sq = ax_sq.legend(loc='upper right', frameon=True, edgecolor='black',\n                          facecolor='white', fontsize=12, fancybox=True)\n    leg_sq.get_frame().set_facecolor('white')\n    leg_sq.get_frame().set_edgecolor('black')\n    leg_sq.get_frame().set_alpha(1.0)\n\n    plt.tight_layout()\n    self._save_or_show(fig_sample, save_path)\n</code></pre>"},{"location":"api/preamble/","title":"Preamble","text":"Source code in <code>src/preamble.py</code> <pre><code>class Preamble:\n\n    def __init__(self, preamble_hex=\"2BEEEEBF\"):\n        r\"\"\"\n        Inicializa uma inst\u00e2ncia de palavra de sincronismo. A palavra de sincronismo $S$ \u00e9 composta por 30 bits, $S = 2BEEEEBF_{16}$, conforme o padr\u00e3o PPT-A3.\n\n        Refer\u00eancia:\n            AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.6)\n\n        Args:\n            preamble_hex (str, opcional): Hexadecimal da palavra de sincronismo.\n\n        Raises:\n            ValueError: Se a palavra de sincronismo n\u00e3o contiver 30 bits.\n            ValueError: Se o hexadecimal n\u00e3o for v\u00e1lido ou n\u00e3o puder ser convertido para 30 bits\n        \"\"\"\n\n        if not isinstance(preamble_hex, str) or len(preamble_hex) != 8:\n            raise ValueError(\"O hexadecimal da palavra de sincronismo deve ser uma string de 8 caracteres.\")\n\n        self.preamble_hex = preamble_hex\n        self.preamble_bits = self.hex_to_bits(self.preamble_hex)\n\n        if len(self.preamble_bits) != 30:\n            raise ValueError(\"A palavra de sincronismo deve conter 30 bits.\")\n\n        self.preamble_sI, self.preamble_sQ = self.generate_preamble()\n\n    def hex_to_bits(self, hex_string):\n        r\"\"\"\n        Converte uma string hexadecimal em uma string de bits de 30 bits.\n\n        Args:\n            hex_string (str): String hexadecimal a ser convertida.\n\n        Returns:\n            bin_str (str): String de bits de 30 bits.\n        \"\"\"\n        return format(int(hex_string, 16), '032b')[2:] \n\n    def generate_preamble(self):\n        r\"\"\"\n        Gera os vetores I e Q da palavra de sincronismo, com base no vetor $S$ passado no construtor.\n\n        Defini\u00e7\u00e3o dos vetores:\n        $$\n        \\begin{align}\n            S_I &amp;= [S_0, S_2, S_4, \\dots, S_{28}]\n        \\end{align}\n        $$\n        $$\n        \\begin{align}\n            S_Q &amp;= [S_1, S_3, S_5, \\dots, S_{29}]\n        \\end{align}\n        $$\n\n        Returns:\n            tuple (np.ndarray, np.ndarray): Vetores $S_I$ e $S_Q$.\n        \"\"\"\n        Si = np.array([int(bit) for bit in self.preamble_bits[::2]])\n        Sq = np.array([int(bit) for bit in self.preamble_bits[1::2]])\n        return Si, Sq\n</code></pre>"},{"location":"api/preamble/#preamble.Preamble.__init__","title":"<code>__init__(preamble_hex='2BEEEEBF')</code>","text":"<p>Inicializa uma inst\u00e2ncia de palavra de sincronismo. A palavra de sincronismo \\(S\\) \u00e9 composta por 30 bits, \\(S = 2BEEEEBF_{16}\\), conforme o padr\u00e3o PPT-A3.</p> Refer\u00eancia <p>AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.6)</p> <p>Parameters:</p> Name Type Description Default <code>preamble_hex</code> <code>(str, opcional)</code> <p>Hexadecimal da palavra de sincronismo.</p> <code>'2BEEEEBF'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se a palavra de sincronismo n\u00e3o contiver 30 bits.</p> <code>ValueError</code> <p>Se o hexadecimal n\u00e3o for v\u00e1lido ou n\u00e3o puder ser convertido para 30 bits</p> Source code in <code>src/preamble.py</code> <pre><code>def __init__(self, preamble_hex=\"2BEEEEBF\"):\n    r\"\"\"\n    Inicializa uma inst\u00e2ncia de palavra de sincronismo. A palavra de sincronismo $S$ \u00e9 composta por 30 bits, $S = 2BEEEEBF_{16}$, conforme o padr\u00e3o PPT-A3.\n\n    Refer\u00eancia:\n        AS3-SP-516-274-CNES (se\u00e7\u00e3o 3.1.4.6)\n\n    Args:\n        preamble_hex (str, opcional): Hexadecimal da palavra de sincronismo.\n\n    Raises:\n        ValueError: Se a palavra de sincronismo n\u00e3o contiver 30 bits.\n        ValueError: Se o hexadecimal n\u00e3o for v\u00e1lido ou n\u00e3o puder ser convertido para 30 bits\n    \"\"\"\n\n    if not isinstance(preamble_hex, str) or len(preamble_hex) != 8:\n        raise ValueError(\"O hexadecimal da palavra de sincronismo deve ser uma string de 8 caracteres.\")\n\n    self.preamble_hex = preamble_hex\n    self.preamble_bits = self.hex_to_bits(self.preamble_hex)\n\n    if len(self.preamble_bits) != 30:\n        raise ValueError(\"A palavra de sincronismo deve conter 30 bits.\")\n\n    self.preamble_sI, self.preamble_sQ = self.generate_preamble()\n</code></pre>"},{"location":"api/preamble/#preamble.Preamble.hex_to_bits","title":"<code>hex_to_bits(hex_string)</code>","text":"<p>Converte uma string hexadecimal em uma string de bits de 30 bits.</p> <p>Parameters:</p> Name Type Description Default <code>hex_string</code> <code>str</code> <p>String hexadecimal a ser convertida.</p> required <p>Returns:</p> Name Type Description <code>bin_str</code> <code>str</code> <p>String de bits de 30 bits.</p> Source code in <code>src/preamble.py</code> <pre><code>def hex_to_bits(self, hex_string):\n    r\"\"\"\n    Converte uma string hexadecimal em uma string de bits de 30 bits.\n\n    Args:\n        hex_string (str): String hexadecimal a ser convertida.\n\n    Returns:\n        bin_str (str): String de bits de 30 bits.\n    \"\"\"\n    return format(int(hex_string, 16), '032b')[2:] \n</code></pre>"},{"location":"api/preamble/#preamble.Preamble.generate_preamble","title":"<code>generate_preamble()</code>","text":"<p>Gera os vetores I e Q da palavra de sincronismo, com base no vetor \\(S\\) passado no construtor.</p> <p>Defini\u00e7\u00e3o dos vetores: $$ \\begin{align}     S_I &amp;= [S_0, S_2, S_4, \\dots, S_{28}] \\end{align} $$ $$ \\begin{align}     S_Q &amp;= [S_1, S_3, S_5, \\dots, S_{29}] \\end{align} $$</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>(ndarray, ndarray)</code> <p>Vetores \\(S_I\\) e \\(S_Q\\).</p> Source code in <code>src/preamble.py</code> <pre><code>def generate_preamble(self):\n    r\"\"\"\n    Gera os vetores I e Q da palavra de sincronismo, com base no vetor $S$ passado no construtor.\n\n    Defini\u00e7\u00e3o dos vetores:\n    $$\n    \\begin{align}\n        S_I &amp;= [S_0, S_2, S_4, \\dots, S_{28}]\n    \\end{align}\n    $$\n    $$\n    \\begin{align}\n        S_Q &amp;= [S_1, S_3, S_5, \\dots, S_{29}]\n    \\end{align}\n    $$\n\n    Returns:\n        tuple (np.ndarray, np.ndarray): Vetores $S_I$ e $S_Q$.\n    \"\"\"\n    Si = np.array([int(bit) for bit in self.preamble_bits[::2]])\n    Sq = np.array([int(bit) for bit in self.preamble_bits[1::2]])\n    return Si, Sq\n</code></pre>"},{"location":"api/receiver/","title":"Receptor","text":"Source code in <code>src/receiver.py</code> <pre><code>class Receiver:\n    def __init__(self, fs=128_000, Rb=400, output_print=True, output_plot=True):\n        r\"\"\"\n        Classe que encapsula todo o processo de recep\u00e7\u00e3o, desde o recebimento do sinal com ru\u00eddo (sinal do canal), at\u00e9 a recupera\u00e7\u00e3o do vetor de bit.\n\n        Args:\n            fs (int): Frequ\u00eancia de amostragem em Hz. Default \u00e9 128000 Hz.\n            Rb (int): Taxa de bits em bps. Default \u00e9 400 bps.\n            output_print (bool): Se True, imprime os vetores intermedi\u00e1rios no console. Default \u00e9 True.\n            output_plot (bool): Se True, gera e salva os gr\u00e1ficos dos processos intermedi\u00e1rios. Default \u00e9 True.\n        \"\"\"\n        self.fs = fs\n        self.Rb = Rb\n        self.output_print = output_print\n        self.output_plot = output_plot\n        self.plotter = Plotter()\n\n    def demodulate(self, s):\n        r\"\"\"\n        Demodula o sinal $s'(t)$ com ru\u00eddo recebido, recuperando os sinais $x'_{I}(t)$ e $y'_{Q}(t)$.\n\n        Args:\n            s (np.ndarray): Sinal $s'(t)$ a ser demodulado.\n\n        Returns:\n            xI_prime (np.ndarray): Sinal $x'_{I}(t)$ demodulado.\n            yQ_prime (np.ndarray): Sinal $y'_{Q}(t)$ demodulado.\n        \"\"\"\n        demodulator = Modulator(fc=self.fc, fs=self.fs)\n        xI_prime, yQ_prime = demodulator.demodulate(s)\n\n        if self.output_print:\n            print(\"\\n ==== DEMODULADOR ==== \\n\")\n            print(\"x'I(t):\", ''.join(map(str, xI_prime[:5])),\"...\")\n            print(\"y'Q(t):\", ''.join(map(str, yQ_prime[:5])),\"...\")\n        if self.output_plot:\n            self.plotter.plot_freq_receiver(\n                xI_prime,\n                yQ_prime,\n                self.fs,\n                self.fc,\n                save_path=\"../out/receiver_freq.pdf\"\n            )\n        return xI_prime, yQ_prime\n\n    def lowpassfilter(self, cut_off, xI_prime, yQ_prime, t):\n        r\"\"\"\n        Aplica o filtro passa-baixa com resposta ao impuslo $h(t)$ aos sinais $x'_{I}(t)$ e $y'_{Q}(t)$.\n\n        Args:\n            cut_off (float): Frequ\u00eancia de corte do filtro.\n            xI_prime (np.ndarray): Sinal $x'_{I}(t)$ a ser filtrado.\n            yQ_prime (np.ndarray): Sinal $y'_{Q}(t)$ a ser filtrado.\n            t (np.ndarray): Vetor de tempo.\n\n        Returns:\n            dI_prime (np.ndarray): Sinal $d'_{I}(t)$ filtrado.\n            dQ_prime (np.ndarray): Sinal $d'_{Q}(t)$ filtrado.\n        \"\"\"\n\n        lpf = LPF(cut_off=cut_off, order=6, fs=self.fs, type=\"butter\")\n        impulse_response, t_impulse = lpf.calc_impulse_response()\n        dI_prime = lpf.apply_filter(xI_prime)\n        dQ_prime = lpf.apply_filter(yQ_prime)\n\n        if self.output_print:\n            print(\"\\n ==== FILTRAGEM PASSA-BAIXA ==== \\n\")\n            print(\"d'I(t):\", ''.join(map(str, dI_prime[:5])),\"...\")\n            print(\"d'Q(t):\", ''.join(map(str, dQ_prime[:5])),\"...\")\n\n        if self.output_plot:\n            self.plotter.plot_lowpass_filter(\n                t_impulse,\n                impulse_response,\n                t,\n                dI_prime,\n                dQ_prime,\n                save_path=\"../out/receiver_lowpass_filter.pdf\"\n            )\n            self.plotter.plot_lowpass_freq(\n                t_impulse,\n                impulse_response,\n                xI_prime,\n                yQ_prime,\n                dI_prime,\n                dQ_prime,\n                self.fs,\n                self.fc,\n                save_path=\"../out/receiver_lowpass_freq.pdf\"\n            )\n\n        return dI_prime, dQ_prime\n\n    def matchedfilter(self, dI_prime, dQ_prime, t):\n        r\"\"\"\n        Aplica o filtro casado com resposta ao impuslo $h(t)$ aos sinais $d'_{I}(t)$ e $d'_{Q}(t)$.\n\n        Args:\n            dI_prime (np.ndarray): Sinal $d'_{I}(t)$ a ser filtrado.\n            dQ_prime (np.ndarray): Sinal $d'_{Q}(t)$ a ser filtrado.\n            t (np.ndarray): Vetor de tempo.\n\n        Returns:\n            It_prime (np.ndarray): Sinal $I'(t)$ filtrado.\n            Qt_prime (np.ndarray): Sinal $Q'(t)$ filtrado.\n        \"\"\"\n\n        matched_filter = MatchedFilter(alpha=0.8, fs=self.fs, Rb=self.Rb, span=6, type=\"RRC-Inverted\")\n        It_prime = matched_filter.apply_filter(dI_prime)\n        Qt_prime = matched_filter.apply_filter(dQ_prime)\n\n        if self.output_print:\n            print(\"\\n ==== FILTRAGEM CASADA ==== \\n\")\n            print(\"I'(t):\", ''.join(map(str, It_prime[:5])),\"...\")\n            print(\"Q'(t):\", ''.join(map(str, Qt_prime[:5])),\"...\")\n\n        if self.output_plot:\n            self.plotter.plot_matched_filter(\n                matched_filter.t_impulse,\n                matched_filter.impulse_response,\n                t,\n                It_prime,\n                Qt_prime,\n                \"Resposta ao Impulso - Filtro Casado\",\n                \"Canal I - Filtro Casado\",\n                \"Canal Q - Filtro Casado\",\n                \"Resposta ao Impulso - Filtro Casado\",\n                \"Canal I - Filtro Casado\",\n                \"Canal Q - Filtro Casado\",\n                0.1,\n                save_path=\"../out/receiver_matched_filter.pdf\"\n            )\n            self.plotter.plot_matched_filter_freq(\n                matched_filter.t_impulse,\n                matched_filter.impulse_response,\n                dI_prime,\n                dQ_prime,\n                It_prime,\n                Qt_prime,\n                self.fs,\n                self.fc,\n                \"Resposta ao Impulso - Filtro Casado\",\n                \"Canal I - Antes do Filtro Casado\",\n                \"Canal Q - Antes do Filtro Casado\",\n                \"Canal I - Depois do Filtro Casado\",\n                \"Canal Q - Depois do Filtro Casado\",\n                \"Resposta ao Impulso - Filtro Casado\",\n                \"Canal I - Antes do Filtro Casado\",\n                \"Canal Q - Antes do Filtro Casado\",\n                \"Canal I - Depois do Filtro Casado\",\n                \"Canal Q - Depois do Filtro Casado\",\n                save_path=\"../out/receiver_matched_filter_freq.pdf\"\n            )\n        return It_prime, Qt_prime\n\n    def sampler(self, It_prime, Qt_prime, t):\n        r\"\"\"\n        Realiza a decis\u00e3o (amostragem e quantiza\u00e7\u00e3o) dos sinais $I'(t)$ e $Q'(t)$.\n\n        Args:\n            It_prime (np.ndarray): Sinal $I'(t)$ a ser amostrado e quantizado.\n            Qt_prime (np.ndarray): Sinal $Q'(t)$ a ser amostrado e quantizado.\n            t (np.ndarray): Vetor de tempo.\n\n        Returns:\n            Xnrz_prime (np.ndarray): Sinal $X'_{NRZ}[n]$ amostrado e quantizado.\n            Yman_prime (np.ndarray): Sinal $Y'_{MAN}[n]$ amostrado e quantizado.\n        \"\"\" \n        sampler = Sampler(fs=self.fs, Rb=self.Rb, t=t)\n        i_signal_sampled = sampler.sample(It_prime)\n        q_signal_sampled = sampler.sample(Qt_prime)\n        t_sampled = sampler.sample(t)\n\n        Xnrz_prime = sampler.quantize(i_signal_sampled)\n        Yman_prime = sampler.quantize(q_signal_sampled)\n\n        if self.output_print:\n            print(\"\\n ==== DECISOR ==== \\n\")\n            print(\"X'nrz:\", ''.join(map(str, Xnrz_prime[:80])),\"...\")\n            print(\"Y'man:\", ''.join(map(str, Yman_prime[:80])),\"...\")\n\n        if self.output_plot:\n            self.plotter.plot_sampled_signals(t,\n                                 It_prime,\n                                 Qt_prime,\n                                 t_sampled,\n                                 i_signal_sampled,\n                                 q_signal_sampled,                                 \n                                 \"Amostragem\",\n                                 \"Canal I\",\n                                 \"Canal Q\",\n                                 \"Amostragem\",\n                                 \"Canal I - Amostragem\",\n                                 \"Canal Q - Amostragem\",\n                                 0.1,\n                                 save_path=\"../out/receiver_sampler.pdf\"\n            )\n        return Xnrz_prime, Yman_prime\n\n    def decode(self, Xnrz_prime, Yman_prime):\n        r\"\"\"\n        Decodifica os sinais quantizados $X'_{NRZ}[n]$ e $Y'_{MAN}[n]$.\n\n        Args:\n            Xnrz_prime (np.ndarray): Sinal $X'_{NRZ}[n]$ quantizado.\n            Yman_prime (np.ndarray): Sinal $Y'_{MAN}[n]$ quantizado.\n\n        Returns:\n            Xn_prime (np.ndarray): Sinal $X'n$ decodificado.\n            Yn_prime (np.ndarray): Sinal $Y'n$ decodificado.\n        \"\"\"\n        decoderNRZ = Encoder(\"nrz\")\n        decoderManchester = Encoder(\"manchester\")\n        i_quantized = np.array(Xnrz_prime)\n        q_quantized = np.array(Yman_prime)\n\n        Xn_prime = decoderNRZ.decode(i_quantized)\n        Yn_prime = decoderManchester.decode(q_quantized)\n\n        if self.output_print:\n            print(\"\\n ==== DECODIFICADOR DE LINHA ==== \\n\")\n            print(\"X'n:\", ''.join(map(str, Xn_prime)))\n            print(\"Y'n:\", ''.join(map(str, Yn_prime)))\n\n        return Xn_prime, Yn_prime\n\n    def remove_preamble(self, Xn_prime, Yn_prime):\n        r\"\"\"\n        Remove os 15 primeiros bits de cada sinal.\n\n        Args:\n            Xn_prime (np.ndarray): Sinal $X'n$ decodificado.\n            Yn_prime (np.ndarray): Sinal $Y'n$ decodificado.\n\n        Returns:\n            Xn_prime (np.ndarray): Sinal $X'n$ sem pre\u00e2mbulo.\n            Yn_prime (np.ndarray): Sinal $Y'n$ sem pre\u00e2mbulo.\n        \"\"\"\n        # remove the first 15 bits from each signal\n        Xn_prime = Xn_prime[15:]\n        Yn_prime = Yn_prime[15:]\n\n        if self.output_print:\n            print(\"\\n ==== REMO\u00c7\u00c3O DO PRE\u00c2MBULO ==== \\n\")\n            print(\"X'n:\", ''.join(map(str, Xn_prime)))\n            print(\"Y'n:\", ''.join(map(str, Yn_prime)))\n\n        return Xn_prime, Yn_prime\n\n    def descrambler(self, Xn_prime, Yn_prime):\n        r\"\"\"\n        Desembaralha os vetores de bits dos canais I e Q.\n\n        Args:\n            Xn_prime (np.ndarray): Vetor de bits $X'n$ embaralhados.\n            Yn_prime (np.ndarray): Vetor de bits $Y'n$ embaralhados.\n\n        Returns:\n            vt0 (np.ndarray): Vetor de bits $v_{t}^{0}'$ desembaralhado.\n            vt1 (np.ndarray): Vetor de bits $v_{t}^{1}'$ desembaralhado.\n        \"\"\"\n        descrambler = Scrambler()\n        vt0, vt1 = descrambler.descramble(Xn_prime, Yn_prime)\n\n        if self.output_print:\n            print(\"\\n ==== DESEMBARALHADOR ==== \\n\")\n            print(\"vt0':\", ''.join(map(str, vt0)))\n            print(\"vt1':\", ''.join(map(str, vt1)))\n\n        return vt0, vt1\n\n    def conv_decoder(self, vt0, vt1):\n        r\"\"\"\n        Decodifica os vetores de bits dos canais I e Q.\n\n        Args:\n            vt0 (np.ndarray): Vetor de bits $v_{t}^{0}'$ desembaralhado.\n            vt1 (np.ndarray): Vetor de bits $v_{t}^{1}'$ desembaralhado.\n\n        Returns:\n            ut (np.ndarray): Vetor de bits $u_{t}'$ decodificado.\n        \"\"\"\n        conv_decoder = DecoderViterbi()\n        ut = conv_decoder.decode(vt0, vt1)\n\n        if self.output_print:\n            print(\"\\n ==== DECODIFICADOR VITERBI ==== \\n\")\n            print(\"u't:\", ''.join(map(str, ut)))\n\n        return ut\n\n    def run(self, s, t, fc=4000):\n        r\"\"\"\n        Executa o processo de recep\u00e7\u00e3o, retornando o resultado da recep\u00e7\u00e3o.\n\n        Args:\n            s (np.ndarray): Sinal $s(t)$ recebido.\n            t (np.ndarray): Vetor de tempo.\n            fc (float): Frequ\u00eancia de portadora.\n\n        Returns:\n            ut (np.ndarray): Vetor de bits $u_{t}'$ decodificado.\n        \"\"\"\n\n        # TODO: Adicionar detec\u00e7\u00e3o de portadora;\n        self.fc = fc\n\n        xI_prime, yQ_prime = self.demodulate(s)\n        dI_prime, dQ_prime= self.lowpassfilter(self.fc*0.6, xI_prime, yQ_prime, t)\n        It_prime, Qt_prime = self.matchedfilter(dI_prime, dQ_prime, t)\n        Xnrz_prime, Yman_prime = self.sampler(It_prime, Qt_prime, t)\n        Xn_prime, Yn_prime = self.decode(Xnrz_prime, Yman_prime)\n        Xn_prime, Yn_prime = self.remove_preamble(Xn_prime, Yn_prime)\n        vt0, vt1 = self.descrambler(Xn_prime, Yn_prime)\n        ut = self.conv_decoder(vt0, vt1)\n        return ut \n</code></pre>"},{"location":"api/receiver/#receiver.Receiver.__init__","title":"<code>__init__(fs=128000, Rb=400, output_print=True, output_plot=True)</code>","text":"<p>Classe que encapsula todo o processo de recep\u00e7\u00e3o, desde o recebimento do sinal com ru\u00eddo (sinal do canal), at\u00e9 a recupera\u00e7\u00e3o do vetor de bit.</p> <p>Parameters:</p> Name Type Description Default <code>fs</code> <code>int</code> <p>Frequ\u00eancia de amostragem em Hz. Default \u00e9 128000 Hz.</p> <code>128000</code> <code>Rb</code> <code>int</code> <p>Taxa de bits em bps. Default \u00e9 400 bps.</p> <code>400</code> <code>output_print</code> <code>bool</code> <p>Se True, imprime os vetores intermedi\u00e1rios no console. Default \u00e9 True.</p> <code>True</code> <code>output_plot</code> <code>bool</code> <p>Se True, gera e salva os gr\u00e1ficos dos processos intermedi\u00e1rios. Default \u00e9 True.</p> <code>True</code> Source code in <code>src/receiver.py</code> <pre><code>def __init__(self, fs=128_000, Rb=400, output_print=True, output_plot=True):\n    r\"\"\"\n    Classe que encapsula todo o processo de recep\u00e7\u00e3o, desde o recebimento do sinal com ru\u00eddo (sinal do canal), at\u00e9 a recupera\u00e7\u00e3o do vetor de bit.\n\n    Args:\n        fs (int): Frequ\u00eancia de amostragem em Hz. Default \u00e9 128000 Hz.\n        Rb (int): Taxa de bits em bps. Default \u00e9 400 bps.\n        output_print (bool): Se True, imprime os vetores intermedi\u00e1rios no console. Default \u00e9 True.\n        output_plot (bool): Se True, gera e salva os gr\u00e1ficos dos processos intermedi\u00e1rios. Default \u00e9 True.\n    \"\"\"\n    self.fs = fs\n    self.Rb = Rb\n    self.output_print = output_print\n    self.output_plot = output_plot\n    self.plotter = Plotter()\n</code></pre>"},{"location":"api/receiver/#receiver.Receiver.demodulate","title":"<code>demodulate(s)</code>","text":"<p>Demodula o sinal \\(s'(t)\\) com ru\u00eddo recebido, recuperando os sinais \\(x'_{I}(t)\\) e \\(y'_{Q}(t)\\).</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>ndarray</code> <p>Sinal \\(s'(t)\\) a ser demodulado.</p> required <p>Returns:</p> Name Type Description <code>xI_prime</code> <code>ndarray</code> <p>Sinal \\(x'_{I}(t)\\) demodulado.</p> <code>yQ_prime</code> <code>ndarray</code> <p>Sinal \\(y'_{Q}(t)\\) demodulado.</p> Source code in <code>src/receiver.py</code> <pre><code>def demodulate(self, s):\n    r\"\"\"\n    Demodula o sinal $s'(t)$ com ru\u00eddo recebido, recuperando os sinais $x'_{I}(t)$ e $y'_{Q}(t)$.\n\n    Args:\n        s (np.ndarray): Sinal $s'(t)$ a ser demodulado.\n\n    Returns:\n        xI_prime (np.ndarray): Sinal $x'_{I}(t)$ demodulado.\n        yQ_prime (np.ndarray): Sinal $y'_{Q}(t)$ demodulado.\n    \"\"\"\n    demodulator = Modulator(fc=self.fc, fs=self.fs)\n    xI_prime, yQ_prime = demodulator.demodulate(s)\n\n    if self.output_print:\n        print(\"\\n ==== DEMODULADOR ==== \\n\")\n        print(\"x'I(t):\", ''.join(map(str, xI_prime[:5])),\"...\")\n        print(\"y'Q(t):\", ''.join(map(str, yQ_prime[:5])),\"...\")\n    if self.output_plot:\n        self.plotter.plot_freq_receiver(\n            xI_prime,\n            yQ_prime,\n            self.fs,\n            self.fc,\n            save_path=\"../out/receiver_freq.pdf\"\n        )\n    return xI_prime, yQ_prime\n</code></pre>"},{"location":"api/receiver/#receiver.Receiver.lowpassfilter","title":"<code>lowpassfilter(cut_off, xI_prime, yQ_prime, t)</code>","text":"<p>Aplica o filtro passa-baixa com resposta ao impuslo \\(h(t)\\) aos sinais \\(x'_{I}(t)\\) e \\(y'_{Q}(t)\\).</p> <p>Parameters:</p> Name Type Description Default <code>cut_off</code> <code>float</code> <p>Frequ\u00eancia de corte do filtro.</p> required <code>xI_prime</code> <code>ndarray</code> <p>Sinal \\(x'_{I}(t)\\) a ser filtrado.</p> required <code>yQ_prime</code> <code>ndarray</code> <p>Sinal \\(y'_{Q}(t)\\) a ser filtrado.</p> required <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> required <p>Returns:</p> Name Type Description <code>dI_prime</code> <code>ndarray</code> <p>Sinal \\(d'_{I}(t)\\) filtrado.</p> <code>dQ_prime</code> <code>ndarray</code> <p>Sinal \\(d'_{Q}(t)\\) filtrado.</p> Source code in <code>src/receiver.py</code> <pre><code>def lowpassfilter(self, cut_off, xI_prime, yQ_prime, t):\n    r\"\"\"\n    Aplica o filtro passa-baixa com resposta ao impuslo $h(t)$ aos sinais $x'_{I}(t)$ e $y'_{Q}(t)$.\n\n    Args:\n        cut_off (float): Frequ\u00eancia de corte do filtro.\n        xI_prime (np.ndarray): Sinal $x'_{I}(t)$ a ser filtrado.\n        yQ_prime (np.ndarray): Sinal $y'_{Q}(t)$ a ser filtrado.\n        t (np.ndarray): Vetor de tempo.\n\n    Returns:\n        dI_prime (np.ndarray): Sinal $d'_{I}(t)$ filtrado.\n        dQ_prime (np.ndarray): Sinal $d'_{Q}(t)$ filtrado.\n    \"\"\"\n\n    lpf = LPF(cut_off=cut_off, order=6, fs=self.fs, type=\"butter\")\n    impulse_response, t_impulse = lpf.calc_impulse_response()\n    dI_prime = lpf.apply_filter(xI_prime)\n    dQ_prime = lpf.apply_filter(yQ_prime)\n\n    if self.output_print:\n        print(\"\\n ==== FILTRAGEM PASSA-BAIXA ==== \\n\")\n        print(\"d'I(t):\", ''.join(map(str, dI_prime[:5])),\"...\")\n        print(\"d'Q(t):\", ''.join(map(str, dQ_prime[:5])),\"...\")\n\n    if self.output_plot:\n        self.plotter.plot_lowpass_filter(\n            t_impulse,\n            impulse_response,\n            t,\n            dI_prime,\n            dQ_prime,\n            save_path=\"../out/receiver_lowpass_filter.pdf\"\n        )\n        self.plotter.plot_lowpass_freq(\n            t_impulse,\n            impulse_response,\n            xI_prime,\n            yQ_prime,\n            dI_prime,\n            dQ_prime,\n            self.fs,\n            self.fc,\n            save_path=\"../out/receiver_lowpass_freq.pdf\"\n        )\n\n    return dI_prime, dQ_prime\n</code></pre>"},{"location":"api/receiver/#receiver.Receiver.matchedfilter","title":"<code>matchedfilter(dI_prime, dQ_prime, t)</code>","text":"<p>Aplica o filtro casado com resposta ao impuslo \\(h(t)\\) aos sinais \\(d'_{I}(t)\\) e \\(d'_{Q}(t)\\).</p> <p>Parameters:</p> Name Type Description Default <code>dI_prime</code> <code>ndarray</code> <p>Sinal \\(d'_{I}(t)\\) a ser filtrado.</p> required <code>dQ_prime</code> <code>ndarray</code> <p>Sinal \\(d'_{Q}(t)\\) a ser filtrado.</p> required <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> required <p>Returns:</p> Name Type Description <code>It_prime</code> <code>ndarray</code> <p>Sinal \\(I'(t)\\) filtrado.</p> <code>Qt_prime</code> <code>ndarray</code> <p>Sinal \\(Q'(t)\\) filtrado.</p> Source code in <code>src/receiver.py</code> <pre><code>def matchedfilter(self, dI_prime, dQ_prime, t):\n    r\"\"\"\n    Aplica o filtro casado com resposta ao impuslo $h(t)$ aos sinais $d'_{I}(t)$ e $d'_{Q}(t)$.\n\n    Args:\n        dI_prime (np.ndarray): Sinal $d'_{I}(t)$ a ser filtrado.\n        dQ_prime (np.ndarray): Sinal $d'_{Q}(t)$ a ser filtrado.\n        t (np.ndarray): Vetor de tempo.\n\n    Returns:\n        It_prime (np.ndarray): Sinal $I'(t)$ filtrado.\n        Qt_prime (np.ndarray): Sinal $Q'(t)$ filtrado.\n    \"\"\"\n\n    matched_filter = MatchedFilter(alpha=0.8, fs=self.fs, Rb=self.Rb, span=6, type=\"RRC-Inverted\")\n    It_prime = matched_filter.apply_filter(dI_prime)\n    Qt_prime = matched_filter.apply_filter(dQ_prime)\n\n    if self.output_print:\n        print(\"\\n ==== FILTRAGEM CASADA ==== \\n\")\n        print(\"I'(t):\", ''.join(map(str, It_prime[:5])),\"...\")\n        print(\"Q'(t):\", ''.join(map(str, Qt_prime[:5])),\"...\")\n\n    if self.output_plot:\n        self.plotter.plot_matched_filter(\n            matched_filter.t_impulse,\n            matched_filter.impulse_response,\n            t,\n            It_prime,\n            Qt_prime,\n            \"Resposta ao Impulso - Filtro Casado\",\n            \"Canal I - Filtro Casado\",\n            \"Canal Q - Filtro Casado\",\n            \"Resposta ao Impulso - Filtro Casado\",\n            \"Canal I - Filtro Casado\",\n            \"Canal Q - Filtro Casado\",\n            0.1,\n            save_path=\"../out/receiver_matched_filter.pdf\"\n        )\n        self.plotter.plot_matched_filter_freq(\n            matched_filter.t_impulse,\n            matched_filter.impulse_response,\n            dI_prime,\n            dQ_prime,\n            It_prime,\n            Qt_prime,\n            self.fs,\n            self.fc,\n            \"Resposta ao Impulso - Filtro Casado\",\n            \"Canal I - Antes do Filtro Casado\",\n            \"Canal Q - Antes do Filtro Casado\",\n            \"Canal I - Depois do Filtro Casado\",\n            \"Canal Q - Depois do Filtro Casado\",\n            \"Resposta ao Impulso - Filtro Casado\",\n            \"Canal I - Antes do Filtro Casado\",\n            \"Canal Q - Antes do Filtro Casado\",\n            \"Canal I - Depois do Filtro Casado\",\n            \"Canal Q - Depois do Filtro Casado\",\n            save_path=\"../out/receiver_matched_filter_freq.pdf\"\n        )\n    return It_prime, Qt_prime\n</code></pre>"},{"location":"api/receiver/#receiver.Receiver.sampler","title":"<code>sampler(It_prime, Qt_prime, t)</code>","text":"<p>Realiza a decis\u00e3o (amostragem e quantiza\u00e7\u00e3o) dos sinais \\(I'(t)\\) e \\(Q'(t)\\).</p> <p>Parameters:</p> Name Type Description Default <code>It_prime</code> <code>ndarray</code> <p>Sinal \\(I'(t)\\) a ser amostrado e quantizado.</p> required <code>Qt_prime</code> <code>ndarray</code> <p>Sinal \\(Q'(t)\\) a ser amostrado e quantizado.</p> required <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> required <p>Returns:</p> Name Type Description <code>Xnrz_prime</code> <code>ndarray</code> <p>Sinal \\(X'_{NRZ}[n]\\) amostrado e quantizado.</p> <code>Yman_prime</code> <code>ndarray</code> <p>Sinal \\(Y'_{MAN}[n]\\) amostrado e quantizado.</p> Source code in <code>src/receiver.py</code> <pre><code>def sampler(self, It_prime, Qt_prime, t):\n    r\"\"\"\n    Realiza a decis\u00e3o (amostragem e quantiza\u00e7\u00e3o) dos sinais $I'(t)$ e $Q'(t)$.\n\n    Args:\n        It_prime (np.ndarray): Sinal $I'(t)$ a ser amostrado e quantizado.\n        Qt_prime (np.ndarray): Sinal $Q'(t)$ a ser amostrado e quantizado.\n        t (np.ndarray): Vetor de tempo.\n\n    Returns:\n        Xnrz_prime (np.ndarray): Sinal $X'_{NRZ}[n]$ amostrado e quantizado.\n        Yman_prime (np.ndarray): Sinal $Y'_{MAN}[n]$ amostrado e quantizado.\n    \"\"\" \n    sampler = Sampler(fs=self.fs, Rb=self.Rb, t=t)\n    i_signal_sampled = sampler.sample(It_prime)\n    q_signal_sampled = sampler.sample(Qt_prime)\n    t_sampled = sampler.sample(t)\n\n    Xnrz_prime = sampler.quantize(i_signal_sampled)\n    Yman_prime = sampler.quantize(q_signal_sampled)\n\n    if self.output_print:\n        print(\"\\n ==== DECISOR ==== \\n\")\n        print(\"X'nrz:\", ''.join(map(str, Xnrz_prime[:80])),\"...\")\n        print(\"Y'man:\", ''.join(map(str, Yman_prime[:80])),\"...\")\n\n    if self.output_plot:\n        self.plotter.plot_sampled_signals(t,\n                             It_prime,\n                             Qt_prime,\n                             t_sampled,\n                             i_signal_sampled,\n                             q_signal_sampled,                                 \n                             \"Amostragem\",\n                             \"Canal I\",\n                             \"Canal Q\",\n                             \"Amostragem\",\n                             \"Canal I - Amostragem\",\n                             \"Canal Q - Amostragem\",\n                             0.1,\n                             save_path=\"../out/receiver_sampler.pdf\"\n        )\n    return Xnrz_prime, Yman_prime\n</code></pre>"},{"location":"api/receiver/#receiver.Receiver.decode","title":"<code>decode(Xnrz_prime, Yman_prime)</code>","text":"<p>Decodifica os sinais quantizados \\(X'_{NRZ}[n]\\) e \\(Y'_{MAN}[n]\\).</p> <p>Parameters:</p> Name Type Description Default <code>Xnrz_prime</code> <code>ndarray</code> <p>Sinal \\(X'_{NRZ}[n]\\) quantizado.</p> required <code>Yman_prime</code> <code>ndarray</code> <p>Sinal \\(Y'_{MAN}[n]\\) quantizado.</p> required <p>Returns:</p> Name Type Description <code>Xn_prime</code> <code>ndarray</code> <p>Sinal \\(X'n\\) decodificado.</p> <code>Yn_prime</code> <code>ndarray</code> <p>Sinal \\(Y'n\\) decodificado.</p> Source code in <code>src/receiver.py</code> <pre><code>def decode(self, Xnrz_prime, Yman_prime):\n    r\"\"\"\n    Decodifica os sinais quantizados $X'_{NRZ}[n]$ e $Y'_{MAN}[n]$.\n\n    Args:\n        Xnrz_prime (np.ndarray): Sinal $X'_{NRZ}[n]$ quantizado.\n        Yman_prime (np.ndarray): Sinal $Y'_{MAN}[n]$ quantizado.\n\n    Returns:\n        Xn_prime (np.ndarray): Sinal $X'n$ decodificado.\n        Yn_prime (np.ndarray): Sinal $Y'n$ decodificado.\n    \"\"\"\n    decoderNRZ = Encoder(\"nrz\")\n    decoderManchester = Encoder(\"manchester\")\n    i_quantized = np.array(Xnrz_prime)\n    q_quantized = np.array(Yman_prime)\n\n    Xn_prime = decoderNRZ.decode(i_quantized)\n    Yn_prime = decoderManchester.decode(q_quantized)\n\n    if self.output_print:\n        print(\"\\n ==== DECODIFICADOR DE LINHA ==== \\n\")\n        print(\"X'n:\", ''.join(map(str, Xn_prime)))\n        print(\"Y'n:\", ''.join(map(str, Yn_prime)))\n\n    return Xn_prime, Yn_prime\n</code></pre>"},{"location":"api/receiver/#receiver.Receiver.remove_preamble","title":"<code>remove_preamble(Xn_prime, Yn_prime)</code>","text":"<p>Remove os 15 primeiros bits de cada sinal.</p> <p>Parameters:</p> Name Type Description Default <code>Xn_prime</code> <code>ndarray</code> <p>Sinal \\(X'n\\) decodificado.</p> required <code>Yn_prime</code> <code>ndarray</code> <p>Sinal \\(Y'n\\) decodificado.</p> required <p>Returns:</p> Name Type Description <code>Xn_prime</code> <code>ndarray</code> <p>Sinal \\(X'n\\) sem pre\u00e2mbulo.</p> <code>Yn_prime</code> <code>ndarray</code> <p>Sinal \\(Y'n\\) sem pre\u00e2mbulo.</p> Source code in <code>src/receiver.py</code> <pre><code>def remove_preamble(self, Xn_prime, Yn_prime):\n    r\"\"\"\n    Remove os 15 primeiros bits de cada sinal.\n\n    Args:\n        Xn_prime (np.ndarray): Sinal $X'n$ decodificado.\n        Yn_prime (np.ndarray): Sinal $Y'n$ decodificado.\n\n    Returns:\n        Xn_prime (np.ndarray): Sinal $X'n$ sem pre\u00e2mbulo.\n        Yn_prime (np.ndarray): Sinal $Y'n$ sem pre\u00e2mbulo.\n    \"\"\"\n    # remove the first 15 bits from each signal\n    Xn_prime = Xn_prime[15:]\n    Yn_prime = Yn_prime[15:]\n\n    if self.output_print:\n        print(\"\\n ==== REMO\u00c7\u00c3O DO PRE\u00c2MBULO ==== \\n\")\n        print(\"X'n:\", ''.join(map(str, Xn_prime)))\n        print(\"Y'n:\", ''.join(map(str, Yn_prime)))\n\n    return Xn_prime, Yn_prime\n</code></pre>"},{"location":"api/receiver/#receiver.Receiver.descrambler","title":"<code>descrambler(Xn_prime, Yn_prime)</code>","text":"<p>Desembaralha os vetores de bits dos canais I e Q.</p> <p>Parameters:</p> Name Type Description Default <code>Xn_prime</code> <code>ndarray</code> <p>Vetor de bits \\(X'n\\) embaralhados.</p> required <code>Yn_prime</code> <code>ndarray</code> <p>Vetor de bits \\(Y'n\\) embaralhados.</p> required <p>Returns:</p> Name Type Description <code>vt0</code> <code>ndarray</code> <p>Vetor de bits \\(v_{t}^{0}'\\) desembaralhado.</p> <code>vt1</code> <code>ndarray</code> <p>Vetor de bits \\(v_{t}^{1}'\\) desembaralhado.</p> Source code in <code>src/receiver.py</code> <pre><code>def descrambler(self, Xn_prime, Yn_prime):\n    r\"\"\"\n    Desembaralha os vetores de bits dos canais I e Q.\n\n    Args:\n        Xn_prime (np.ndarray): Vetor de bits $X'n$ embaralhados.\n        Yn_prime (np.ndarray): Vetor de bits $Y'n$ embaralhados.\n\n    Returns:\n        vt0 (np.ndarray): Vetor de bits $v_{t}^{0}'$ desembaralhado.\n        vt1 (np.ndarray): Vetor de bits $v_{t}^{1}'$ desembaralhado.\n    \"\"\"\n    descrambler = Scrambler()\n    vt0, vt1 = descrambler.descramble(Xn_prime, Yn_prime)\n\n    if self.output_print:\n        print(\"\\n ==== DESEMBARALHADOR ==== \\n\")\n        print(\"vt0':\", ''.join(map(str, vt0)))\n        print(\"vt1':\", ''.join(map(str, vt1)))\n\n    return vt0, vt1\n</code></pre>"},{"location":"api/receiver/#receiver.Receiver.conv_decoder","title":"<code>conv_decoder(vt0, vt1)</code>","text":"<p>Decodifica os vetores de bits dos canais I e Q.</p> <p>Parameters:</p> Name Type Description Default <code>vt0</code> <code>ndarray</code> <p>Vetor de bits \\(v_{t}^{0}'\\) desembaralhado.</p> required <code>vt1</code> <code>ndarray</code> <p>Vetor de bits \\(v_{t}^{1}'\\) desembaralhado.</p> required <p>Returns:</p> Name Type Description <code>ut</code> <code>ndarray</code> <p>Vetor de bits \\(u_{t}'\\) decodificado.</p> Source code in <code>src/receiver.py</code> <pre><code>def conv_decoder(self, vt0, vt1):\n    r\"\"\"\n    Decodifica os vetores de bits dos canais I e Q.\n\n    Args:\n        vt0 (np.ndarray): Vetor de bits $v_{t}^{0}'$ desembaralhado.\n        vt1 (np.ndarray): Vetor de bits $v_{t}^{1}'$ desembaralhado.\n\n    Returns:\n        ut (np.ndarray): Vetor de bits $u_{t}'$ decodificado.\n    \"\"\"\n    conv_decoder = DecoderViterbi()\n    ut = conv_decoder.decode(vt0, vt1)\n\n    if self.output_print:\n        print(\"\\n ==== DECODIFICADOR VITERBI ==== \\n\")\n        print(\"u't:\", ''.join(map(str, ut)))\n\n    return ut\n</code></pre>"},{"location":"api/receiver/#receiver.Receiver.run","title":"<code>run(s, t, fc=4000)</code>","text":"<p>Executa o processo de recep\u00e7\u00e3o, retornando o resultado da recep\u00e7\u00e3o.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>ndarray</code> <p>Sinal \\(s(t)\\) recebido.</p> required <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> required <code>fc</code> <code>float</code> <p>Frequ\u00eancia de portadora.</p> <code>4000</code> <p>Returns:</p> Name Type Description <code>ut</code> <code>ndarray</code> <p>Vetor de bits \\(u_{t}'\\) decodificado.</p> Source code in <code>src/receiver.py</code> <pre><code>def run(self, s, t, fc=4000):\n    r\"\"\"\n    Executa o processo de recep\u00e7\u00e3o, retornando o resultado da recep\u00e7\u00e3o.\n\n    Args:\n        s (np.ndarray): Sinal $s(t)$ recebido.\n        t (np.ndarray): Vetor de tempo.\n        fc (float): Frequ\u00eancia de portadora.\n\n    Returns:\n        ut (np.ndarray): Vetor de bits $u_{t}'$ decodificado.\n    \"\"\"\n\n    # TODO: Adicionar detec\u00e7\u00e3o de portadora;\n    self.fc = fc\n\n    xI_prime, yQ_prime = self.demodulate(s)\n    dI_prime, dQ_prime= self.lowpassfilter(self.fc*0.6, xI_prime, yQ_prime, t)\n    It_prime, Qt_prime = self.matchedfilter(dI_prime, dQ_prime, t)\n    Xnrz_prime, Yman_prime = self.sampler(It_prime, Qt_prime, t)\n    Xn_prime, Yn_prime = self.decode(Xnrz_prime, Yman_prime)\n    Xn_prime, Yn_prime = self.remove_preamble(Xn_prime, Yn_prime)\n    vt0, vt1 = self.descrambler(Xn_prime, Yn_prime)\n    ut = self.conv_decoder(vt0, vt1)\n    return ut \n</code></pre>"},{"location":"api/sampler/","title":"Decisor","text":"Source code in <code>src/sampler.py</code> <pre><code>class Sampler:\n    def __init__(self, fs=128_000, Rb=400, t=None, output_print=True, output_plot=True):\n        r\"\"\"\n        Implementa\u00e7\u00e3o de decisor (amostragem e quantiza\u00e7\u00e3o) para o receptor.\n\n        Args: \n            fs (int): Frequ\u00eancia de amostragem.\n            Rb (int): Taxa de bits.\n            t (numpy.ndarray): Vetor de tempo.\n            output_print (bool): Se True, imprime a sa\u00edda.\n            output_plot (bool): Se True, plota a sa\u00edda.\n        \"\"\"\n        self.fs = fs\n        self.Rb = Rb\n        self.sps = int(self.fs / self.Rb)\n        self.output_print = output_print\n        self.output_plot = output_plot\n        self.plotter = Plotter()\n        self.delay = 0\n        self.indexes = self.calc_indexes(t)\n\n    def calc_indexes(self, t):\n        r\"\"\"\n        Calcula os \u00edndices de amostragem com base no vetor de tempo.\n\n        Args:\n            t (numpy.ndarray): Vetor de tempo.\n\n        Returns:\n            numpy.ndarray: \u00cdndices de amostragem.\n        \"\"\"\n        indexes = np.arange(self.delay, len(t), self.sps)\n        indexes = indexes[indexes &lt; len(t)]\n        return indexes\n\n    def sample(self, signal):\n        r\"\"\"\n        Amostra o sinal com base nos \u00edndices de amostragem.\n\n        Args:\n            signal (numpy.ndarray): Sinal a ser amostrado.\n\n        Returns:\n            numpy.ndarray: Sinal amostrado.\n        \"\"\"\n        sampled_signal = signal[self.indexes]\n        return sampled_signal\n\n    def quantize(self, signal):\n        r\"\"\"\n        Quantiza o sinal em uma representa\u00e7\u00e3o bin\u00e1ria.\n\n        Args:\n            signal (numpy.ndarray): Sinal a ser quantizado.\n\n        Returns:\n            list: Representa\u00e7\u00e3o bin\u00e1ria do sinal quantizado.\n        \"\"\"\n        bits = []\n        for i in range(len(signal)):\n            if signal[i] &gt; 0:\n                bits.append(1)\n            else:\n                bits.append(0)\n        return bits\n</code></pre>"},{"location":"api/sampler/#sampler.Sampler.__init__","title":"<code>__init__(fs=128000, Rb=400, t=None, output_print=True, output_plot=True)</code>","text":"<p>Implementa\u00e7\u00e3o de decisor (amostragem e quantiza\u00e7\u00e3o) para o receptor.</p> <p>Parameters:</p> Name Type Description Default <code>fs</code> <code>int</code> <p>Frequ\u00eancia de amostragem.</p> <code>128000</code> <code>Rb</code> <code>int</code> <p>Taxa de bits.</p> <code>400</code> <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> <code>None</code> <code>output_print</code> <code>bool</code> <p>Se True, imprime a sa\u00edda.</p> <code>True</code> <code>output_plot</code> <code>bool</code> <p>Se True, plota a sa\u00edda.</p> <code>True</code> Source code in <code>src/sampler.py</code> <pre><code>def __init__(self, fs=128_000, Rb=400, t=None, output_print=True, output_plot=True):\n    r\"\"\"\n    Implementa\u00e7\u00e3o de decisor (amostragem e quantiza\u00e7\u00e3o) para o receptor.\n\n    Args: \n        fs (int): Frequ\u00eancia de amostragem.\n        Rb (int): Taxa de bits.\n        t (numpy.ndarray): Vetor de tempo.\n        output_print (bool): Se True, imprime a sa\u00edda.\n        output_plot (bool): Se True, plota a sa\u00edda.\n    \"\"\"\n    self.fs = fs\n    self.Rb = Rb\n    self.sps = int(self.fs / self.Rb)\n    self.output_print = output_print\n    self.output_plot = output_plot\n    self.plotter = Plotter()\n    self.delay = 0\n    self.indexes = self.calc_indexes(t)\n</code></pre>"},{"location":"api/sampler/#sampler.Sampler.calc_indexes","title":"<code>calc_indexes(t)</code>","text":"<p>Calcula os \u00edndices de amostragem com base no vetor de tempo.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> required <p>Returns:</p> Type Description <p>numpy.ndarray: \u00cdndices de amostragem.</p> Source code in <code>src/sampler.py</code> <pre><code>def calc_indexes(self, t):\n    r\"\"\"\n    Calcula os \u00edndices de amostragem com base no vetor de tempo.\n\n    Args:\n        t (numpy.ndarray): Vetor de tempo.\n\n    Returns:\n        numpy.ndarray: \u00cdndices de amostragem.\n    \"\"\"\n    indexes = np.arange(self.delay, len(t), self.sps)\n    indexes = indexes[indexes &lt; len(t)]\n    return indexes\n</code></pre>"},{"location":"api/sampler/#sampler.Sampler.sample","title":"<code>sample(signal)</code>","text":"<p>Amostra o sinal com base nos \u00edndices de amostragem.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>ndarray</code> <p>Sinal a ser amostrado.</p> required <p>Returns:</p> Type Description <p>numpy.ndarray: Sinal amostrado.</p> Source code in <code>src/sampler.py</code> <pre><code>def sample(self, signal):\n    r\"\"\"\n    Amostra o sinal com base nos \u00edndices de amostragem.\n\n    Args:\n        signal (numpy.ndarray): Sinal a ser amostrado.\n\n    Returns:\n        numpy.ndarray: Sinal amostrado.\n    \"\"\"\n    sampled_signal = signal[self.indexes]\n    return sampled_signal\n</code></pre>"},{"location":"api/sampler/#sampler.Sampler.quantize","title":"<code>quantize(signal)</code>","text":"<p>Quantiza o sinal em uma representa\u00e7\u00e3o bin\u00e1ria.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>ndarray</code> <p>Sinal a ser quantizado.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Representa\u00e7\u00e3o bin\u00e1ria do sinal quantizado.</p> Source code in <code>src/sampler.py</code> <pre><code>def quantize(self, signal):\n    r\"\"\"\n    Quantiza o sinal em uma representa\u00e7\u00e3o bin\u00e1ria.\n\n    Args:\n        signal (numpy.ndarray): Sinal a ser quantizado.\n\n    Returns:\n        list: Representa\u00e7\u00e3o bin\u00e1ria do sinal quantizado.\n    \"\"\"\n    bits = []\n    for i in range(len(signal)):\n        if signal[i] &gt; 0:\n            bits.append(1)\n        else:\n            bits.append(0)\n    return bits\n</code></pre>"},{"location":"api/scrambler/","title":"Scrambler","text":"<p>O processo de embaralhamento pode ser expresso como:</p> \\[ X_n = \\begin{cases} A, &amp; \\text{se } n \\equiv 0 \\pmod{3} \\\\\\\\ B, &amp; \\text{se } n \\equiv 1 \\pmod{3} \\\\\\\\ C, &amp; \\text{se } n \\equiv 2 \\pmod{3} \\end{cases}, \\quad Y_n = \\begin{cases} A, &amp; \\text{se } n \\equiv 0 \\pmod{3} \\\\\\\\ B, &amp; \\text{se } n \\equiv 1 \\pmod{3} \\\\\\\\ C, &amp; \\text{se } n \\equiv 2 \\pmod{3} \\end{cases} \\] Source code in <code>src/scrambler.py</code> <pre><code>class Scrambler:\n    def __init__(self):\n        r\"\"\"\n        Implementa\u00e7\u00e3o do embaralhador e desembaralhador compat\u00edvel com o padr\u00e3o PPT-A3.\n        \"\"\"\n        pass\n\n    def scramble(self, X, Y):\n        r\"\"\"\n        Embaralha os vetores X e Y de mesmo comprimento, retornando os vetores embaralhados.\n\n        Args:\n            X (np.ndarray): Vetor de entrada $v_t^{(0)}$.\n            Y (np.ndarray): Vetor de entrada $v_t^{(1)}$.\n\n        Returns:\n            X_scrambled (np.ndarray): Vetor $X_n$ embaralhado.\n            Y_scrambled (np.ndarray): Vetor $Y_n$ embaralhado.\n\n        Raises:\n            AssertionError: Se os vetores X e Y n\u00e3o tiverem o mesmo comprimento.\n        \"\"\"\n        assert len(X) == len(Y), \"Vetores X e Y devem ter o mesmo comprimento\"\n        X_scrambled = []\n        Y_scrambled = []\n\n        for i in range(0, len(X), 3):\n            x_blk = X[i:i+3]\n            y_blk = Y[i:i+3]\n            n = len(x_blk)\n\n            if n == 3:\n                # Embaralhamento do bloco [x1, x2, x3], [y1, y2, y3]\n                x1, x2, x3 = x_blk\n                y1, y2, y3 = y_blk\n                X_scrambled += [y1, x2, y2]\n                Y_scrambled += [x1, x3, y3]\n            elif n == 2:\n                # Embaralhamento do bloco [x1, x2], [y1, y2]\n                x1, x2 = x_blk\n                y1, y2 = y_blk\n                X_scrambled += [y1, x2]\n                Y_scrambled += [x1, y2]\n            elif n == 1:\n                # Embaralhamento do bloco [x1], [y1]\n                x1 = x_blk[0]\n                y1 = y_blk[0]\n                X_scrambled += [y1]\n                Y_scrambled += [x1]\n\n        return X_scrambled, Y_scrambled\n\n    def descramble(self, X, Y):\n        r\"\"\"\n        Restaura os vetores X e Y embaralhados ao seu estado original.\n\n        Args:\n            X (np.ndarray): Vetor $X'_{n}$ embaralhado.\n            Y (np.ndarray): Vetor $Y'_{n}$ embaralhado.\n\n        Returns:\n           msg_length (np.ndarray): Vetor de 4 bits representando o campo Message Length.\n\n        Returns:\n            X_original (np.ndarray): Vetor $v_t^{(0)}$ restaurado.\n            Y_original (np.ndarray): Vetor $v_t^{(1)}$ restaurado.\n\n        Raises:\n            AssertionError: Se os vetores X e Y n\u00e3o tiverem o mesmo comprimento.\n        \"\"\"\n        assert len(X) == len(Y), \"Vetores X e Y devem ter o mesmo comprimento\"\n        X_original = []\n        Y_original = []\n\n        for i in range(0, len(X), 3):\n            x_blk = X[i:i+3]\n            y_blk = Y[i:i+3]\n            n = len(x_blk)\n\n            if n == 3:\n                # Desembaralhamento do bloco [y1, x2, y2], [x1, x3, y3]\n                x1, x2, x3 = y_blk[0], x_blk[1], y_blk[1]\n                y1, y2, y3 = x_blk[0], x_blk[2], y_blk[2]\n                X_original.extend([x1, x2, x3])\n                Y_original.extend([y1, y2, y3])\n            elif n == 2:\n                # Desembaralhamento do bloco [y1, x2], [x1, y2]\n                x1, x2 = y_blk[0], x_blk[1]\n                y1, y2 = x_blk[0], y_blk[1]\n                X_original.extend([x1, x2])\n                Y_original.extend([y1, y2])\n            elif n == 1:\n                # Desembaralhamento do bloco [y1], [x1]\n                x1 = y_blk[0]\n                y1 = x_blk[0]\n                X_original.append(x1)\n                Y_original.append(y1)\n\n        return X_original, Y_original\n</code></pre>"},{"location":"api/scrambler/#scrambler.Scrambler.__init__","title":"<code>__init__()</code>","text":"<p>Implementa\u00e7\u00e3o do embaralhador e desembaralhador compat\u00edvel com o padr\u00e3o PPT-A3.</p> Source code in <code>src/scrambler.py</code> <pre><code>def __init__(self):\n    r\"\"\"\n    Implementa\u00e7\u00e3o do embaralhador e desembaralhador compat\u00edvel com o padr\u00e3o PPT-A3.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/scrambler/#scrambler.Scrambler.scramble","title":"<code>scramble(X, Y)</code>","text":"<p>Embaralha os vetores X e Y de mesmo comprimento, retornando os vetores embaralhados.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Vetor de entrada \\(v_t^{(0)}\\).</p> required <code>Y</code> <code>ndarray</code> <p>Vetor de entrada \\(v_t^{(1)}\\).</p> required <p>Returns:</p> Name Type Description <code>X_scrambled</code> <code>ndarray</code> <p>Vetor \\(X_n\\) embaralhado.</p> <code>Y_scrambled</code> <code>ndarray</code> <p>Vetor \\(Y_n\\) embaralhado.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>Se os vetores X e Y n\u00e3o tiverem o mesmo comprimento.</p> Source code in <code>src/scrambler.py</code> <pre><code>def scramble(self, X, Y):\n    r\"\"\"\n    Embaralha os vetores X e Y de mesmo comprimento, retornando os vetores embaralhados.\n\n    Args:\n        X (np.ndarray): Vetor de entrada $v_t^{(0)}$.\n        Y (np.ndarray): Vetor de entrada $v_t^{(1)}$.\n\n    Returns:\n        X_scrambled (np.ndarray): Vetor $X_n$ embaralhado.\n        Y_scrambled (np.ndarray): Vetor $Y_n$ embaralhado.\n\n    Raises:\n        AssertionError: Se os vetores X e Y n\u00e3o tiverem o mesmo comprimento.\n    \"\"\"\n    assert len(X) == len(Y), \"Vetores X e Y devem ter o mesmo comprimento\"\n    X_scrambled = []\n    Y_scrambled = []\n\n    for i in range(0, len(X), 3):\n        x_blk = X[i:i+3]\n        y_blk = Y[i:i+3]\n        n = len(x_blk)\n\n        if n == 3:\n            # Embaralhamento do bloco [x1, x2, x3], [y1, y2, y3]\n            x1, x2, x3 = x_blk\n            y1, y2, y3 = y_blk\n            X_scrambled += [y1, x2, y2]\n            Y_scrambled += [x1, x3, y3]\n        elif n == 2:\n            # Embaralhamento do bloco [x1, x2], [y1, y2]\n            x1, x2 = x_blk\n            y1, y2 = y_blk\n            X_scrambled += [y1, x2]\n            Y_scrambled += [x1, y2]\n        elif n == 1:\n            # Embaralhamento do bloco [x1], [y1]\n            x1 = x_blk[0]\n            y1 = y_blk[0]\n            X_scrambled += [y1]\n            Y_scrambled += [x1]\n\n    return X_scrambled, Y_scrambled\n</code></pre>"},{"location":"api/scrambler/#scrambler.Scrambler.descramble","title":"<code>descramble(X, Y)</code>","text":"<p>Restaura os vetores X e Y embaralhados ao seu estado original.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Vetor \\(X'_{n}\\) embaralhado.</p> required <code>Y</code> <code>ndarray</code> <p>Vetor \\(Y'_{n}\\) embaralhado.</p> required <p>Returns:</p> Name Type Description <code>msg_length</code> <code>ndarray</code> <p>Vetor de 4 bits representando o campo Message Length.</p> <p>Returns:</p> Name Type Description <code>X_original</code> <code>ndarray</code> <p>Vetor \\(v_t^{(0)}\\) restaurado.</p> <code>Y_original</code> <code>ndarray</code> <p>Vetor \\(v_t^{(1)}\\) restaurado.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>Se os vetores X e Y n\u00e3o tiverem o mesmo comprimento.</p> Source code in <code>src/scrambler.py</code> <pre><code>def descramble(self, X, Y):\n    r\"\"\"\n    Restaura os vetores X e Y embaralhados ao seu estado original.\n\n    Args:\n        X (np.ndarray): Vetor $X'_{n}$ embaralhado.\n        Y (np.ndarray): Vetor $Y'_{n}$ embaralhado.\n\n    Returns:\n       msg_length (np.ndarray): Vetor de 4 bits representando o campo Message Length.\n\n    Returns:\n        X_original (np.ndarray): Vetor $v_t^{(0)}$ restaurado.\n        Y_original (np.ndarray): Vetor $v_t^{(1)}$ restaurado.\n\n    Raises:\n        AssertionError: Se os vetores X e Y n\u00e3o tiverem o mesmo comprimento.\n    \"\"\"\n    assert len(X) == len(Y), \"Vetores X e Y devem ter o mesmo comprimento\"\n    X_original = []\n    Y_original = []\n\n    for i in range(0, len(X), 3):\n        x_blk = X[i:i+3]\n        y_blk = Y[i:i+3]\n        n = len(x_blk)\n\n        if n == 3:\n            # Desembaralhamento do bloco [y1, x2, y2], [x1, x3, y3]\n            x1, x2, x3 = y_blk[0], x_blk[1], y_blk[1]\n            y1, y2, y3 = x_blk[0], x_blk[2], y_blk[2]\n            X_original.extend([x1, x2, x3])\n            Y_original.extend([y1, y2, y3])\n        elif n == 2:\n            # Desembaralhamento do bloco [y1, x2], [x1, y2]\n            x1, x2 = y_blk[0], x_blk[1]\n            y1, y2 = x_blk[0], y_blk[1]\n            X_original.extend([x1, x2])\n            Y_original.extend([y1, y2])\n        elif n == 1:\n            # Desembaralhamento do bloco [y1], [x1]\n            x1 = y_blk[0]\n            y1 = x_blk[0]\n            X_original.append(x1)\n            Y_original.append(y1)\n\n    return X_original, Y_original\n</code></pre>"},{"location":"api/transmitter/","title":"Transmissor","text":"Source code in <code>src/transmitter.py</code> <pre><code>class Transmitter:\n    def __init__(self, datagram: Datagram, fc=4000, fs=128_000, Rb=400, \n                 output_print=True, output_plot=True):\n        r\"\"\"\n        Classe que encapsula todo o processo de transmiss\u00e3o, desde a prepara\u00e7\u00e3o do datagrama at\u00e9 a\n        modula\u00e7\u00e3o do sinal.\n\n        Args:\n            datagram (Datagram): Inst\u00e2ncia do datagrama a ser transmitido.\n            fc (float): Frequ\u00eancia da portadora em Hz. Default \u00e9 4000 Hz\n            fs (float): Frequ\u00eancia de amostragem em Hz. Default \u00e9 128000 Hz.\n            Rb (float): Taxa de bits em bps. Default \u00e9 400 b\n            output_print (bool): Se True, imprime os vetores intermedi\u00e1rios no console. Default \u00e9 True.\n            output_plot (bool): Se True, gera e salva os gr\u00e1ficos dos processos intermedi\u00e1rios.\n        \"\"\"\n        self.datagram = datagram\n        self.fc = fc\n        self.fs = fs\n        self.Rb = Rb\n        self.output_print = output_print\n        self.output_plot = output_plot\n        self.plotter = Plotter()\n\n    def prepare_datagram(self):\n        r\"\"\"\n        Prepara o datagrama para transmiss\u00e3o, retornando o vetor de bits $u_t$.\n\n        Returns:\n            ut (np.ndarray): Vetor de bits do datagrama.\n        \"\"\"\n        ut = self.datagram.streambits\n        if self.output_print:\n            print(\"\\n ==== MONTAGEM DATAGRAMA ==== \\n\")\n            print(self.datagram.parse_datagram())\n            print(\"\\nut:\", ''.join(map(str, ut)))\n        if self.output_plot:\n            self.plotter.plot_bits(\n                [self.datagram.msglength, self.datagram.pcdid, self.datagram.blocks, self.datagram.tail],\n                sections=[\n                    (\"Message Length\", len(self.datagram.msglength)),\n                    (\"PCD ID\", len(self.datagram.pcdid)),\n                    (\"Dados de App.\", len(self.datagram.blocks)),\n                    (\"Tail\", len(self.datagram.tail))\n                ],\n                colors=[\"green\", \"orange\", \"red\", \"blue\"],\n                save_path=\"../out/transmitter_datagram.pdf\"\n            )\n        return ut\n\n    def encode_convolutional(self, ut):\n        r\"\"\"\n        Codifica o vetor de bits $u_t$ usando codifica\u00e7\u00e3o convolucional.\n\n        Args:\n            ut (np.ndarray): Vetor de bits a ser codificado.\n\n        Returns:\n            vt0 (np.ndarray): Sa\u00edda do canal I.\n            vt1 (np.ndarray): Sa\u00edda do canal Q.\n        \"\"\"\n        encoder = EncoderConvolutional()\n        vt0, vt1 = encoder.encode(ut)\n        if self.output_print:\n            print(\"\\n ==== CODIFICADOR CONVOLUCIONAL ==== \\n\")\n            print(\"vt0:\", ''.join(map(str, vt0)))\n            print(\"vt1:\", ''.join(map(str, vt1)))\n        if self.output_plot:\n            self.plotter.plot_conv(\n                ut, vt0, vt1, \"Entrada $u_t$\",\n                \"Canal I $v_t^{(0)}$\", \"Canal Q $v_t^{(1)}$\",\n                \"$u_t$\", \"$v_t^{(0)}$\", \"$v_t^{(1)}$\",\n                save_path=\"../out/transmitter_convolutional.pdf\"\n            )\n        return vt0, vt1\n\n    def scramble(self, vt0, vt1):\n        r\"\"\"\n        Embaralha os vetores de bits dos canais I e Q.\n\n        Args:\n            vt0 (np.ndarray): Vetor de bits do canal I.\n            vt1 (np.ndarray): Vetor de bits do canal Q.\n\n        Returns:\n            Xn (np.ndarray): Vetor embaralhado do canal I.\n            Yn (np.ndarray): Vetor embaralhado do canal Q.\n        \"\"\"\n        scrambler = Scrambler()\n        X, Y = scrambler.scramble(vt0, vt1)\n        if self.output_print:\n            print(\"\\n ==== EMBARALHADOR ==== \\n\")\n            print(\"Xn:\", ''.join(map(str, X)))\n            print(\"Yn:\", ''.join(map(str, Y)))\n        return X, Y\n\n    def generate_preamble(self):\n        r\"\"\"\n        Gera os vetores de pre\u00e2mbulo $S_I$ e $S_Q$.\n\n        Returns:\n            sI (np.ndarray): Vetor do pre\u00e2mbulo do canal I.\n            sQ (np.ndarray): Vetor do pre\u00e2mbulo do canal Q.\n        \"\"\"\n        sI, sQ = Preamble().generate_preamble()\n        if self.output_print:\n            print(\"\\n ==== MONTAGEM PREAMBULO ==== \\n\")\n            print(\"sI:\", ''.join(map(str, sI)))\n            print(\"sQ:\", ''.join(map(str, sQ)))\n        if self.output_plot:\n            self.plotter.plot_preamble(\n                sI, sQ, r\"$S_i$\", r\"$S_q$\",\n                r\"Canal $I$\", r\"Canal $Q$\",\n                save_path=\"../out/transmitter_preamble.pdf\"\n            )\n        return sI, sQ\n\n    def multiplex(self, sI, sQ, X, Y):\n        r\"\"\"\n        Multiplexa os vetores de pre\u00e2mbulo e dados dos canais I e Q.\n\n        Args:\n            sI (np.ndarray): Vetor do pre\u00e2mbulo do canal I.\n            sQ (np.ndarray): Vetor do pre\u00e2mbulo do canal Q.\n            X (np.ndarray): Vetor de dados do canal I.\n            Y (np.ndarray): Vetor de dados do canal Q.\n\n        Returns:\n            Xn (np.ndarray): Vetor multiplexado do canal I.\n            Yn (np.ndarray): Vetor multiplexado do canal Q.\n        \"\"\"\n\n        multiplexer = Multiplexer()\n        Xn, Yn = multiplexer.concatenate(sI, sQ, X, Y)\n        if self.output_print:\n            print(\"\\n ==== MULTIPLEXADOR ==== \\n\")\n            print(\"Xn:\", ''.join(map(str, Xn)))\n            print(\"Yn:\", ''.join(map(str, Yn)))\n        if self.output_plot:\n            self.plotter.plot_mux(\n                sI, sQ, X, Y,\n                \"Preambulo $S_I$\", \"Canal I $(X_n)$\",\n                \"Preambulo $S_Q$\", \"Canal Q $(Y_n)$\",\n                \"$X_n$\", \"$Y_n$\",\n                save_path=\"../out/transmitter_multiplexing.pdf\"\n            )\n        return Xn, Yn\n\n    def encode_channels(self, Xn, Yn):\n        r\"\"\"\n        Codifica os vetores dos canais I e Q usando NRZ e Manchester, respectivamente.\n\n        Args:\n            Xn (np.ndarray): Vetor do canal I a ser codificado.\n            Yn (np.ndarray): Vetor do canal Q a ser codificado.\n\n        Returns:\n            Xnrz (np.ndarray): Vetor codificado do canal I (NRZ).\n            Yman (np.ndarray): Vetor codificado do canal Q (Manchester).\n        \"\"\"\n\n        encoderNRZ = Encoder(\"nrz\")\n        encoderManchester = Encoder(\"manchester\")\n        Xnrz = encoderNRZ.encode(Xn)\n        Yman = encoderManchester.encode(Yn)\n        if self.output_print:\n            print(\"\\n ==== CODIFICA\u00c7\u00c3O DE LINHA ==== \\n\")\n            print(\"Xnrz:\", ''.join(map(str, Xnrz[:80])),\"...\")\n            print(\"Yman:\", ''.join(map(str, Yman[:80])),\"...\")\n        if self.output_plot:\n            self.plotter.plot_encode(\n                Xn, Yn, Xnrz, Yman,\n                \"Canal I $(X_n)$\", \"Canal Q $(Y_n)$\",\n                \"Canal I $(X_{NRZ}[n])$\", \"Canal Q $(Y_{MAN}[n])$\",\n                \"$X_n$\", \"$Y_n$\", \"$X_{NRZ}[n]$\", \"$Y_{MAN}[n]$\",\n                save_path=\"../out/transmitter_encode.pdf\"\n            )\n        return Xnrz, Yman\n\n    def format_signals(self, Xnrz, Yman):\n        r\"\"\"\n        Formata os vetores dos canais I e Q usando filtro RRC.\n\n        Args:\n            Xnrz (np.ndarray): Vetor do canal I a ser formatado.\n            Yman (np.ndarray): Vetor do canal Q a ser formatado.\n\n        Returns:\n            dI (np.ndarray): Vetor formatado do canal I.\n            dQ (np.ndarray): Vetor formatado do canal Q.\n        \"\"\"\n        formatter = Formatter()\n        dI = formatter.apply_format(Xnrz)\n        dQ = formatter.apply_format(Yman)\n        if self.output_print:\n            print(\"\\n ==== FORMATADOR ==== \\n\")\n            print(\"dI:\", ''.join(map(str, dI[:5])),\"...\")\n            print(\"dQ:\", ''.join(map(str, dQ[:5])),\"...\")\n        if self.output_plot:\n            self.plotter.plot_filter(\n                formatter.g, formatter.t_rc, formatter.Tb,\n                formatter.span, formatter.fs, dI, dQ,\n                fr'Pulso RRC ($\\alpha={formatter.alpha}$)',\n                fr'$d_I(t)$', fr'$d_Q(t)$',\n                'Pulso Root Raised Cosine (RRC)',\n                fr'Sinal $d_I(t)$', fr'Sinal $d_Q(t)$',\n                0.05, save_path=\"../out/transmitter_filter.pdf\"\n            )\n        return dI, dQ\n\n    def modulate(self, dI, dQ):\n        r\"\"\"\n        Modula os vetores formatados dos canais I e Q usando modula\u00e7\u00e3o QPSK.\n\n        Args:\n            dI (np.ndarray): Vetor formatado do canal I.\n            dQ (np.ndarray): Vetor formatado do canal Q.\n\n        Returns:\n\n            t (np.ndarray): Vetor de tempo.\n            s (np.ndarray): Sinal modulado.\n        \"\"\"\n        modulator = Modulator(fc=self.fc, fs=self.fs)\n        t, s = modulator.modulate(dI, dQ)\n        if self.output_print:\n            print(\"\\n ==== MODULADOR ==== \\n\")\n            print(\"s(t):\", ''.join(map(str, s[:5])),\"...\")\n            print(\"t:   \", ''.join(map(str, t[:5])),\"...\")\n        if self.output_plot:\n            self.plotter.plot_modulation_time(\n                dI, dQ, s, \"dI(t)\", \"dQ(t)\", \"s(t)\",\n                \"Sinal $IQ$ - Formatados RRC\", \"Sinal Modulado $IQ$\",\n                fs=self.fs, t_xlim=0.10,\n                save_path=\"../out/transmitter_modulator_time.pdf\"\n            )\n            self.plotter.plot_modulation_freq(\n                dI, dQ, s,\n                \"$D_I'(f)$\", \"$D_Q'(f)$\", \"$S(f)$\",\n                \"Sinal Banda Base - Componente $I$\",\n                \"Sinal Banda Base - Componente $Q$\",\n                \"Sinal Modulado $IQ$\",\n                fs=self.fs, fc=self.fc,\n                save_path=\"../out/transmitter_modulator_freq.pdf\"\n            )\n            self.plotter.plot_modulation_iq(\n                dI, dQ,\n                fr'Amostras $IQ$', fr'Simbolos $QPSK$',\n                fr'Plano $IQ$ (Scatter)', fr'Plano $IQ$ (Constela\u00e7\u00e3o)',\n                save_path=\"../out/transmitter_modulator_iq.pdf\"\n            )\n        return t, s\n\n    def run(self):\n        r\"\"\"\n        Executa o processo de transmiss\u00e3o, retornando o resultado da transmiss\u00e3o.\n\n        Returns:\n            t (np.ndarray): Vetor de tempo.\n            s (np.ndarray): Sinal modulado $s(t)$.\n        \"\"\"\n        ut = self.prepare_datagram()\n        vt0, vt1 = self.encode_convolutional(ut)\n        X, Y = self.scramble(vt0, vt1)\n        sI, sQ = self.generate_preamble()\n        Xn, Yn = self.multiplex(sI, sQ, X, Y)\n        Xnrz, Yman = self.encode_channels(Xn, Yn)\n        dI, dQ = self.format_signals(Xnrz, Yman)\n        t, s = self.modulate(dI, dQ)\n        return t, s\n</code></pre> <p>Classe para armazenar o resultado da transmiss\u00e3o, incluindo o sinal modulado e o vetor de tempo.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> required <code>s</code> <code>ndarray</code> <p>Sinal modulado.</p> required Source code in <code>src/transmitter.py</code> <pre><code>class TransmissionResult:\n    r\"\"\"\n    Classe para armazenar o resultado da transmiss\u00e3o, incluindo o sinal modulado e o vetor de tempo.\n\n    Args:\n        t (np.ndarray): Vetor de tempo.\n        s (np.ndarray): Sinal modulado.\n    \"\"\"\n    def __init__(self, t, s):\n        self.time = t\n        self.signal = s\n\n    def save(self, path_prefix=\"../out/transmission\"):\n        r\"\"\"\n        Salva os resultados em arquivos TXT.\n        \"\"\"\n        script_dir = os.path.dirname(os.path.abspath(__file__))\n        basepath = os.path.normpath(os.path.join(script_dir, path_prefix))\n\n        os.makedirs(os.path.dirname(basepath), exist_ok=True)\n\n        with open(f\"{basepath}_signal.txt\", \"w\") as f:\n            f.write(\" \".join(map(str, self.signal)))\n\n        with open(f\"{basepath}_time.txt\", \"w\") as f:\n            f.write(\" \".join(map(str, self.time)))\n</code></pre>"},{"location":"api/transmitter/#transmitter.Transmitter.__init__","title":"<code>__init__(datagram, fc=4000, fs=128000, Rb=400, output_print=True, output_plot=True)</code>","text":"<p>Classe que encapsula todo o processo de transmiss\u00e3o, desde a prepara\u00e7\u00e3o do datagrama at\u00e9 a modula\u00e7\u00e3o do sinal.</p> <p>Parameters:</p> Name Type Description Default <code>datagram</code> <code>Datagram</code> <p>Inst\u00e2ncia do datagrama a ser transmitido.</p> required <code>fc</code> <code>float</code> <p>Frequ\u00eancia da portadora em Hz. Default \u00e9 4000 Hz</p> <code>4000</code> <code>fs</code> <code>float</code> <p>Frequ\u00eancia de amostragem em Hz. Default \u00e9 128000 Hz.</p> <code>128000</code> <code>Rb</code> <code>float</code> <p>Taxa de bits em bps. Default \u00e9 400 b</p> <code>400</code> <code>output_print</code> <code>bool</code> <p>Se True, imprime os vetores intermedi\u00e1rios no console. Default \u00e9 True.</p> <code>True</code> <code>output_plot</code> <code>bool</code> <p>Se True, gera e salva os gr\u00e1ficos dos processos intermedi\u00e1rios.</p> <code>True</code> Source code in <code>src/transmitter.py</code> <pre><code>def __init__(self, datagram: Datagram, fc=4000, fs=128_000, Rb=400, \n             output_print=True, output_plot=True):\n    r\"\"\"\n    Classe que encapsula todo o processo de transmiss\u00e3o, desde a prepara\u00e7\u00e3o do datagrama at\u00e9 a\n    modula\u00e7\u00e3o do sinal.\n\n    Args:\n        datagram (Datagram): Inst\u00e2ncia do datagrama a ser transmitido.\n        fc (float): Frequ\u00eancia da portadora em Hz. Default \u00e9 4000 Hz\n        fs (float): Frequ\u00eancia de amostragem em Hz. Default \u00e9 128000 Hz.\n        Rb (float): Taxa de bits em bps. Default \u00e9 400 b\n        output_print (bool): Se True, imprime os vetores intermedi\u00e1rios no console. Default \u00e9 True.\n        output_plot (bool): Se True, gera e salva os gr\u00e1ficos dos processos intermedi\u00e1rios.\n    \"\"\"\n    self.datagram = datagram\n    self.fc = fc\n    self.fs = fs\n    self.Rb = Rb\n    self.output_print = output_print\n    self.output_plot = output_plot\n    self.plotter = Plotter()\n</code></pre>"},{"location":"api/transmitter/#transmitter.Transmitter.prepare_datagram","title":"<code>prepare_datagram()</code>","text":"<p>Prepara o datagrama para transmiss\u00e3o, retornando o vetor de bits \\(u_t\\).</p> <p>Returns:</p> Name Type Description <code>ut</code> <code>ndarray</code> <p>Vetor de bits do datagrama.</p> Source code in <code>src/transmitter.py</code> <pre><code>def prepare_datagram(self):\n    r\"\"\"\n    Prepara o datagrama para transmiss\u00e3o, retornando o vetor de bits $u_t$.\n\n    Returns:\n        ut (np.ndarray): Vetor de bits do datagrama.\n    \"\"\"\n    ut = self.datagram.streambits\n    if self.output_print:\n        print(\"\\n ==== MONTAGEM DATAGRAMA ==== \\n\")\n        print(self.datagram.parse_datagram())\n        print(\"\\nut:\", ''.join(map(str, ut)))\n    if self.output_plot:\n        self.plotter.plot_bits(\n            [self.datagram.msglength, self.datagram.pcdid, self.datagram.blocks, self.datagram.tail],\n            sections=[\n                (\"Message Length\", len(self.datagram.msglength)),\n                (\"PCD ID\", len(self.datagram.pcdid)),\n                (\"Dados de App.\", len(self.datagram.blocks)),\n                (\"Tail\", len(self.datagram.tail))\n            ],\n            colors=[\"green\", \"orange\", \"red\", \"blue\"],\n            save_path=\"../out/transmitter_datagram.pdf\"\n        )\n    return ut\n</code></pre>"},{"location":"api/transmitter/#transmitter.Transmitter.encode_convolutional","title":"<code>encode_convolutional(ut)</code>","text":"<p>Codifica o vetor de bits \\(u_t\\) usando codifica\u00e7\u00e3o convolucional.</p> <p>Parameters:</p> Name Type Description Default <code>ut</code> <code>ndarray</code> <p>Vetor de bits a ser codificado.</p> required <p>Returns:</p> Name Type Description <code>vt0</code> <code>ndarray</code> <p>Sa\u00edda do canal I.</p> <code>vt1</code> <code>ndarray</code> <p>Sa\u00edda do canal Q.</p> Source code in <code>src/transmitter.py</code> <pre><code>def encode_convolutional(self, ut):\n    r\"\"\"\n    Codifica o vetor de bits $u_t$ usando codifica\u00e7\u00e3o convolucional.\n\n    Args:\n        ut (np.ndarray): Vetor de bits a ser codificado.\n\n    Returns:\n        vt0 (np.ndarray): Sa\u00edda do canal I.\n        vt1 (np.ndarray): Sa\u00edda do canal Q.\n    \"\"\"\n    encoder = EncoderConvolutional()\n    vt0, vt1 = encoder.encode(ut)\n    if self.output_print:\n        print(\"\\n ==== CODIFICADOR CONVOLUCIONAL ==== \\n\")\n        print(\"vt0:\", ''.join(map(str, vt0)))\n        print(\"vt1:\", ''.join(map(str, vt1)))\n    if self.output_plot:\n        self.plotter.plot_conv(\n            ut, vt0, vt1, \"Entrada $u_t$\",\n            \"Canal I $v_t^{(0)}$\", \"Canal Q $v_t^{(1)}$\",\n            \"$u_t$\", \"$v_t^{(0)}$\", \"$v_t^{(1)}$\",\n            save_path=\"../out/transmitter_convolutional.pdf\"\n        )\n    return vt0, vt1\n</code></pre>"},{"location":"api/transmitter/#transmitter.Transmitter.scramble","title":"<code>scramble(vt0, vt1)</code>","text":"<p>Embaralha os vetores de bits dos canais I e Q.</p> <p>Parameters:</p> Name Type Description Default <code>vt0</code> <code>ndarray</code> <p>Vetor de bits do canal I.</p> required <code>vt1</code> <code>ndarray</code> <p>Vetor de bits do canal Q.</p> required <p>Returns:</p> Name Type Description <code>Xn</code> <code>ndarray</code> <p>Vetor embaralhado do canal I.</p> <code>Yn</code> <code>ndarray</code> <p>Vetor embaralhado do canal Q.</p> Source code in <code>src/transmitter.py</code> <pre><code>def scramble(self, vt0, vt1):\n    r\"\"\"\n    Embaralha os vetores de bits dos canais I e Q.\n\n    Args:\n        vt0 (np.ndarray): Vetor de bits do canal I.\n        vt1 (np.ndarray): Vetor de bits do canal Q.\n\n    Returns:\n        Xn (np.ndarray): Vetor embaralhado do canal I.\n        Yn (np.ndarray): Vetor embaralhado do canal Q.\n    \"\"\"\n    scrambler = Scrambler()\n    X, Y = scrambler.scramble(vt0, vt1)\n    if self.output_print:\n        print(\"\\n ==== EMBARALHADOR ==== \\n\")\n        print(\"Xn:\", ''.join(map(str, X)))\n        print(\"Yn:\", ''.join(map(str, Y)))\n    return X, Y\n</code></pre>"},{"location":"api/transmitter/#transmitter.Transmitter.generate_preamble","title":"<code>generate_preamble()</code>","text":"<p>Gera os vetores de pre\u00e2mbulo \\(S_I\\) e \\(S_Q\\).</p> <p>Returns:</p> Name Type Description <code>sI</code> <code>ndarray</code> <p>Vetor do pre\u00e2mbulo do canal I.</p> <code>sQ</code> <code>ndarray</code> <p>Vetor do pre\u00e2mbulo do canal Q.</p> Source code in <code>src/transmitter.py</code> <pre><code>def generate_preamble(self):\n    r\"\"\"\n    Gera os vetores de pre\u00e2mbulo $S_I$ e $S_Q$.\n\n    Returns:\n        sI (np.ndarray): Vetor do pre\u00e2mbulo do canal I.\n        sQ (np.ndarray): Vetor do pre\u00e2mbulo do canal Q.\n    \"\"\"\n    sI, sQ = Preamble().generate_preamble()\n    if self.output_print:\n        print(\"\\n ==== MONTAGEM PREAMBULO ==== \\n\")\n        print(\"sI:\", ''.join(map(str, sI)))\n        print(\"sQ:\", ''.join(map(str, sQ)))\n    if self.output_plot:\n        self.plotter.plot_preamble(\n            sI, sQ, r\"$S_i$\", r\"$S_q$\",\n            r\"Canal $I$\", r\"Canal $Q$\",\n            save_path=\"../out/transmitter_preamble.pdf\"\n        )\n    return sI, sQ\n</code></pre>"},{"location":"api/transmitter/#transmitter.Transmitter.multiplex","title":"<code>multiplex(sI, sQ, X, Y)</code>","text":"<p>Multiplexa os vetores de pre\u00e2mbulo e dados dos canais I e Q.</p> <p>Parameters:</p> Name Type Description Default <code>sI</code> <code>ndarray</code> <p>Vetor do pre\u00e2mbulo do canal I.</p> required <code>sQ</code> <code>ndarray</code> <p>Vetor do pre\u00e2mbulo do canal Q.</p> required <code>X</code> <code>ndarray</code> <p>Vetor de dados do canal I.</p> required <code>Y</code> <code>ndarray</code> <p>Vetor de dados do canal Q.</p> required <p>Returns:</p> Name Type Description <code>Xn</code> <code>ndarray</code> <p>Vetor multiplexado do canal I.</p> <code>Yn</code> <code>ndarray</code> <p>Vetor multiplexado do canal Q.</p> Source code in <code>src/transmitter.py</code> <pre><code>def multiplex(self, sI, sQ, X, Y):\n    r\"\"\"\n    Multiplexa os vetores de pre\u00e2mbulo e dados dos canais I e Q.\n\n    Args:\n        sI (np.ndarray): Vetor do pre\u00e2mbulo do canal I.\n        sQ (np.ndarray): Vetor do pre\u00e2mbulo do canal Q.\n        X (np.ndarray): Vetor de dados do canal I.\n        Y (np.ndarray): Vetor de dados do canal Q.\n\n    Returns:\n        Xn (np.ndarray): Vetor multiplexado do canal I.\n        Yn (np.ndarray): Vetor multiplexado do canal Q.\n    \"\"\"\n\n    multiplexer = Multiplexer()\n    Xn, Yn = multiplexer.concatenate(sI, sQ, X, Y)\n    if self.output_print:\n        print(\"\\n ==== MULTIPLEXADOR ==== \\n\")\n        print(\"Xn:\", ''.join(map(str, Xn)))\n        print(\"Yn:\", ''.join(map(str, Yn)))\n    if self.output_plot:\n        self.plotter.plot_mux(\n            sI, sQ, X, Y,\n            \"Preambulo $S_I$\", \"Canal I $(X_n)$\",\n            \"Preambulo $S_Q$\", \"Canal Q $(Y_n)$\",\n            \"$X_n$\", \"$Y_n$\",\n            save_path=\"../out/transmitter_multiplexing.pdf\"\n        )\n    return Xn, Yn\n</code></pre>"},{"location":"api/transmitter/#transmitter.Transmitter.encode_channels","title":"<code>encode_channels(Xn, Yn)</code>","text":"<p>Codifica os vetores dos canais I e Q usando NRZ e Manchester, respectivamente.</p> <p>Parameters:</p> Name Type Description Default <code>Xn</code> <code>ndarray</code> <p>Vetor do canal I a ser codificado.</p> required <code>Yn</code> <code>ndarray</code> <p>Vetor do canal Q a ser codificado.</p> required <p>Returns:</p> Name Type Description <code>Xnrz</code> <code>ndarray</code> <p>Vetor codificado do canal I (NRZ).</p> <code>Yman</code> <code>ndarray</code> <p>Vetor codificado do canal Q (Manchester).</p> Source code in <code>src/transmitter.py</code> <pre><code>def encode_channels(self, Xn, Yn):\n    r\"\"\"\n    Codifica os vetores dos canais I e Q usando NRZ e Manchester, respectivamente.\n\n    Args:\n        Xn (np.ndarray): Vetor do canal I a ser codificado.\n        Yn (np.ndarray): Vetor do canal Q a ser codificado.\n\n    Returns:\n        Xnrz (np.ndarray): Vetor codificado do canal I (NRZ).\n        Yman (np.ndarray): Vetor codificado do canal Q (Manchester).\n    \"\"\"\n\n    encoderNRZ = Encoder(\"nrz\")\n    encoderManchester = Encoder(\"manchester\")\n    Xnrz = encoderNRZ.encode(Xn)\n    Yman = encoderManchester.encode(Yn)\n    if self.output_print:\n        print(\"\\n ==== CODIFICA\u00c7\u00c3O DE LINHA ==== \\n\")\n        print(\"Xnrz:\", ''.join(map(str, Xnrz[:80])),\"...\")\n        print(\"Yman:\", ''.join(map(str, Yman[:80])),\"...\")\n    if self.output_plot:\n        self.plotter.plot_encode(\n            Xn, Yn, Xnrz, Yman,\n            \"Canal I $(X_n)$\", \"Canal Q $(Y_n)$\",\n            \"Canal I $(X_{NRZ}[n])$\", \"Canal Q $(Y_{MAN}[n])$\",\n            \"$X_n$\", \"$Y_n$\", \"$X_{NRZ}[n]$\", \"$Y_{MAN}[n]$\",\n            save_path=\"../out/transmitter_encode.pdf\"\n        )\n    return Xnrz, Yman\n</code></pre>"},{"location":"api/transmitter/#transmitter.Transmitter.format_signals","title":"<code>format_signals(Xnrz, Yman)</code>","text":"<p>Formata os vetores dos canais I e Q usando filtro RRC.</p> <p>Parameters:</p> Name Type Description Default <code>Xnrz</code> <code>ndarray</code> <p>Vetor do canal I a ser formatado.</p> required <code>Yman</code> <code>ndarray</code> <p>Vetor do canal Q a ser formatado.</p> required <p>Returns:</p> Name Type Description <code>dI</code> <code>ndarray</code> <p>Vetor formatado do canal I.</p> <code>dQ</code> <code>ndarray</code> <p>Vetor formatado do canal Q.</p> Source code in <code>src/transmitter.py</code> <pre><code>def format_signals(self, Xnrz, Yman):\n    r\"\"\"\n    Formata os vetores dos canais I e Q usando filtro RRC.\n\n    Args:\n        Xnrz (np.ndarray): Vetor do canal I a ser formatado.\n        Yman (np.ndarray): Vetor do canal Q a ser formatado.\n\n    Returns:\n        dI (np.ndarray): Vetor formatado do canal I.\n        dQ (np.ndarray): Vetor formatado do canal Q.\n    \"\"\"\n    formatter = Formatter()\n    dI = formatter.apply_format(Xnrz)\n    dQ = formatter.apply_format(Yman)\n    if self.output_print:\n        print(\"\\n ==== FORMATADOR ==== \\n\")\n        print(\"dI:\", ''.join(map(str, dI[:5])),\"...\")\n        print(\"dQ:\", ''.join(map(str, dQ[:5])),\"...\")\n    if self.output_plot:\n        self.plotter.plot_filter(\n            formatter.g, formatter.t_rc, formatter.Tb,\n            formatter.span, formatter.fs, dI, dQ,\n            fr'Pulso RRC ($\\alpha={formatter.alpha}$)',\n            fr'$d_I(t)$', fr'$d_Q(t)$',\n            'Pulso Root Raised Cosine (RRC)',\n            fr'Sinal $d_I(t)$', fr'Sinal $d_Q(t)$',\n            0.05, save_path=\"../out/transmitter_filter.pdf\"\n        )\n    return dI, dQ\n</code></pre>"},{"location":"api/transmitter/#transmitter.Transmitter.modulate","title":"<code>modulate(dI, dQ)</code>","text":"<p>Modula os vetores formatados dos canais I e Q usando modula\u00e7\u00e3o QPSK.</p> <p>Parameters:</p> Name Type Description Default <code>dI</code> <code>ndarray</code> <p>Vetor formatado do canal I.</p> required <code>dQ</code> <code>ndarray</code> <p>Vetor formatado do canal Q.</p> required <p>Returns:</p> <pre><code>t (np.ndarray): Vetor de tempo.\ns (np.ndarray): Sinal modulado.\n</code></pre> Source code in <code>src/transmitter.py</code> <pre><code>def modulate(self, dI, dQ):\n    r\"\"\"\n    Modula os vetores formatados dos canais I e Q usando modula\u00e7\u00e3o QPSK.\n\n    Args:\n        dI (np.ndarray): Vetor formatado do canal I.\n        dQ (np.ndarray): Vetor formatado do canal Q.\n\n    Returns:\n\n        t (np.ndarray): Vetor de tempo.\n        s (np.ndarray): Sinal modulado.\n    \"\"\"\n    modulator = Modulator(fc=self.fc, fs=self.fs)\n    t, s = modulator.modulate(dI, dQ)\n    if self.output_print:\n        print(\"\\n ==== MODULADOR ==== \\n\")\n        print(\"s(t):\", ''.join(map(str, s[:5])),\"...\")\n        print(\"t:   \", ''.join(map(str, t[:5])),\"...\")\n    if self.output_plot:\n        self.plotter.plot_modulation_time(\n            dI, dQ, s, \"dI(t)\", \"dQ(t)\", \"s(t)\",\n            \"Sinal $IQ$ - Formatados RRC\", \"Sinal Modulado $IQ$\",\n            fs=self.fs, t_xlim=0.10,\n            save_path=\"../out/transmitter_modulator_time.pdf\"\n        )\n        self.plotter.plot_modulation_freq(\n            dI, dQ, s,\n            \"$D_I'(f)$\", \"$D_Q'(f)$\", \"$S(f)$\",\n            \"Sinal Banda Base - Componente $I$\",\n            \"Sinal Banda Base - Componente $Q$\",\n            \"Sinal Modulado $IQ$\",\n            fs=self.fs, fc=self.fc,\n            save_path=\"../out/transmitter_modulator_freq.pdf\"\n        )\n        self.plotter.plot_modulation_iq(\n            dI, dQ,\n            fr'Amostras $IQ$', fr'Simbolos $QPSK$',\n            fr'Plano $IQ$ (Scatter)', fr'Plano $IQ$ (Constela\u00e7\u00e3o)',\n            save_path=\"../out/transmitter_modulator_iq.pdf\"\n        )\n    return t, s\n</code></pre>"},{"location":"api/transmitter/#transmitter.Transmitter.run","title":"<code>run()</code>","text":"<p>Executa o processo de transmiss\u00e3o, retornando o resultado da transmiss\u00e3o.</p> <p>Returns:</p> Name Type Description <code>t</code> <code>ndarray</code> <p>Vetor de tempo.</p> <code>s</code> <code>ndarray</code> <p>Sinal modulado \\(s(t)\\).</p> Source code in <code>src/transmitter.py</code> <pre><code>def run(self):\n    r\"\"\"\n    Executa o processo de transmiss\u00e3o, retornando o resultado da transmiss\u00e3o.\n\n    Returns:\n        t (np.ndarray): Vetor de tempo.\n        s (np.ndarray): Sinal modulado $s(t)$.\n    \"\"\"\n    ut = self.prepare_datagram()\n    vt0, vt1 = self.encode_convolutional(ut)\n    X, Y = self.scramble(vt0, vt1)\n    sI, sQ = self.generate_preamble()\n    Xn, Yn = self.multiplex(sI, sQ, X, Y)\n    Xnrz, Yman = self.encode_channels(Xn, Yn)\n    dI, dQ = self.format_signals(Xnrz, Yman)\n    t, s = self.modulate(dI, dQ)\n    return t, s\n</code></pre>"},{"location":"api/transmitter/#transmitter.TransmissionResult.save","title":"<code>save(path_prefix='../out/transmission')</code>","text":"<p>Salva os resultados em arquivos TXT.</p> Source code in <code>src/transmitter.py</code> <pre><code>def save(self, path_prefix=\"../out/transmission\"):\n    r\"\"\"\n    Salva os resultados em arquivos TXT.\n    \"\"\"\n    script_dir = os.path.dirname(os.path.abspath(__file__))\n    basepath = os.path.normpath(os.path.join(script_dir, path_prefix))\n\n    os.makedirs(os.path.dirname(basepath), exist_ok=True)\n\n    with open(f\"{basepath}_signal.txt\", \"w\") as f:\n        f.write(\" \".join(map(str, self.signal)))\n\n    with open(f\"{basepath}_time.txt\", \"w\") as f:\n        f.write(\" \".join(map(str, self.time)))\n</code></pre>"}]}